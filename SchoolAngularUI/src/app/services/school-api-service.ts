//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class WeeklyDayOffServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    weeklyDayOffSelect(academicYearId: number | undefined): Observable<WeeklyDayOffDto> {
        let url_ = this.baseUrl + "/api/WeeklyDayOff/WeeklyDayOffSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeeklyDayOffSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeeklyDayOffSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeeklyDayOffDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeeklyDayOffDto>;
        }));
    }

    protected processWeeklyDayOffSelect(response: HttpResponseBase): Observable<WeeklyDayOffDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeeklyDayOffDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeeklyDayOffDto>(null as any);
    }

    weeklyDayOffInsert(obj: WeeklyDayOffDto): Observable<number> {
        let url_ = this.baseUrl + "/api/WeeklyDayOff/WeeklyDayOffInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeeklyDayOffInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeeklyDayOffInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processWeeklyDayOffInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    applogin(model: LoginDto): Observable<UserLoginResponse> {
        let url_ = this.baseUrl + "/Auth/applogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserLoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserLoginResponse>;
        }));
    }

    protected processApplogin(response: HttpResponseBase): Observable<UserLoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLoginResponse>(null as any);
    }

    saveFCMToken(fCMToken: string): Observable<number> {
        let url_ = this.baseUrl + "/Auth/SaveFCMToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fCMToken);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFCMToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFCMToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveFCMToken(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    webLogin(model: LoginDto): Observable<UserLoginResponse> {
        let url_ = this.baseUrl + "/Auth/WebLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserLoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserLoginResponse>;
        }));
    }

    protected processWebLogin(response: HttpResponseBase): Observable<UserLoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLoginResponse>(null as any);
    }

    getUserRoleModulePermissionDetail(roleId: number | null | undefined): Observable<UserRoleModulePermissionDto> {
        let url_ = this.baseUrl + "/Auth/getUserRoleModulePermissionDetail?";
        if (roleId !== undefined && roleId !== null)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoleModulePermissionDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoleModulePermissionDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleModulePermissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleModulePermissionDto>;
        }));
    }

    protected processGetUserRoleModulePermissionDetail(response: HttpResponseBase): Observable<UserRoleModulePermissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleModulePermissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleModulePermissionDto>(null as any);
    }

    forgotPassword(forgotPasswordRequestDto: ForgotPasswordRequestDto): Observable<boolean> {
        let url_ = this.baseUrl + "/Auth/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(forgotPasswordRequestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    changePassword(resetPasswordRequestDto: ResetPasswordRequestDto): Observable<boolean> {
        let url_ = this.baseUrl + "/Auth/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetPasswordRequestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    resetPasswordByAdmin(userNameEncrpty: string | null | undefined, roleId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Auth/ResetPasswordByAdmin?";
        if (userNameEncrpty !== undefined && userNameEncrpty !== null)
            url_ += "userNameEncrpty=" + encodeURIComponent("" + userNameEncrpty) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPasswordByAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPasswordByAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processResetPasswordByAdmin(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class TransportPaymentAnalyticsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getTransportPaymentAnalyticsSchool(academicYearId: number | undefined): Observable<TransportPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalytics/GetTransportPaymentAnalyticsSchool?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportPaymentAnalyticsSchool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportPaymentAnalyticsSchool(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsDto>;
        }));
    }

    protected processGetTransportPaymentAnalyticsSchool(response: HttpResponseBase): Observable<TransportPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsDto>(null as any);
    }

    getTransportPaymentAnalyticsGrade(academicYearId: number | undefined): Observable<TransportPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalytics/GetTransportPaymentAnalyticsGrade?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportPaymentAnalyticsGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportPaymentAnalyticsGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsDto>;
        }));
    }

    protected processGetTransportPaymentAnalyticsGrade(response: HttpResponseBase): Observable<TransportPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsDto>(null as any);
    }

    getTransportPaymentAnalyticsDivision(gradeId: number | undefined, academicYearId: number | undefined): Observable<TransportPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalytics/GetTransportPaymentAnalyticsDivision?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportPaymentAnalyticsDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportPaymentAnalyticsDivision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsDto>;
        }));
    }

    protected processGetTransportPaymentAnalyticsDivision(response: HttpResponseBase): Observable<TransportPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsDto>(null as any);
    }

    getTransportPaymentAnalyticsStudent(gradeId: number | undefined, divisionId: number | undefined, academicYearId: number | undefined): Observable<TransportPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalytics/GetTransportPaymentAnalyticsStudent?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportPaymentAnalyticsStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportPaymentAnalyticsStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsDto>;
        }));
    }

    protected processGetTransportPaymentAnalyticsStudent(response: HttpResponseBase): Observable<TransportPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsDto>(null as any);
    }

    getTransportPaymentAnalyticsStaff(academicYearId: number | undefined): Observable<TransportPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalytics/GetTransportPaymentAnalyticsStaff?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportPaymentAnalyticsStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportPaymentAnalyticsStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsDto>;
        }));
    }

    protected processGetTransportPaymentAnalyticsStaff(response: HttpResponseBase): Observable<TransportPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsDto>(null as any);
    }

    getTransportPaymentAnalyticsStaffList(academicYearId: number | undefined): Observable<TransportPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalytics/GetTransportPaymentAnalyticsStaffList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportPaymentAnalyticsStaffList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportPaymentAnalyticsStaffList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsDto>;
        }));
    }

    protected processGetTransportPaymentAnalyticsStaffList(response: HttpResponseBase): Observable<TransportPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsDto>(null as any);
    }
}

@Injectable()
export class TransportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getAreaSelect(areaId: number | undefined, academicYearId: number | undefined): Observable<AreaDto> {
        let url_ = this.baseUrl + "/api/Transport/GetAreaSelect?";
        if (areaId === null)
            throw new Error("The parameter 'areaId' cannot be null.");
        else if (areaId !== undefined)
            url_ += "areaId=" + encodeURIComponent("" + areaId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaDto>;
        }));
    }

    protected processGetAreaSelect(response: HttpResponseBase): Observable<AreaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDto>(null as any);
    }

    getAreaGridListSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Transport/GetAreaGridListSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaGridListSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaGridListSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetAreaGridListSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    areaDelete(areaId: number | undefined, academicYearId: number | undefined): Observable<AreaDeleteRespose> {
        let url_ = this.baseUrl + "/api/Transport/AreaDelete?";
        if (areaId === null)
            throw new Error("The parameter 'areaId' cannot be null.");
        else if (areaId !== undefined)
            url_ += "areaId=" + encodeURIComponent("" + areaId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAreaDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAreaDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaDeleteRespose>;
        }));
    }

    protected processAreaDelete(response: HttpResponseBase): Observable<AreaDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDeleteRespose>(null as any);
    }

    areaUpsert(academicYearId: number | undefined, areaDto: AreaDto): Observable<AreaDto> {
        let url_ = this.baseUrl + "/api/Transport/AreaUpsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(areaDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAreaUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAreaUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaDto>;
        }));
    }

    protected processAreaUpsert(response: HttpResponseBase): Observable<AreaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDto>(null as any);
    }

    getRouteSelect(routeId: number | undefined, academicYearId: number | undefined): Observable<RouteDto> {
        let url_ = this.baseUrl + "/api/Transport/GetRouteSelect?";
        if (routeId === null)
            throw new Error("The parameter 'routeId' cannot be null.");
        else if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRouteSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRouteSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteDto>;
        }));
    }

    protected processGetRouteSelect(response: HttpResponseBase): Observable<RouteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteDto>(null as any);
    }

    getRouteGridListSelect(request: RouteGridInputRequestDto): Observable<RouteListResponse> {
        let url_ = this.baseUrl + "/api/Transport/GetRouteGridListSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRouteGridListSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRouteGridListSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteListResponse>;
        }));
    }

    protected processGetRouteGridListSelect(response: HttpResponseBase): Observable<RouteListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteListResponse>(null as any);
    }

    routeDelete(routeId: number | undefined, academicYearId: number | undefined): Observable<RouteDeleteRespose> {
        let url_ = this.baseUrl + "/api/Transport/RouteDelete?";
        if (routeId === null)
            throw new Error("The parameter 'routeId' cannot be null.");
        else if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRouteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRouteDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteDeleteRespose>;
        }));
    }

    protected processRouteDelete(response: HttpResponseBase): Observable<RouteDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteDeleteRespose>(null as any);
    }

    routeUpsert(academicYearId: number | undefined, routeDto: RouteDto): Observable<RouteDto> {
        let url_ = this.baseUrl + "/api/Transport/RouteUpsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(routeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRouteUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRouteUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteDto>;
        }));
    }

    protected processRouteUpsert(response: HttpResponseBase): Observable<RouteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteDto>(null as any);
    }

    getStoppageSelect(stoppageId: number | undefined, academicYearId: number | undefined): Observable<StoppageDto> {
        let url_ = this.baseUrl + "/api/Transport/GetStoppageSelect?";
        if (stoppageId === null)
            throw new Error("The parameter 'stoppageId' cannot be null.");
        else if (stoppageId !== undefined)
            url_ += "stoppageId=" + encodeURIComponent("" + stoppageId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoppageSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoppageSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoppageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoppageDto>;
        }));
    }

    protected processGetStoppageSelect(response: HttpResponseBase): Observable<StoppageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoppageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoppageDto>(null as any);
    }

    getStoppageGridListSelect(requestDto: StoppageGridInputDto): Observable<StoppageListResponse> {
        let url_ = this.baseUrl + "/api/Transport/GetStoppageGridListSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoppageGridListSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoppageGridListSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoppageListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoppageListResponse>;
        }));
    }

    protected processGetStoppageGridListSelect(response: HttpResponseBase): Observable<StoppageListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoppageListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoppageListResponse>(null as any);
    }

    stoppageDelete(stoppageId: number | undefined, academicYearId: number | undefined): Observable<StoppageDeleteRespose> {
        let url_ = this.baseUrl + "/api/Transport/StoppageDelete?";
        if (stoppageId === null)
            throw new Error("The parameter 'stoppageId' cannot be null.");
        else if (stoppageId !== undefined)
            url_ += "stoppageId=" + encodeURIComponent("" + stoppageId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoppageDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoppageDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoppageDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoppageDeleteRespose>;
        }));
    }

    protected processStoppageDelete(response: HttpResponseBase): Observable<StoppageDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoppageDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoppageDeleteRespose>(null as any);
    }

    stoppageUpsert(academicYearId: number | undefined, routeId: number | undefined, stoppageDto: StoppageDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Transport/StoppageUpsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (routeId === null)
            throw new Error("The parameter 'routeId' cannot be null.");
        else if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stoppageDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoppageUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoppageUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStoppageUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getVehicleList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Transport/GetVehicleList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetVehicleList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getVehicleSelect(vehicleId: number | undefined, academicYearId: number | undefined): Observable<VehicleDto> {
        let url_ = this.baseUrl + "/api/Transport/GetVehicleSelect?";
        if (vehicleId === null)
            throw new Error("The parameter 'vehicleId' cannot be null.");
        else if (vehicleId !== undefined)
            url_ += "VehicleId=" + encodeURIComponent("" + vehicleId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleDto>;
        }));
    }

    protected processGetVehicleSelect(response: HttpResponseBase): Observable<VehicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleDto>(null as any);
    }

    vehicleUpsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/Transport/VehicleUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVehicleUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVehicleUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processVehicleUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    activeInActiveVehicle(activeRequest: ActiceInActiveVehicleDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Transport/ActiveInActiveVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activeRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveInActiveVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveInActiveVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processActiveInActiveVehicle(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    vehicleDelete(vehicleId: number | undefined): Observable<VehicleDeleteResposeDto> {
        let url_ = this.baseUrl + "/api/Transport/VehicleDelete?";
        if (vehicleId === null)
            throw new Error("The parameter 'vehicleId' cannot be null.");
        else if (vehicleId !== undefined)
            url_ += "VehicleId=" + encodeURIComponent("" + vehicleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVehicleDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVehicleDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleDeleteResposeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleDeleteResposeDto>;
        }));
    }

    protected processVehicleDelete(response: HttpResponseBase): Observable<VehicleDeleteResposeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleDeleteResposeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleDeleteResposeDto>(null as any);
    }

    getCabDriverDropDown(): Observable<DropdownResponseDto> {
        let url_ = this.baseUrl + "/api/Transport/GetCabDriverDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCabDriverDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCabDriverDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropdownResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropdownResponseDto>;
        }));
    }

    protected processGetCabDriverDropDown(response: HttpResponseBase): Observable<DropdownResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownResponseDto>(null as any);
    }

    getAreaNameDropdown(academicYearId: number | undefined): Observable<DropdownResponseDto> {
        let url_ = this.baseUrl + "/api/Transport/GetAreaNameDropdown?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaNameDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaNameDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropdownResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropdownResponseDto>;
        }));
    }

    protected processGetAreaNameDropdown(response: HttpResponseBase): Observable<DropdownResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownResponseDto>(null as any);
    }

    getVehicleDropdown(): Observable<DropdownResponseDto> {
        let url_ = this.baseUrl + "/api/Transport/GetVehicleDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropdownResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropdownResponseDto>;
        }));
    }

    protected processGetVehicleDropdown(response: HttpResponseBase): Observable<DropdownResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownResponseDto>(null as any);
    }

    getTransportStaffList(): Observable<TransportStaffResponseDto> {
        let url_ = this.baseUrl + "/api/Transport/GetTransportStaffList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportStaffList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportStaffList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportStaffResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportStaffResponseDto>;
        }));
    }

    protected processGetTransportStaffList(response: HttpResponseBase): Observable<TransportStaffResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportStaffResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportStaffResponseDto>(null as any);
    }

    getTransportConsumerTreeViewItem(requestDto: StoppageConsumerTreeviewRequestDto): Observable<SchoolTreeviewItemResponseDto> {
        let url_ = this.baseUrl + "/api/Transport/GetTransportConsumerTreeViewItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportConsumerTreeViewItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportConsumerTreeViewItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolTreeviewItemResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolTreeviewItemResponseDto>;
        }));
    }

    protected processGetTransportConsumerTreeViewItem(response: HttpResponseBase): Observable<SchoolTreeviewItemResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolTreeviewItemResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolTreeviewItemResponseDto>(null as any);
    }

    saveTransportConsumerList(requestDto: ConsumerTransportMappingUpsertDto): Observable<CreateTransportConsumerResponse> {
        let url_ = this.baseUrl + "/api/Transport/SaveTransportConsumerList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTransportConsumerList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTransportConsumerList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateTransportConsumerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateTransportConsumerResponse>;
        }));
    }

    protected processSaveTransportConsumerList(response: HttpResponseBase): Observable<CreateTransportConsumerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTransportConsumerResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTransportConsumerResponse>(null as any);
    }

    getAllConsumerByStoppageId(requestDto: ConsumerByStoppageIdInputDto): Observable<ConsumerTransportMappingUpsertDto> {
        let url_ = this.baseUrl + "/api/Transport/GetAllConsumerByStoppageId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllConsumerByStoppageId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllConsumerByStoppageId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerTransportMappingUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerTransportMappingUpsertDto>;
        }));
    }

    protected processGetAllConsumerByStoppageId(response: HttpResponseBase): Observable<ConsumerTransportMappingUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerTransportMappingUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerTransportMappingUpsertDto>(null as any);
    }

    deleteStoppageConsumer(transportConsumerStoppageMappingId: number | undefined, roleId: number | undefined, academicYearId: number | undefined): Observable<ConsumerDeleteResposeDto> {
        let url_ = this.baseUrl + "/api/Transport/DeleteStoppageConsumer?";
        if (transportConsumerStoppageMappingId === null)
            throw new Error("The parameter 'transportConsumerStoppageMappingId' cannot be null.");
        else if (transportConsumerStoppageMappingId !== undefined)
            url_ += "TransportConsumerStoppageMappingId=" + encodeURIComponent("" + transportConsumerStoppageMappingId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStoppageConsumer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStoppageConsumer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerDeleteResposeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerDeleteResposeDto>;
        }));
    }

    protected processDeleteStoppageConsumer(response: HttpResponseBase): Observable<ConsumerDeleteResposeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerDeleteResposeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerDeleteResposeDto>(null as any);
    }

    getActiveTripForAdminSelect(academicYearId: number | undefined): Observable<ActiveTripResponseDto> {
        let url_ = this.baseUrl + "/api/Transport/GetActiveTripForAdminSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveTripForAdminSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveTripForAdminSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveTripResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveTripResponseDto>;
        }));
    }

    protected processGetActiveTripForAdminSelect(response: HttpResponseBase): Observable<ActiveTripResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActiveTripResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActiveTripResponseDto>(null as any);
    }

    getStoppageTrackForAdmin(academicYearId: number | undefined, routeId: number | undefined): Observable<StoppageTrackResponseLisDto> {
        let url_ = this.baseUrl + "/api/Transport/GetStoppageTrackForAdmin?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (routeId === null)
            throw new Error("The parameter 'routeId' cannot be null.");
        else if (routeId !== undefined)
            url_ += "RouteId=" + encodeURIComponent("" + routeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoppageTrackForAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoppageTrackForAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoppageTrackResponseLisDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoppageTrackResponseLisDto>;
        }));
    }

    protected processGetStoppageTrackForAdmin(response: HttpResponseBase): Observable<StoppageTrackResponseLisDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoppageTrackResponseLisDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoppageTrackResponseLisDto>(null as any);
    }
}

@Injectable()
export class TransportFeePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getTransportFeePaymentStudentGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetTransportFeePaymentStudentGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportFeePaymentStudentGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportFeePaymentStudentGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetTransportFeePaymentStudentGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getTransportFeePaymentStaffGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetTransportFeePaymentStaffGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportFeePaymentStaffGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportFeePaymentStaffGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetTransportFeePaymentStaffGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getTransportFeePaymentDueListByAY(consumerId: number | undefined, roleId: number | undefined, currentAcademicYearInclude: boolean | undefined): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetTransportFeePaymentDueListByAY?";
        if (consumerId === null)
            throw new Error("The parameter 'consumerId' cannot be null.");
        else if (consumerId !== undefined)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (currentAcademicYearInclude === null)
            throw new Error("The parameter 'currentAcademicYearInclude' cannot be null.");
        else if (currentAcademicYearInclude !== undefined)
            url_ += "currentAcademicYearInclude=" + encodeURIComponent("" + currentAcademicYearInclude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportFeePaymentDueListByAY(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportFeePaymentDueListByAY(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetTransportFeePaymentDueListByAY(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getTransportFeePaymentSelect(academicYearId: number | undefined, consumerId: number | undefined, roleId: number | undefined, transportConsumerStoppageMappingId: number | undefined): Observable<TransportFeePaymentSelectDto> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetTransportFeePaymentSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (consumerId === null)
            throw new Error("The parameter 'consumerId' cannot be null.");
        else if (consumerId !== undefined)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (transportConsumerStoppageMappingId === null)
            throw new Error("The parameter 'transportConsumerStoppageMappingId' cannot be null.");
        else if (transportConsumerStoppageMappingId !== undefined)
            url_ += "transportConsumerStoppageMappingId=" + encodeURIComponent("" + transportConsumerStoppageMappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportFeePaymentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportFeePaymentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportFeePaymentSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportFeePaymentSelectDto>;
        }));
    }

    protected processGetTransportFeePaymentSelect(response: HttpResponseBase): Observable<TransportFeePaymentSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportFeePaymentSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportFeePaymentSelectDto>(null as any);
    }

    transportFeePaymentUpsert(transportFeePaymentUpsertDto: TransportFeePaymentUpsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/TransportFeePaymentUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(transportFeePaymentUpsertDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransportFeePaymentUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransportFeePaymentUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTransportFeePaymentUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getTransportFeePaymentMonths(academicYearId: number | undefined, consumerId: number | undefined, roleId: number | undefined, transportConsumerStoppageMappingId: number | undefined): Observable<TransportFeeMonthMastersDto> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetTransportFeePaymentMonths?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (consumerId === null)
            throw new Error("The parameter 'consumerId' cannot be null.");
        else if (consumerId !== undefined)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (transportConsumerStoppageMappingId === null)
            throw new Error("The parameter 'transportConsumerStoppageMappingId' cannot be null.");
        else if (transportConsumerStoppageMappingId !== undefined)
            url_ += "transportConsumerStoppageMappingId=" + encodeURIComponent("" + transportConsumerStoppageMappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportFeePaymentMonths(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportFeePaymentMonths(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportFeeMonthMastersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportFeeMonthMastersDto>;
        }));
    }

    protected processGetTransportFeePaymentMonths(response: HttpResponseBase): Observable<TransportFeeMonthMastersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportFeeMonthMastersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportFeeMonthMastersDto>(null as any);
    }

    getTransportFeePaymentStoppageGridLIst(academicYearId: number | undefined, consumerId: number | undefined, roleId: number | undefined): Observable<TransportFeePaymentStoppageGridDto> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetTransportFeePaymentStoppageGridLIst?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (consumerId === null)
            throw new Error("The parameter 'consumerId' cannot be null.");
        else if (consumerId !== undefined)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportFeePaymentStoppageGridLIst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportFeePaymentStoppageGridLIst(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportFeePaymentStoppageGridDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportFeePaymentStoppageGridDto>;
        }));
    }

    protected processGetTransportFeePaymentStoppageGridLIst(response: HttpResponseBase): Observable<TransportFeePaymentStoppageGridDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportFeePaymentStoppageGridDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportFeePaymentStoppageGridDto>(null as any);
    }

    getTransportFeePaymentHistoryGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetTransportFeePaymentHistoryGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportFeePaymentHistoryGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportFeePaymentHistoryGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetTransportFeePaymentHistoryGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getTransportFeePaymentHistorySelect(roleId: number | undefined, academicYearId: number | undefined, consumerId: number | undefined, tarnsportFeePaymentId: number | undefined, transportConsumerStoppageMappingId: number | undefined): Observable<TransportFeePaymentHistorySelectDto> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetTransportFeePaymentHistorySelect?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (consumerId === null)
            throw new Error("The parameter 'consumerId' cannot be null.");
        else if (consumerId !== undefined)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (tarnsportFeePaymentId === null)
            throw new Error("The parameter 'tarnsportFeePaymentId' cannot be null.");
        else if (tarnsportFeePaymentId !== undefined)
            url_ += "tarnsportFeePaymentId=" + encodeURIComponent("" + tarnsportFeePaymentId) + "&";
        if (transportConsumerStoppageMappingId === null)
            throw new Error("The parameter 'transportConsumerStoppageMappingId' cannot be null.");
        else if (transportConsumerStoppageMappingId !== undefined)
            url_ += "transportConsumerStoppageMappingId=" + encodeURIComponent("" + transportConsumerStoppageMappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportFeePaymentHistorySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportFeePaymentHistorySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportFeePaymentHistorySelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportFeePaymentHistorySelectDto>;
        }));
    }

    protected processGetTransportFeePaymentHistorySelect(response: HttpResponseBase): Observable<TransportFeePaymentHistorySelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportFeePaymentHistorySelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportFeePaymentHistorySelectDto>(null as any);
    }

    transportFeePaymentDelete(transportFeePaymentId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/TransportFeePaymentDelete?";
        if (transportFeePaymentId === null)
            throw new Error("The parameter 'transportFeePaymentId' cannot be null.");
        else if (transportFeePaymentId !== undefined)
            url_ += "transportFeePaymentId=" + encodeURIComponent("" + transportFeePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransportFeePaymentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransportFeePaymentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTransportFeePaymentDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    transportClearCheque(transportFeePaymentId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/TransportClearCheque?";
        if (transportFeePaymentId === null)
            throw new Error("The parameter 'transportFeePaymentId' cannot be null.");
        else if (transportFeePaymentId !== undefined)
            url_ += "transportFeePaymentId=" + encodeURIComponent("" + transportFeePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransportClearCheque(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransportClearCheque(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTransportClearCheque(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    getDayWiseTransportPaymentReport(request: DaywiseTransportPaymentReportRequest): Observable<TransportPaymentReportDaywiseDto> {
        let url_ = this.baseUrl + "/api/TransportFeePayment/GetDayWiseTransportPaymentReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDayWiseTransportPaymentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDayWiseTransportPaymentReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentReportDaywiseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentReportDaywiseDto>;
        }));
    }

    protected processGetDayWiseTransportPaymentReport(response: HttpResponseBase): Observable<TransportPaymentReportDaywiseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentReportDaywiseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentReportDaywiseDto>(null as any);
    }
}

@Injectable()
export class TeachingLoadAnalysisServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    teacherPercentageSelect(academicYearId: number | undefined): Observable<TeachingLoadAnalysisResponseDto> {
        let url_ = this.baseUrl + "/api/TeachingLoadAnalysis/TeacherPercentageSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherPercentageSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherPercentageSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeachingLoadAnalysisResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeachingLoadAnalysisResponseDto>;
        }));
    }

    protected processTeacherPercentageSelect(response: HttpResponseBase): Observable<TeachingLoadAnalysisResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeachingLoadAnalysisResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeachingLoadAnalysisResponseDto>(null as any);
    }
}

@Injectable()
export class TeacherSubjectMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getTeacherSubjectMappingList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/TeacherSubjectMapping/GetTeacherSubjectMappingList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherSubjectMappingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherSubjectMappingList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetTeacherSubjectMappingList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    teacherSubjectMappingInsert(academicYearId: number | undefined, teacherId: number | undefined, teacherSubjectMappingObj: TeacherSubjectMappingDto): Observable<TeacherSubjectMappingUpsertDto> {
        let url_ = this.baseUrl + "/api/TeacherSubjectMapping/TeacherSubjectMappingInsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(teacherSubjectMappingObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherSubjectMappingInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherSubjectMappingInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherSubjectMappingUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherSubjectMappingUpsertDto>;
        }));
    }

    protected processTeacherSubjectMappingInsert(response: HttpResponseBase): Observable<TeacherSubjectMappingUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherSubjectMappingUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherSubjectMappingUpsertDto>(null as any);
    }

    teacherSubjectMappingDelete(academicYearId: number | undefined, teacherId: number | undefined, subjectId: number | undefined): Observable<TeacherSubjectMappingUpsertDto> {
        let url_ = this.baseUrl + "/api/TeacherSubjectMapping/TeacherSubjectMappingDelete?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        if (subjectId === null)
            throw new Error("The parameter 'subjectId' cannot be null.");
        else if (subjectId !== undefined)
            url_ += "subjectId=" + encodeURIComponent("" + subjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherSubjectMappingDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherSubjectMappingDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherSubjectMappingUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherSubjectMappingUpsertDto>;
        }));
    }

    protected processTeacherSubjectMappingDelete(response: HttpResponseBase): Observable<TeacherSubjectMappingUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherSubjectMappingUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherSubjectMappingUpsertDto>(null as any);
    }
}

@Injectable()
export class TeacherOneDayLectureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    teacherOneDayLectureSelect(academicYearId: number | undefined, teacherId: number | undefined, dayNo: number | undefined): Observable<TeacherOneDayLectureResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherOneDayLecture/TeacherOneDayLectureSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "TeacherId=" + encodeURIComponent("" + teacherId) + "&";
        if (dayNo === null)
            throw new Error("The parameter 'dayNo' cannot be null.");
        else if (dayNo !== undefined)
            url_ += "DayNo=" + encodeURIComponent("" + dayNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherOneDayLectureSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherOneDayLectureSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherOneDayLectureResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherOneDayLectureResponseDto>;
        }));
    }

    protected processTeacherOneDayLectureSelect(response: HttpResponseBase): Observable<TeacherOneDayLectureResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherOneDayLectureResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherOneDayLectureResponseDto>(null as any);
    }
}

@Injectable()
export class TeacherServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getTeacherProfile(teacherId: number | undefined): Observable<TeacherDto> {
        let url_ = this.baseUrl + "/api/Teacher/GetTeacherProfile?";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "TeacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherDto>;
        }));
    }

    protected processGetTeacherProfile(response: HttpResponseBase): Observable<TeacherDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherDto>(null as any);
    }

    teacherProfileUpsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/Teacher/TeacherProfileUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherProfileUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherProfileUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTeacherProfileUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getTeacherList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Teacher/GetTeacherList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetTeacherList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    teacherProfileDelete(teacherId: number | undefined): Observable<TeacherDeleteRespose> {
        let url_ = this.baseUrl + "/api/Teacher/TeacherProfileDelete?";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherProfileDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherProfileDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherDeleteRespose>;
        }));
    }

    protected processTeacherProfileDelete(response: HttpResponseBase): Observable<TeacherDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherDeleteRespose>(null as any);
    }
}

@Injectable()
export class TeacherGradeDivisionMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getTeacherGradeDivisionMappingList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/TeacherGradeDivisionMapping/GetTeacherGradeDivisionMappingList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherGradeDivisionMappingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherGradeDivisionMappingList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetTeacherGradeDivisionMappingList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    teacherGradeDivisionMappingInsert(teacherGradeDivisionMappingobj: TeacherGradeDivisionMappingDto): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherGradeDivisionMapping/TeacherGradeDivisionMappingInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(teacherGradeDivisionMappingobj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherGradeDivisionMappingInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherGradeDivisionMappingInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTeacherGradeDivisionMappingInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    teacherMappingDelete(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, teacherId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherGradeDivisionMapping/TeacherMappingDelete?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherMappingDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherMappingDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTeacherMappingDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class TeacherCountPerSubjectAnalyzerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    teacherCountPerSubjectSelect(academicYearId: number | undefined): Observable<TeacherCountPerSubjectAnalyzerResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherCountPerSubjectAnalyzer/TeacherCountPerSubjectSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherCountPerSubjectSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherCountPerSubjectSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherCountPerSubjectAnalyzerResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherCountPerSubjectAnalyzerResponseDto>;
        }));
    }

    protected processTeacherCountPerSubjectSelect(response: HttpResponseBase): Observable<TeacherCountPerSubjectAnalyzerResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherCountPerSubjectAnalyzerResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherCountPerSubjectAnalyzerResponseDto>(null as any);
    }
}

@Injectable()
export class TeacherProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    teacherProfileUpdate(): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherProfile/TeacherProfileUpdate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherProfileUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherProfileUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTeacherProfileUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getTeacherProfile(teacherId: number | undefined): Observable<TeacherDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetTeacherProfile?";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "TeacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherDto>;
        }));
    }

    protected processGetTeacherProfile(response: HttpResponseBase): Observable<TeacherDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherDto>(null as any);
    }

    getStudentAttendanceList(requestDto: StudentAttendanceRequestDto): Observable<StudentAttendanceGridResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetStudentAttendanceList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentAttendanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentAttendanceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAttendanceGridResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAttendanceGridResponseDto>;
        }));
    }

    protected processGetStudentAttendanceList(response: HttpResponseBase): Observable<StudentAttendanceGridResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentAttendanceGridResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentAttendanceGridResponseDto>(null as any);
    }

    getStudentAttendanceUpsert(studentAttendanceUpsertDto: StudentAttendanceUpsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetStudentAttendanceUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(studentAttendanceUpsertDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentAttendanceUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentAttendanceUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetStudentAttendanceUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    classTeacherGradeDivisionList(teacherId: number | undefined): Observable<ClassTeacherGradeDivisionListDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/ClassTeacherGradeDivisionList?";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassTeacherGradeDivisionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassTeacherGradeDivisionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassTeacherGradeDivisionListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassTeacherGradeDivisionListDto>;
        }));
    }

    protected processClassTeacherGradeDivisionList(response: HttpResponseBase): Observable<ClassTeacherGradeDivisionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassTeacherGradeDivisionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassTeacherGradeDivisionListDto>(null as any);
    }

    getSubjectDropdownByClassTeacher(requestDto: TeacherClassSubjectRequestDto): Observable<TeacherClassSubjectResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetSubjectDropdownByClassTeacher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectDropdownByClassTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectDropdownByClassTeacher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherClassSubjectResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherClassSubjectResponseDto>;
        }));
    }

    protected processGetSubjectDropdownByClassTeacher(response: HttpResponseBase): Observable<TeacherClassSubjectResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherClassSubjectResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherClassSubjectResponseDto>(null as any);
    }

    getSchoolBasicDetails(): Observable<SchoolDetailMobileDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetSchoolBasicDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchoolBasicDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchoolBasicDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolDetailMobileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolDetailMobileDto>;
        }));
    }

    protected processGetSchoolBasicDetails(response: HttpResponseBase): Observable<SchoolDetailMobileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolDetailMobileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolDetailMobileDto>(null as any);
    }

    getHomeworkList(month: number | undefined, year: number | undefined): Observable<HomeworkListDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetHomeworkList?";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHomeworkList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHomeworkList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HomeworkListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HomeworkListDto>;
        }));
    }

    protected processGetHomeworkList(response: HttpResponseBase): Observable<HomeworkListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HomeworkListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeworkListDto>(null as any);
    }

    publishUnpublishHomeworkParticulars(publishRequest: PublishUnpublishHomeworkDto): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherProfile/PublishUnpublishHomeworkParticulars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishHomeworkParticulars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishHomeworkParticulars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishHomeworkParticulars(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    homeworkSelect(homeworkId: number | undefined): Observable<HomeworkUpsertDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/HomeworkSelect?";
        if (homeworkId === null)
            throw new Error("The parameter 'homeworkId' cannot be null.");
        else if (homeworkId !== undefined)
            url_ += "HomeworkId=" + encodeURIComponent("" + homeworkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeworkSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeworkSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HomeworkUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HomeworkUpsertDto>;
        }));
    }

    protected processHomeworkSelect(response: HttpResponseBase): Observable<HomeworkUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HomeworkUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeworkUpsertDto>(null as any);
    }

    homeWorkDelete(homeworkId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherProfile/HomeWorkDelete?";
        if (homeworkId === null)
            throw new Error("The parameter 'homeworkId' cannot be null.");
        else if (homeworkId !== undefined)
            url_ += "homeworkId=" + encodeURIComponent("" + homeworkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeWorkDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeWorkDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processHomeWorkDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    homeworkUpsert(): Observable<HomeworkUpsertDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/HomeworkUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeworkUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeworkUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HomeworkUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HomeworkUpsertDto>;
        }));
    }

    protected processHomeworkUpsert(response: HttpResponseBase): Observable<HomeworkUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HomeworkUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeworkUpsertDto>(null as any);
    }

    noticeSelect(noticeId: number | undefined): Observable<NoticeUpsertDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/NoticeSelect?";
        if (noticeId === null)
            throw new Error("The parameter 'noticeId' cannot be null.");
        else if (noticeId !== undefined)
            url_ += "NoticeId=" + encodeURIComponent("" + noticeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoticeSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoticeSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeUpsertDto>;
        }));
    }

    protected processNoticeSelect(response: HttpResponseBase): Observable<NoticeUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeUpsertDto>(null as any);
    }

    publishUnpublishNoticeParticulars(publishRequest: PublishUnpublishNoticeDto): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherProfile/PublishUnpublishNoticeParticulars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishNoticeParticulars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishNoticeParticulars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishNoticeParticulars(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    noticeDelete(noticeId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherProfile/NoticeDelete?";
        if (noticeId === null)
            throw new Error("The parameter 'noticeId' cannot be null.");
        else if (noticeId !== undefined)
            url_ += "noticeId=" + encodeURIComponent("" + noticeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoticeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoticeDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processNoticeDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getNoticeList(noticeTypeId: number | undefined, refId: number | undefined, month: number | undefined, year: number | undefined): Observable<NoticeListDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetNoticeList?";
        if (noticeTypeId === null)
            throw new Error("The parameter 'noticeTypeId' cannot be null.");
        else if (noticeTypeId !== undefined)
            url_ += "NoticeTypeId=" + encodeURIComponent("" + noticeTypeId) + "&";
        if (refId === null)
            throw new Error("The parameter 'refId' cannot be null.");
        else if (refId !== undefined)
            url_ += "RefId=" + encodeURIComponent("" + refId) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoticeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoticeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeListDto>;
        }));
    }

    protected processGetNoticeList(response: HttpResponseBase): Observable<NoticeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeListDto>(null as any);
    }

    noticeUpsert(): Observable<NoticeUpsertDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/NoticeUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoticeUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoticeUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeUpsertDto>;
        }));
    }

    protected processNoticeUpsert(response: HttpResponseBase): Observable<NoticeUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeUpsertDto>(null as any);
    }

    gallerySelect(galleryId: number | undefined): Observable<GalleryUpsertDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GallerySelect?";
        if (galleryId === null)
            throw new Error("The parameter 'galleryId' cannot be null.");
        else if (galleryId !== undefined)
            url_ += "GalleryId=" + encodeURIComponent("" + galleryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGallerySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGallerySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GalleryUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GalleryUpsertDto>;
        }));
    }

    protected processGallerySelect(response: HttpResponseBase): Observable<GalleryUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GalleryUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GalleryUpsertDto>(null as any);
    }

    publishUnpublishGalleryParticular(publishRequest: PublishUnpublishGalleryDto): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherProfile/PublishUnpublishGalleryParticular";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishGalleryParticular(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishGalleryParticular(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishGalleryParticular(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    galleryDelete(galleryId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GalleryDelete?";
        if (galleryId === null)
            throw new Error("The parameter 'galleryId' cannot be null.");
        else if (galleryId !== undefined)
            url_ += "GalleryId=" + encodeURIComponent("" + galleryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGalleryDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGalleryDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGalleryDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getGalleryGridList(galleryTypeId: number | undefined, refId: number | undefined): Observable<GalleryListDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetGalleryGridList?";
        if (galleryTypeId === null)
            throw new Error("The parameter 'galleryTypeId' cannot be null.");
        else if (galleryTypeId !== undefined)
            url_ += "GalleryTypeId=" + encodeURIComponent("" + galleryTypeId) + "&";
        if (refId === null)
            throw new Error("The parameter 'refId' cannot be null.");
        else if (refId !== undefined)
            url_ += "RefId=" + encodeURIComponent("" + refId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGalleryGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGalleryGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GalleryListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GalleryListDto>;
        }));
    }

    protected processGetGalleryGridList(response: HttpResponseBase): Observable<GalleryListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GalleryListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GalleryListDto>(null as any);
    }

    galleryUpsert(): Observable<GalleryUpsertDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GalleryUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGalleryUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGalleryUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GalleryUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GalleryUpsertDto>;
        }));
    }

    protected processGalleryUpsert(response: HttpResponseBase): Observable<GalleryUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GalleryUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GalleryUpsertDto>(null as any);
    }

    studentTeacherAppSelect(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<StudentTeacherAppResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/StudentTeacherAppSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentTeacherAppSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentTeacherAppSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentTeacherAppResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentTeacherAppResponseDto>;
        }));
    }

    protected processStudentTeacherAppSelect(response: HttpResponseBase): Observable<StudentTeacherAppResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentTeacherAppResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentTeacherAppResponseDto>(null as any);
    }

    classMissingAttendanceReport(teacherId: number | undefined, month: number | undefined, year: number | undefined): Observable<ClassAttendanceMissingReportResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/ClassMissingAttendanceReport?";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassMissingAttendanceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassMissingAttendanceReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassAttendanceMissingReportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassAttendanceMissingReportResponseDto>;
        }));
    }

    protected processClassMissingAttendanceReport(response: HttpResponseBase): Observable<ClassAttendanceMissingReportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassAttendanceMissingReportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassAttendanceMissingReportResponseDto>(null as any);
    }

    teacherOneDayLectureSelect(teacherId: number | undefined, dayNo: number | undefined): Observable<TeacherOneDayLectureResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/TeacherOneDayLectureSelect?";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "TeacherId=" + encodeURIComponent("" + teacherId) + "&";
        if (dayNo === null)
            throw new Error("The parameter 'dayNo' cannot be null.");
        else if (dayNo !== undefined)
            url_ += "DayNo=" + encodeURIComponent("" + dayNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeacherOneDayLectureSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeacherOneDayLectureSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherOneDayLectureResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherOneDayLectureResponseDto>;
        }));
    }

    protected processTeacherOneDayLectureSelect(response: HttpResponseBase): Observable<TeacherOneDayLectureResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherOneDayLectureResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherOneDayLectureResponseDto>(null as any);
    }

    schoolMonthEvent(): Observable<SchoolMonthEventResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/SchoolMonthEvent";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolMonthEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolMonthEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolMonthEventResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolMonthEventResponseDto>;
        }));
    }

    protected processSchoolMonthEvent(response: HttpResponseBase): Observable<SchoolMonthEventResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolMonthEventResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolMonthEventResponseDto>(null as any);
    }

    schoolMonthEventParentSelect(gradeId: number | undefined, divisionId: number | undefined): Observable<SchoolMonthEventResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/SchoolMonthEventParentSelect?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolMonthEventParentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolMonthEventParentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolMonthEventResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolMonthEventResponseDto>;
        }));
    }

    protected processSchoolMonthEventParentSelect(response: HttpResponseBase): Observable<SchoolMonthEventResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolMonthEventResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolMonthEventResponseDto>(null as any);
    }

    getTeacherAttendanceHoliday(): Observable<TeacherAttendanceHolidayResponseDto> {
        let url_ = this.baseUrl + "/api/TeacherProfile/GetTeacherAttendanceHoliday";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherAttendanceHoliday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherAttendanceHoliday(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherAttendanceHolidayResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherAttendanceHolidayResponseDto>;
        }));
    }

    protected processGetTeacherAttendanceHoliday(response: HttpResponseBase): Observable<TeacherAttendanceHolidayResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherAttendanceHolidayResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherAttendanceHolidayResponseDto>(null as any);
    }
}

@Injectable()
export class SurveyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getSurveyGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Survey/GetSurveyGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetSurveyGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    surveySelect(surveyId: number | undefined): Observable<SurveyDto> {
        let url_ = this.baseUrl + "/api/Survey/SurveySelect?";
        if (surveyId === null)
            throw new Error("The parameter 'surveyId' cannot be null.");
        else if (surveyId !== undefined)
            url_ += "SurveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurveySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurveySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurveyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurveyDto>;
        }));
    }

    protected processSurveySelect(response: HttpResponseBase): Observable<SurveyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurveyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyDto>(null as any);
    }

    surveyDelete(surveyId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Survey/SurveyDelete?";
        if (surveyId === null)
            throw new Error("The parameter 'surveyId' cannot be null.");
        else if (surveyId !== undefined)
            url_ += "SurveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurveyDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurveyDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSurveyDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    publishUnpublishSurveyParticulars(publishRequest: PublishUnpublishSurveyDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Survey/PublishUnpublishSurveyParticulars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishSurveyParticulars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishSurveyParticulars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishSurveyParticulars(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getSurveyFromRoleAppSelectList(): Observable<CommonDropdownSelectListItemResponseDto> {
        let url_ = this.baseUrl + "/api/Survey/GetSurveyFromRoleAppSelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyFromRoleAppSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyFromRoleAppSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonDropdownSelectListItemResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonDropdownSelectListItemResponseDto>;
        }));
    }

    protected processGetSurveyFromRoleAppSelectList(response: HttpResponseBase): Observable<CommonDropdownSelectListItemResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonDropdownSelectListItemResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDropdownSelectListItemResponseDto>(null as any);
    }

    surveyUpsert(): Observable<SurveyDto> {
        let url_ = this.baseUrl + "/api/Survey/SurveyUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurveyUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurveyUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurveyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurveyDto>;
        }));
    }

    protected processSurveyUpsert(response: HttpResponseBase): Observable<SurveyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurveyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyDto>(null as any);
    }
}

@Injectable()
export class SubjectMasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    subjectMasterUpsert(subjectMasterObj: SubjectMasterDto): Observable<number> {
        let url_ = this.baseUrl + "/api/SubjectMaster/SubjectMasterUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subjectMasterObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubjectMasterUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubjectMasterUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSubjectMasterUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getSubjectMasterList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/SubjectMaster/GetSubjectMasterList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectMasterList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectMasterList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetSubjectMasterList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getSubjectMaster(subjectMasterId: number | undefined): Observable<SubjectMasterDto> {
        let url_ = this.baseUrl + "/api/SubjectMaster/GetSubjectMaster?";
        if (subjectMasterId === null)
            throw new Error("The parameter 'subjectMasterId' cannot be null.");
        else if (subjectMasterId !== undefined)
            url_ += "SubjectMasterId=" + encodeURIComponent("" + subjectMasterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectMasterDto>;
        }));
    }

    protected processGetSubjectMaster(response: HttpResponseBase): Observable<SubjectMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectMasterDto>(null as any);
    }

    subjectMasterDelete(subjectMasterId: number | undefined): Observable<SubjectMasterDeleteResponceDto> {
        let url_ = this.baseUrl + "/api/SubjectMaster/SubjectMasterDelete?";
        if (subjectMasterId === null)
            throw new Error("The parameter 'subjectMasterId' cannot be null.");
        else if (subjectMasterId !== undefined)
            url_ += "subjectMasterId=" + encodeURIComponent("" + subjectMasterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubjectMasterDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubjectMasterDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectMasterDeleteResponceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectMasterDeleteResponceDto>;
        }));
    }

    protected processSubjectMasterDelete(response: HttpResponseBase): Observable<SubjectMasterDeleteResponceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectMasterDeleteResponceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectMasterDeleteResponceDto>(null as any);
    }

    getAllSubjectsByClassList(requestDto: TimetableSubjectDropdownRequestDto): Observable<TimetableSubjectDropdownResponseDto> {
        let url_ = this.baseUrl + "/api/SubjectMaster/GetAllSubjectsByClassList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubjectsByClassList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubjectsByClassList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimetableSubjectDropdownResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimetableSubjectDropdownResponseDto>;
        }));
    }

    protected processGetAllSubjectsByClassList(response: HttpResponseBase): Observable<TimetableSubjectDropdownResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimetableSubjectDropdownResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimetableSubjectDropdownResponseDto>(null as any);
    }
}

@Injectable()
export class SubjectMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getSubjectMappingList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/SubjectMapping/GetSubjectMappingList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectMappingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectMappingList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetSubjectMappingList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    subjectMappingInsert(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, subjectMappingObj: SubjectMappingDto): Observable<SubjectMappingUpsertDto> {
        let url_ = this.baseUrl + "/api/SubjectMapping/SubjectMappingInsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subjectMappingObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubjectMappingInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubjectMappingInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectMappingUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectMappingUpsertDto>;
        }));
    }

    protected processSubjectMappingInsert(response: HttpResponseBase): Observable<SubjectMappingUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectMappingUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectMappingUpsertDto>(null as any);
    }

    subjectMappingDelete(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, subjectId: number | undefined): Observable<SubjectMappingUpsertDto> {
        let url_ = this.baseUrl + "/api/SubjectMapping/SubjectMappingDelete?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (subjectId === null)
            throw new Error("The parameter 'subjectId' cannot be null.");
        else if (subjectId !== undefined)
            url_ += "subjectId=" + encodeURIComponent("" + subjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubjectMappingDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubjectMappingDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectMappingUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectMappingUpsertDto>;
        }));
    }

    protected processSubjectMappingDelete(response: HttpResponseBase): Observable<SubjectMappingUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectMappingUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectMappingUpsertDto>(null as any);
    }

    getSubjectMasterDropDown(): Observable<SubjectMappingDto> {
        let url_ = this.baseUrl + "/api/SubjectMapping/GetSubjectMasterDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectMasterDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectMasterDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectMappingDto>;
        }));
    }

    protected processGetSubjectMasterDropDown(response: HttpResponseBase): Observable<SubjectMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectMappingDto>(null as any);
    }

    subjectIndexNumberDetailsSelect(gradeId: number | undefined, divisionId: number | undefined, academicYearId: number | undefined): Observable<SubjectIndexNumberDetailsDto> {
        let url_ = this.baseUrl + "/api/SubjectMapping/SubjectIndexNumberDetailsSelect?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubjectIndexNumberDetailsSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubjectIndexNumberDetailsSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectIndexNumberDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectIndexNumberDetailsDto>;
        }));
    }

    protected processSubjectIndexNumberDetailsSelect(response: HttpResponseBase): Observable<SubjectIndexNumberDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectIndexNumberDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectIndexNumberDetailsDto>(null as any);
    }

    upsertSubjectIndexNumberDetails(obj: UpsertSubjectIndexNumberDetailsDto): Observable<string> {
        let url_ = this.baseUrl + "/api/SubjectMapping/UpsertSubjectIndexNumberDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsertSubjectIndexNumberDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsertSubjectIndexNumberDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpsertSubjectIndexNumberDetails(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    subjectMappingCloneDetails(cloneRequest: SubjectMappingCloneDto): Observable<number> {
        let url_ = this.baseUrl + "/api/SubjectMapping/SubjectMappingCloneDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cloneRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubjectMappingCloneDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubjectMappingCloneDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSubjectMappingCloneDetails(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getGradeDivisionSubjectMappingMasterList(academicYearId: number | undefined): Observable<GradeDivisionWithDisabledCommonMasterDto> {
        let url_ = this.baseUrl + "/api/SubjectMapping/GetGradeDivisionSubjectMappingMasterList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeDivisionSubjectMappingMasterList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeDivisionSubjectMappingMasterList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDivisionWithDisabledCommonMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDivisionWithDisabledCommonMasterDto>;
        }));
    }

    protected processGetGradeDivisionSubjectMappingMasterList(response: HttpResponseBase): Observable<GradeDivisionWithDisabledCommonMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeDivisionWithDisabledCommonMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeDivisionWithDisabledCommonMasterDto>(null as any);
    }
}

@Injectable()
export class StudentReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getCasteWiseStudentCountSelect(obj: RequestReportDto): Observable<CasteWiseStudentCountResponseDto> {
        let url_ = this.baseUrl + "/api/StudentReport/GetCasteWiseStudentCountSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCasteWiseStudentCountSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCasteWiseStudentCountSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasteWiseStudentCountResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasteWiseStudentCountResponseDto>;
        }));
    }

    protected processGetCasteWiseStudentCountSelect(response: HttpResponseBase): Observable<CasteWiseStudentCountResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasteWiseStudentCountResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CasteWiseStudentCountResponseDto>(null as any);
    }

    getcategoryStudentCountSelect(obj: RequestReportDto): Observable<CategoryWiseStudentCountReportResponseDTO> {
        let url_ = this.baseUrl + "/api/StudentReport/GetcategoryStudentCountSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcategoryStudentCountSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcategoryStudentCountSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryWiseStudentCountReportResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryWiseStudentCountReportResponseDTO>;
        }));
    }

    protected processGetcategoryStudentCountSelect(response: HttpResponseBase): Observable<CategoryWiseStudentCountReportResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryWiseStudentCountReportResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryWiseStudentCountReportResponseDTO>(null as any);
    }

    getReligionStudentCountSelect(obj: RequestReportDto): Observable<ReligionWiseStudentCountReporResponsetDTO> {
        let url_ = this.baseUrl + "/api/StudentReport/GetReligionStudentCountSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReligionStudentCountSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReligionStudentCountSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReligionWiseStudentCountReporResponsetDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReligionWiseStudentCountReporResponsetDTO>;
        }));
    }

    protected processGetReligionStudentCountSelect(response: HttpResponseBase): Observable<ReligionWiseStudentCountReporResponsetDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReligionWiseStudentCountReporResponsetDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReligionWiseStudentCountReporResponsetDTO>(null as any);
    }

    getRTEStudentCountSelect(obj: RequestReportDto): Observable<RTEStudentCountReportResponseDto> {
        let url_ = this.baseUrl + "/api/StudentReport/GetRTEStudentCountSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRTEStudentCountSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRTEStudentCountSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RTEStudentCountReportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RTEStudentCountReportResponseDto>;
        }));
    }

    protected processGetRTEStudentCountSelect(response: HttpResponseBase): Observable<RTEStudentCountReportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RTEStudentCountReportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RTEStudentCountReportResponseDto>(null as any);
    }

    getTotalStudentCountSelect(obj: RequestReportDto): Observable<StudentGenderCountReportResponseDto> {
        let url_ = this.baseUrl + "/api/StudentReport/GetTotalStudentCountSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalStudentCountSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalStudentCountSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentGenderCountReportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentGenderCountReportResponseDto>;
        }));
    }

    protected processGetTotalStudentCountSelect(response: HttpResponseBase): Observable<StudentGenderCountReportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentGenderCountReportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentGenderCountReportResponseDto>(null as any);
    }

    getStudentGenderListSelect(obj: RequestReportDto): Observable<StudentGenderListResponseDto> {
        let url_ = this.baseUrl + "/api/StudentReport/GetStudentGenderListSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentGenderListSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentGenderListSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentGenderListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentGenderListResponseDto>;
        }));
    }

    protected processGetStudentGenderListSelect(response: HttpResponseBase): Observable<StudentGenderListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentGenderListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentGenderListResponseDto>(null as any);
    }

    getRTEStudentListSelect(obj: RequestReportDto): Observable<StudentRTEGenderListResponseDto> {
        let url_ = this.baseUrl + "/api/StudentReport/GetRTEStudentListSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRTEStudentListSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRTEStudentListSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentRTEGenderListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentRTEGenderListResponseDto>;
        }));
    }

    protected processGetRTEStudentListSelect(response: HttpResponseBase): Observable<StudentRTEGenderListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentRTEGenderListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentRTEGenderListResponseDto>(null as any);
    }

    getStudentAllFeeReceiptSelect(academicYearId: number | undefined, studentId: number | undefined, classId: number | undefined): Observable<StudentAllFeeReceiptSelectDto> {
        let url_ = this.baseUrl + "/api/StudentReport/GetStudentAllFeeReceiptSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentAllFeeReceiptSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentAllFeeReceiptSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAllFeeReceiptSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAllFeeReceiptSelectDto>;
        }));
    }

    protected processGetStudentAllFeeReceiptSelect(response: HttpResponseBase): Observable<StudentAllFeeReceiptSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentAllFeeReceiptSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentAllFeeReceiptSelectDto>(null as any);
    }

    getStudentNames(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<StudentNameList> {
        let url_ = this.baseUrl + "/api/StudentReport/GetStudentNames?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentNameList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentNameList>;
        }));
    }

    protected processGetStudentNames(response: HttpResponseBase): Observable<StudentNameList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentNameList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentNameList>(null as any);
    }

    getStudentNamesWithArchive(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<StudentNameList> {
        let url_ = this.baseUrl + "/api/StudentReport/GetStudentNamesWithArchive?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentNamesWithArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentNamesWithArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentNameList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentNameList>;
        }));
    }

    protected processGetStudentNamesWithArchive(response: HttpResponseBase): Observable<StudentNameList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentNameList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentNameList>(null as any);
    }
}

@Injectable()
export class StudentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getStudentProfile(studentId: number | null | undefined, academicYearId: number | undefined): Observable<StudentDto> {
        let url_ = this.baseUrl + "/api/Student/GetStudentProfile?";
        if (studentId !== undefined && studentId !== null)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentDto>;
        }));
    }

    protected processGetStudentProfile(response: HttpResponseBase): Observable<StudentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentDto>(null as any);
    }

    studentProfileUpsert(): Observable<StudentIdModelResponse> {
        let url_ = this.baseUrl + "/api/Student/StudentProfileUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentProfileUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentProfileUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentIdModelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentIdModelResponse>;
        }));
    }

    protected processStudentProfileUpsert(response: HttpResponseBase): Observable<StudentIdModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentIdModelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentIdModelResponse>(null as any);
    }

    getStudentList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Student/GetStudentList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetStudentList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    studentProfileDelete(studentId: number | undefined, academicYearId: number | undefined): Observable<StudentDeleteRespose> {
        let url_ = this.baseUrl + "/api/Student/StudentProfileDelete?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentProfileDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentProfileDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentDeleteRespose>;
        }));
    }

    protected processStudentProfileDelete(response: HttpResponseBase): Observable<StudentDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentDeleteRespose>(null as any);
    }

    getQRCodeDetailByStudentId(studentId: number | undefined, academicYearId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Student/GetQRCodeDetailByStudentId?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQRCodeDetailByStudentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQRCodeDetailByStudentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetQRCodeDetailByStudentId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    getQRCodeDetailForAllStudent(academicYearId: number | undefined, classId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Student/GetQRCodeDetailForAllStudent?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "ClassId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQRCodeDetailForAllStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQRCodeDetailForAllStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetQRCodeDetailForAllStudent(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class StudentKitAnalyticsPaymentAnalyticsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getStudentKitPaymentAnalyticsSchool(academicYearId: number | undefined): Observable<StudentKitPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/StudentKitAnalyticsPaymentAnalytics/GetStudentKitPaymentAnalyticsSchool?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitPaymentAnalyticsSchool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitPaymentAnalyticsSchool(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitPaymentAnalyticsDto>;
        }));
    }

    protected processGetStudentKitPaymentAnalyticsSchool(response: HttpResponseBase): Observable<StudentKitPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitPaymentAnalyticsDto>(null as any);
    }

    getStudentKitPaymentAnalyticsGrade(academicYearId: number | undefined): Observable<StudentKitPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/StudentKitAnalyticsPaymentAnalytics/GetStudentKitPaymentAnalyticsGrade?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitPaymentAnalyticsGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitPaymentAnalyticsGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitPaymentAnalyticsDto>;
        }));
    }

    protected processGetStudentKitPaymentAnalyticsGrade(response: HttpResponseBase): Observable<StudentKitPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitPaymentAnalyticsDto>(null as any);
    }

    getStudentKitPaymentAnalyticsDivision(gradeId: number | undefined, academicYearId: number | undefined): Observable<StudentKitPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/StudentKitAnalyticsPaymentAnalytics/GetStudentKitPaymentAnalyticsDivision?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitPaymentAnalyticsDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitPaymentAnalyticsDivision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitPaymentAnalyticsDto>;
        }));
    }

    protected processGetStudentKitPaymentAnalyticsDivision(response: HttpResponseBase): Observable<StudentKitPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitPaymentAnalyticsDto>(null as any);
    }

    getStudentKitPaymentAnalyticsStudent(gradeId: number | undefined, divisionId: number | undefined, academicYearId: number | undefined): Observable<StudentKitPaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/StudentKitAnalyticsPaymentAnalytics/GetStudentKitPaymentAnalyticsStudent?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitPaymentAnalyticsStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitPaymentAnalyticsStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitPaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitPaymentAnalyticsDto>;
        }));
    }

    protected processGetStudentKitPaymentAnalyticsStudent(response: HttpResponseBase): Observable<StudentKitPaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitPaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitPaymentAnalyticsDto>(null as any);
    }
}

@Injectable()
export class StudentKitFeePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getStudentKitFeePaymentGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/GetStudentKitFeePaymentGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitFeePaymentGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitFeePaymentGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetStudentKitFeePaymentGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getStudentKitFeePaymentDueByAYSelect(studentId: number | undefined, currentAcademicYearInclude: boolean | undefined): Observable<StudentKitFeePaymentDueByAYSelectResponseDto> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/GetStudentKitFeePaymentDueByAYSelect?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (currentAcademicYearInclude === null)
            throw new Error("The parameter 'currentAcademicYearInclude' cannot be null.");
        else if (currentAcademicYearInclude !== undefined)
            url_ += "currentAcademicYearInclude=" + encodeURIComponent("" + currentAcademicYearInclude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitFeePaymentDueByAYSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitFeePaymentDueByAYSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitFeePaymentDueByAYSelectResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitFeePaymentDueByAYSelectResponseDto>;
        }));
    }

    protected processGetStudentKitFeePaymentDueByAYSelect(response: HttpResponseBase): Observable<StudentKitFeePaymentDueByAYSelectResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitFeePaymentDueByAYSelectResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitFeePaymentDueByAYSelectResponseDto>(null as any);
    }

    getStudentKitFeePaymentSelect(academicYearId: number | undefined, studentId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<StudentKitFeepaymentSelectDto> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/GetStudentKitFeePaymentSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitFeePaymentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitFeePaymentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitFeepaymentSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitFeepaymentSelectDto>;
        }));
    }

    protected processGetStudentKitFeePaymentSelect(response: HttpResponseBase): Observable<StudentKitFeepaymentSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitFeepaymentSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitFeepaymentSelectDto>(null as any);
    }

    studentKitFeePaymentUpsert(feePaymentUpsertDto: StudentKitFeepaymentUpsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/StudentKitFeePaymentUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feePaymentUpsertDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentKitFeePaymentUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentKitFeePaymentUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentKitFeePaymentUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getStudentKitFeePaymentHistoryGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/GetStudentKitFeePaymentHistoryGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitFeePaymentHistoryGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitFeePaymentHistoryGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetStudentKitFeePaymentHistoryGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getStudentKitFeePaymentHistorySelect(academicYearId: number | undefined, studentId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, studentKitFeePaymentId: number | undefined): Observable<StudentKitFeepaymentHistorySelectDto> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/GetStudentKitFeePaymentHistorySelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (studentKitFeePaymentId === null)
            throw new Error("The parameter 'studentKitFeePaymentId' cannot be null.");
        else if (studentKitFeePaymentId !== undefined)
            url_ += "studentKitFeePaymentId=" + encodeURIComponent("" + studentKitFeePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitFeePaymentHistorySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitFeePaymentHistorySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitFeepaymentHistorySelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitFeepaymentHistorySelectDto>;
        }));
    }

    protected processGetStudentKitFeePaymentHistorySelect(response: HttpResponseBase): Observable<StudentKitFeepaymentHistorySelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitFeepaymentHistorySelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitFeepaymentHistorySelectDto>(null as any);
    }

    studentKitFeePaymentDelete(studentKitFeePaymentId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/StudentKitFeePaymentDelete?";
        if (studentKitFeePaymentId === null)
            throw new Error("The parameter 'studentKitFeePaymentId' cannot be null.");
        else if (studentKitFeePaymentId !== undefined)
            url_ += "studentKitFeePaymentId=" + encodeURIComponent("" + studentKitFeePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentKitFeePaymentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentKitFeePaymentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentKitFeePaymentDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    studentKitClearCheque(studentKitFeePaymentId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/StudentKitClearCheque?";
        if (studentKitFeePaymentId === null)
            throw new Error("The parameter 'studentKitFeePaymentId' cannot be null.");
        else if (studentKitFeePaymentId !== undefined)
            url_ += "studentKitFeePaymentId=" + encodeURIComponent("" + studentKitFeePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentKitClearCheque(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentKitClearCheque(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processStudentKitClearCheque(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    getStudentKitDayWisePaymentReport(request: StudentKitDaywisePaymentReportRequest): Observable<StudentKitDaywisePaymentReportDto> {
        let url_ = this.baseUrl + "/api/StudentKitFeePayment/GetStudentKitDayWisePaymentReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitDayWisePaymentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitDayWisePaymentReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitDaywisePaymentReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitDaywisePaymentReportDto>;
        }));
    }

    protected processGetStudentKitDayWisePaymentReport(response: HttpResponseBase): Observable<StudentKitDaywisePaymentReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitDaywisePaymentReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitDaywisePaymentReportDto>(null as any);
    }
}

@Injectable()
export class StudentEnquiryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    studentEnquirySelect(studentEnquiryId: number | undefined): Observable<StudentEnquiryDto> {
        let url_ = this.baseUrl + "/api/StudentEnquiry/StudentEnquirySelect?";
        if (studentEnquiryId === null)
            throw new Error("The parameter 'studentEnquiryId' cannot be null.");
        else if (studentEnquiryId !== undefined)
            url_ += "StudentEnquiryId=" + encodeURIComponent("" + studentEnquiryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentEnquirySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentEnquirySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentEnquiryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentEnquiryDto>;
        }));
    }

    protected processStudentEnquirySelect(response: HttpResponseBase): Observable<StudentEnquiryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentEnquiryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentEnquiryDto>(null as any);
    }

    studentEnquiryGridSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/StudentEnquiry/StudentEnquiryGridSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentEnquiryGridSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentEnquiryGridSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processStudentEnquiryGridSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    studentEnquiryUpsert(): Observable<StudentEnquiryIdModelResponse> {
        let url_ = this.baseUrl + "/api/StudentEnquiry/StudentEnquiryUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentEnquiryUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentEnquiryUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentEnquiryIdModelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentEnquiryIdModelResponse>;
        }));
    }

    protected processStudentEnquiryUpsert(response: HttpResponseBase): Observable<StudentEnquiryIdModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentEnquiryIdModelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentEnquiryIdModelResponse>(null as any);
    }

    studentEnquiryDelete(studentEnquiryId: number | undefined): Observable<StudentEnquiryIdModelResponse> {
        let url_ = this.baseUrl + "/api/StudentEnquiry/StudentEnquiryDelete?";
        if (studentEnquiryId === null)
            throw new Error("The parameter 'studentEnquiryId' cannot be null.");
        else if (studentEnquiryId !== undefined)
            url_ += "StudentEnquiryId=" + encodeURIComponent("" + studentEnquiryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentEnquiryDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentEnquiryDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentEnquiryIdModelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentEnquiryIdModelResponse>;
        }));
    }

    protected processStudentEnquiryDelete(response: HttpResponseBase): Observable<StudentEnquiryIdModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentEnquiryIdModelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentEnquiryIdModelResponse>(null as any);
    }

    getEnquiryStatusDropDown(): Observable<StudentEnquiryDto> {
        let url_ = this.baseUrl + "/api/StudentEnquiry/GetEnquiryStatusDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnquiryStatusDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnquiryStatusDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentEnquiryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentEnquiryDto>;
        }));
    }

    protected processGetEnquiryStatusDropDown(response: HttpResponseBase): Observable<StudentEnquiryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentEnquiryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentEnquiryDto>(null as any);
    }

    getEnquiryTypeDropDown(): Observable<StudentEnquiryDto> {
        let url_ = this.baseUrl + "/api/StudentEnquiry/GetEnquiryTypeDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnquiryTypeDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnquiryTypeDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentEnquiryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentEnquiryDto>;
        }));
    }

    protected processGetEnquiryTypeDropDown(response: HttpResponseBase): Observable<StudentEnquiryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentEnquiryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentEnquiryDto>(null as any);
    }
}

@Injectable()
export class StudentDocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getStudentDocumentSelect(documentId: number | undefined): Observable<StudentDocumentDto> {
        let url_ = this.baseUrl + "/api/StudentDocument/GetStudentDocumentSelect?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentDocumentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentDocumentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentDocumentDto>;
        }));
    }

    protected processGetStudentDocumentSelect(response: HttpResponseBase): Observable<StudentDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentDocumentDto>(null as any);
    }

    getStudentDocumentList(studentId: number | undefined): Observable<StudentDocumentDto> {
        let url_ = this.baseUrl + "/api/StudentDocument/GetStudentDocumentList?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentDocumentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentDocumentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentDocumentDto>;
        }));
    }

    protected processGetStudentDocumentList(response: HttpResponseBase): Observable<StudentDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentDocumentDto>(null as any);
    }

    studentDocumentInsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/StudentDocument/StudentDocumentInsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentDocumentInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentDocumentInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentDocumentInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    studentDocumentDelete(documentId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/StudentDocument/StudentDocumentDelete?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentDocumentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentDocumentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentDocumentDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class ClassAttendanceMissingReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    classMissingAttendanceReport(academicYearId: number | undefined, refId: number | undefined, roleId: number | undefined): Observable<ClassAttendanceMissingReportResponseDto> {
        let url_ = this.baseUrl + "/api/ClassAttendanceMissingReport/ClassMissingAttendanceReport?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (refId === null)
            throw new Error("The parameter 'refId' cannot be null.");
        else if (refId !== undefined)
            url_ += "RefId=" + encodeURIComponent("" + refId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassMissingAttendanceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassMissingAttendanceReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassAttendanceMissingReportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassAttendanceMissingReportResponseDto>;
        }));
    }

    protected processClassMissingAttendanceReport(response: HttpResponseBase): Observable<ClassAttendanceMissingReportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassAttendanceMissingReportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassAttendanceMissingReportResponseDto>(null as any);
    }
}

@Injectable()
export class StudentAttendanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getStudentAttendanceList(requestDto: StudentAttendanceRequestDto): Observable<StudentAttendanceGridResponseDto> {
        let url_ = this.baseUrl + "/api/StudentAttendance/GetStudentAttendanceList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentAttendanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentAttendanceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAttendanceGridResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAttendanceGridResponseDto>;
        }));
    }

    protected processGetStudentAttendanceList(response: HttpResponseBase): Observable<StudentAttendanceGridResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentAttendanceGridResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentAttendanceGridResponseDto>(null as any);
    }

    getStudentAttendanceUpsert(studentAttendanceUpsertDto: StudentAttendanceUpsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/StudentAttendance/GetStudentAttendanceUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(studentAttendanceUpsertDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentAttendanceUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentAttendanceUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetStudentAttendanceUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getAllTeacherForDropDown(): Observable<TeacherDropdownResponseDto> {
        let url_ = this.baseUrl + "/api/StudentAttendance/GetAllTeacherForDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeacherForDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeacherForDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherDropdownResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherDropdownResponseDto>;
        }));
    }

    protected processGetAllTeacherForDropDown(response: HttpResponseBase): Observable<TeacherDropdownResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherDropdownResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherDropdownResponseDto>(null as any);
    }

    getAttendanceDetailByStudentId(studentId: number | undefined, academicYearId: number | undefined): Observable<StudentAttendanceMobileResponseDto> {
        let url_ = this.baseUrl + "/api/StudentAttendance/GetAttendanceDetailByStudentId?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttendanceDetailByStudentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttendanceDetailByStudentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAttendanceMobileResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAttendanceMobileResponseDto>;
        }));
    }

    protected processGetAttendanceDetailByStudentId(response: HttpResponseBase): Observable<StudentAttendanceMobileResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentAttendanceMobileResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentAttendanceMobileResponseDto>(null as any);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    studentAttendance(studentAttendanceUpsertDto: StudentAttendanceUpsertDto): Observable<boolean> {
        let url_ = this.baseUrl + "/api/StudentAttendance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(studentAttendanceUpsertDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentAttendance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentAttendance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processStudentAttendance(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    galleryPost(galleryUpsertDto: GalleryUpsertDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Gallery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(galleryUpsertDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGalleryPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGalleryPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGalleryPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    galleryGet(title: string | null | undefined, classId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Gallery?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGalleryGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGalleryGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGalleryGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class StudentAttendanceDateWiseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    studentAttendanceReportDateWise(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/StudentAttendanceDateWise/StudentAttendanceReportDateWise";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentAttendanceReportDateWise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentAttendanceReportDateWise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processStudentAttendanceReportDateWise(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }
}

@Injectable()
export class StudentAttendanceReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getStudentAttendanceReportGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/StudentAttendanceReport/GetStudentAttendanceReportGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentAttendanceReportGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentAttendanceReportGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetStudentAttendanceReportGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }
}

@Injectable()
export class SchoolVacationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    schoolVacationDetails(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/SchoolVacation/SchoolVacationDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolVacationDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolVacationDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processSchoolVacationDetails(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getSchoolVacationSelect(schoolVacationId: number | null | undefined): Observable<SchoolVacationDto> {
        let url_ = this.baseUrl + "/api/SchoolVacation/GetSchoolVacationSelect?";
        if (schoolVacationId !== undefined && schoolVacationId !== null)
            url_ += "SchoolVacationId=" + encodeURIComponent("" + schoolVacationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchoolVacationSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchoolVacationSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolVacationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolVacationDto>;
        }));
    }

    protected processGetSchoolVacationSelect(response: HttpResponseBase): Observable<SchoolVacationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolVacationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolVacationDto>(null as any);
    }

    schoolVacationDelete(schoolVacationId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/SchoolVacation/SchoolVacationDelete?";
        if (schoolVacationId !== undefined && schoolVacationId !== null)
            url_ += "SchoolVacationId=" + encodeURIComponent("" + schoolVacationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolVacationDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolVacationDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSchoolVacationDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    updateSchoolVacation(obj: SchoolVacationDto): Observable<number> {
        let url_ = this.baseUrl + "/api/SchoolVacation/UpdateSchoolVacation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSchoolVacation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSchoolVacation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateSchoolVacation(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class SchoolMonthEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    schoolMonthEvent(academicYearId: number | undefined): Observable<SchoolMonthEventResponseDto> {
        let url_ = this.baseUrl + "/api/SchoolMonthEvent/SchoolMonthEvent?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolMonthEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolMonthEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolMonthEventResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolMonthEventResponseDto>;
        }));
    }

    protected processSchoolMonthEvent(response: HttpResponseBase): Observable<SchoolMonthEventResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolMonthEventResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolMonthEventResponseDto>(null as any);
    }
}

@Injectable()
export class SchoolHolidayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getHolidayDetails(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/SchoolHoliday/GetHolidayDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetHolidayDetails(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    schoolHolidaySelect(academicYearId: number | undefined): Observable<SchoolHolidayResponseDto> {
        let url_ = this.baseUrl + "/api/SchoolHoliday/SchoolHolidaySelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolHolidaySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolHolidaySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolHolidayResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolHolidayResponseDto>;
        }));
    }

    protected processSchoolHolidaySelect(response: HttpResponseBase): Observable<SchoolHolidayResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolHolidayResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolHolidayResponseDto>(null as any);
    }

    schoolHolidayDelete(schoolHolidayId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/SchoolHoliday/SchoolHolidayDelete?";
        if (schoolHolidayId === null)
            throw new Error("The parameter 'schoolHolidayId' cannot be null.");
        else if (schoolHolidayId !== undefined)
            url_ += "SchoolHolidayId=" + encodeURIComponent("" + schoolHolidayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolHolidayDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolHolidayDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSchoolHolidayDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    schoolHolidayInsert(shdObj: SchoolHolidayResponseDto): Observable<string> {
        let url_ = this.baseUrl + "/api/SchoolHoliday/SchoolHolidayInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(shdObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolHolidayInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolHolidayInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSchoolHolidayInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    checkExistResponse(obj: CalendarDateRequestDto): Observable<ExistResposeDto> {
        let url_ = this.baseUrl + "/api/SchoolHoliday/CheckExistResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExistResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExistResponse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExistResposeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExistResposeDto>;
        }));
    }

    protected processCheckExistResponse(response: HttpResponseBase): Observable<ExistResposeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExistResposeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExistResposeDto>(null as any);
    }
}

@Injectable()
export class SchoolEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    schoolEvent(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/SchoolEvent/SchoolEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processSchoolEvent(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    schoolEventSelect(schoolEventId: number | undefined): Observable<SchoolEventDto> {
        let url_ = this.baseUrl + "/api/SchoolEvent/SchoolEventSelect?";
        if (schoolEventId === null)
            throw new Error("The parameter 'schoolEventId' cannot be null.");
        else if (schoolEventId !== undefined)
            url_ += "SchoolEventId=" + encodeURIComponent("" + schoolEventId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolEventSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolEventSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolEventDto>;
        }));
    }

    protected processSchoolEventSelect(response: HttpResponseBase): Observable<SchoolEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolEventDto>(null as any);
    }

    publishUnpublishSchoolEventParticular(publishRequest: PublishUnpublishSchoolEventDto): Observable<number> {
        let url_ = this.baseUrl + "/api/SchoolEvent/PublishUnpublishSchoolEventParticular";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishSchoolEventParticular(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishSchoolEventParticular(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishSchoolEventParticular(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    schoolEventDelete(schoolEventId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/SchoolEvent/SchoolEventDelete?";
        if (schoolEventId === null)
            throw new Error("The parameter 'schoolEventId' cannot be null.");
        else if (schoolEventId !== undefined)
            url_ += "SchoolEventId=" + encodeURIComponent("" + schoolEventId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolEventDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolEventDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSchoolEventDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    schoolEventUpsert(): Observable<SchoolEventDto> {
        let url_ = this.baseUrl + "/api/SchoolEvent/SchoolEventUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolEventUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolEventUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolEventDto>;
        }));
    }

    protected processSchoolEventUpsert(response: HttpResponseBase): Observable<SchoolEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolEventDto>(null as any);
    }

    uploadSchoolEventMediaChunk(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SchoolEvent/UploadSchoolEventMediaChunk";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadSchoolEventMediaChunk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadSchoolEventMediaChunk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadSchoolEventMediaChunk(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

@Injectable()
export class SchoolCalendarServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    schoolCalenadarSelect(academicYearId: number | undefined): Observable<SchoolCalendarResponseDto> {
        let url_ = this.baseUrl + "/api/SchoolCalendar/SchoolCalenadarSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolCalenadarSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolCalenadarSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolCalendarResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolCalendarResponseDto>;
        }));
    }

    protected processSchoolCalenadarSelect(response: HttpResponseBase): Observable<SchoolCalendarResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolCalendarResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolCalendarResponseDto>(null as any);
    }

    getSchoolCalendarEventsForTeacherApp(academicYearId: number | undefined): Observable<SchoolCalendarAppResponseDto> {
        let url_ = this.baseUrl + "/api/SchoolCalendar/GetSchoolCalendarEventsForTeacherApp?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchoolCalendarEventsForTeacherApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchoolCalendarEventsForTeacherApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolCalendarAppResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolCalendarAppResponseDto>;
        }));
    }

    protected processGetSchoolCalendarEventsForTeacherApp(response: HttpResponseBase): Observable<SchoolCalendarAppResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolCalendarAppResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolCalendarAppResponseDto>(null as any);
    }
}

@Injectable()
export class RegistrationFeePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getRegistrationFeePaymentGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/RegistrationFeePayment/GetRegistrationFeePaymentGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegistrationFeePaymentGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegistrationFeePaymentGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetRegistrationFeePaymentGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getRegistrationFeePaymentSelect(academicYearId: number | undefined, studentEnquiryId: number | undefined): Observable<RegistrationFeePaymentSelectDto> {
        let url_ = this.baseUrl + "/api/RegistrationFeePayment/GetRegistrationFeePaymentSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentEnquiryId === null)
            throw new Error("The parameter 'studentEnquiryId' cannot be null.");
        else if (studentEnquiryId !== undefined)
            url_ += "studentEnquiryId=" + encodeURIComponent("" + studentEnquiryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegistrationFeePaymentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegistrationFeePaymentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationFeePaymentSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationFeePaymentSelectDto>;
        }));
    }

    protected processGetRegistrationFeePaymentSelect(response: HttpResponseBase): Observable<RegistrationFeePaymentSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistrationFeePaymentSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistrationFeePaymentSelectDto>(null as any);
    }

    registrationFeePaymentDelete(registrationFeeId: number | undefined, academicYearId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/RegistrationFeePayment/RegistrationFeePaymentDelete?";
        if (registrationFeeId === null)
            throw new Error("The parameter 'registrationFeeId' cannot be null.");
        else if (registrationFeeId !== undefined)
            url_ += "registrationFeeId=" + encodeURIComponent("" + registrationFeeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrationFeePaymentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrationFeePaymentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRegistrationFeePaymentDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    registrationFeePaymentUpsert(registrationFeePaymentDto: RegistrationFeePaymentDto): Observable<number> {
        let url_ = this.baseUrl + "/api/RegistrationFeePayment/RegistrationFeePaymentUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationFeePaymentDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrationFeePaymentUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrationFeePaymentUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRegistrationFeePaymentUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getRegistrationFeePaymentHistoryGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/RegistrationFeePayment/GetRegistrationFeePaymentHistoryGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegistrationFeePaymentHistoryGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegistrationFeePaymentHistoryGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetRegistrationFeePaymentHistoryGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getRegistrationFeePaymentHistorySelect(academicYearId: number | undefined, studentEnquiryId: number | undefined, registrationFeeId: number | undefined): Observable<RegistrationFeePaymentHistorySelectDto> {
        let url_ = this.baseUrl + "/api/RegistrationFeePayment/GetRegistrationFeePaymentHistorySelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentEnquiryId === null)
            throw new Error("The parameter 'studentEnquiryId' cannot be null.");
        else if (studentEnquiryId !== undefined)
            url_ += "studentEnquiryId=" + encodeURIComponent("" + studentEnquiryId) + "&";
        if (registrationFeeId === null)
            throw new Error("The parameter 'registrationFeeId' cannot be null.");
        else if (registrationFeeId !== undefined)
            url_ += "registrationFeeId=" + encodeURIComponent("" + registrationFeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegistrationFeePaymentHistorySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegistrationFeePaymentHistorySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationFeePaymentHistorySelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationFeePaymentHistorySelectDto>;
        }));
    }

    protected processGetRegistrationFeePaymentHistorySelect(response: HttpResponseBase): Observable<RegistrationFeePaymentHistorySelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistrationFeePaymentHistorySelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistrationFeePaymentHistorySelectDto>(null as any);
    }
}

@Injectable()
export class PromoteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getPromoteList(requestDto: PromoteGridRequestDto): Observable<PromoteGridResponseDto> {
        let url_ = this.baseUrl + "/api/Promote/GetPromoteList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromoteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromoteList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoteGridResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoteGridResponseDto>;
        }));
    }

    protected processGetPromoteList(response: HttpResponseBase): Observable<PromoteGridResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromoteGridResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromoteGridResponseDto>(null as any);
    }

    studentPassOrFailUpdate(academicYearId: number | undefined, action: string | null | undefined, lstPromoteList: PromoteGridDto[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Promote/StudentPassOrFailUpdate?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lstPromoteList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentPassOrFailUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentPassOrFailUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processStudentPassOrFailUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    promoteStudentToNextYear(nextAcademicYearId: number | undefined, academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, lstPromoteList: PromoteGridDto[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Promote/PromoteStudentToNextYear?";
        if (nextAcademicYearId === null)
            throw new Error("The parameter 'nextAcademicYearId' cannot be null.");
        else if (nextAcademicYearId !== undefined)
            url_ += "nextAcademicYearId=" + encodeURIComponent("" + nextAcademicYearId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lstPromoteList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromoteStudentToNextYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromoteStudentToNextYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPromoteStudentToNextYear(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class PaymentAnalyticsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getPaymentAnalyticsSchool(academicYearId: number | undefined): Observable<PaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/PaymentAnalytics/GetPaymentAnalyticsSchool?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentAnalyticsSchool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentAnalyticsSchool(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAnalyticsDto>;
        }));
    }

    protected processGetPaymentAnalyticsSchool(response: HttpResponseBase): Observable<PaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAnalyticsDto>(null as any);
    }

    getPaymentAnalyticsGrade(academicYearId: number | undefined): Observable<PaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/PaymentAnalytics/GetPaymentAnalyticsGrade?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentAnalyticsGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentAnalyticsGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAnalyticsDto>;
        }));
    }

    protected processGetPaymentAnalyticsGrade(response: HttpResponseBase): Observable<PaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAnalyticsDto>(null as any);
    }

    getPaymentAnalyticsDivision(gradeId: number | undefined, academicYearId: number | undefined): Observable<PaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/PaymentAnalytics/GetPaymentAnalyticsDivision?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentAnalyticsDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentAnalyticsDivision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAnalyticsDto>;
        }));
    }

    protected processGetPaymentAnalyticsDivision(response: HttpResponseBase): Observable<PaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAnalyticsDto>(null as any);
    }

    getPaymentAnalyticsStudent(gradeId: number | undefined, divisionId: number | undefined, academicYearId: number | undefined): Observable<PaymentAnalyticsDto> {
        let url_ = this.baseUrl + "/api/PaymentAnalytics/GetPaymentAnalyticsStudent?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentAnalyticsStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentAnalyticsStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAnalyticsDto>;
        }));
    }

    protected processGetPaymentAnalyticsStudent(response: HttpResponseBase): Observable<PaymentAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAnalyticsDto>(null as any);
    }
}

@Injectable()
export class ParentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getParentProfile(parentId: number | null | undefined): Observable<ParentDto> {
        let url_ = this.baseUrl + "/api/Parent/GetParentProfile?";
        if (parentId !== undefined && parentId !== null)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentDto>;
        }));
    }

    protected processGetParentProfile(response: HttpResponseBase): Observable<ParentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParentDto>(null as any);
    }

    parentProfileUpsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/Parent/ParentProfileUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParentProfileUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParentProfileUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processParentProfileUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getParentList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Parent/GetParentList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetParentList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    parentProfileDelete(parentId: number | undefined): Observable<ParentDeleteRespose> {
        let url_ = this.baseUrl + "/api/Parent/ParentProfileDelete?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParentProfileDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParentProfileDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentDeleteRespose>;
        }));
    }

    protected processParentProfileDelete(response: HttpResponseBase): Observable<ParentDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParentDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParentDeleteRespose>(null as any);
    }
}

@Injectable()
export class NoticeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getNoticeGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Notice/GetNoticeGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoticeGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoticeGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetNoticeGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    noticeSelect(noticeId: number | undefined): Observable<NoticeUpsertDto> {
        let url_ = this.baseUrl + "/api/Notice/NoticeSelect?";
        if (noticeId === null)
            throw new Error("The parameter 'noticeId' cannot be null.");
        else if (noticeId !== undefined)
            url_ += "NoticeId=" + encodeURIComponent("" + noticeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoticeSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoticeSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeUpsertDto>;
        }));
    }

    protected processNoticeSelect(response: HttpResponseBase): Observable<NoticeUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeUpsertDto>(null as any);
    }

    noticeUpsert(): Observable<NoticeUpsertDto> {
        let url_ = this.baseUrl + "/api/Notice/NoticeUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoticeUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoticeUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeUpsertDto>;
        }));
    }

    protected processNoticeUpsert(response: HttpResponseBase): Observable<NoticeUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeUpsertDto>(null as any);
    }

    uploadNoticeMediaChunk(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Notice/UploadNoticeMediaChunk";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadNoticeMediaChunk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadNoticeMediaChunk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadNoticeMediaChunk(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    noticeDelete(noticeId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Notice/NoticeDelete?";
        if (noticeId === null)
            throw new Error("The parameter 'noticeId' cannot be null.");
        else if (noticeId !== undefined)
            url_ += "noticeId=" + encodeURIComponent("" + noticeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoticeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoticeDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processNoticeDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    publishUnpublishNoticeParticulars(publishRequest: PublishUnpublishNoticeDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Notice/PublishUnpublishNoticeParticulars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishNoticeParticulars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishNoticeParticulars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishNoticeParticulars(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getAllNoticeForStudent(requestDto: ParentAppNoticeRequestDto): Observable<ParentAppNoticeResponseDto> {
        let url_ = this.baseUrl + "/api/Notice/GetAllNoticeForStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNoticeForStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNoticeForStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentAppNoticeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentAppNoticeResponseDto>;
        }));
    }

    protected processGetAllNoticeForStudent(response: HttpResponseBase): Observable<ParentAppNoticeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParentAppNoticeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParentAppNoticeResponseDto>(null as any);
    }

    getNoticeFromRoleAppSelectList(): Observable<CommonDropdownSelectListItemResponseDto> {
        let url_ = this.baseUrl + "/api/Notice/GetNoticeFromRoleAppSelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoticeFromRoleAppSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoticeFromRoleAppSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonDropdownSelectListItemResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonDropdownSelectListItemResponseDto>;
        }));
    }

    protected processGetNoticeFromRoleAppSelectList(response: HttpResponseBase): Observable<CommonDropdownSelectListItemResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonDropdownSelectListItemResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDropdownSelectListItemResponseDto>(null as any);
    }
}

@Injectable()
export class CommonAppServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getSchoolDetail(): Observable<SchoolDetailMobileDto> {
        let url_ = this.baseUrl + "/api/CommonApp/GetSchoolDetail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchoolDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchoolDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolDetailMobileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolDetailMobileDto>;
        }));
    }

    protected processGetSchoolDetail(response: HttpResponseBase): Observable<SchoolDetailMobileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolDetailMobileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolDetailMobileDto>(null as any);
    }

    getStudentsByUserId(): Observable<StudentDetailMobileResponseDto> {
        let url_ = this.baseUrl + "/api/CommonApp/GetStudentsByUserId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentsByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentDetailMobileResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentDetailMobileResponseDto>;
        }));
    }

    protected processGetStudentsByUserId(response: HttpResponseBase): Observable<StudentDetailMobileResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentDetailMobileResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentDetailMobileResponseDto>(null as any);
    }
}

@Injectable()
export class StudentProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getStudentProfile(studentId: number | undefined): Observable<StudentProfileMobileDto> {
        let url_ = this.baseUrl + "/api/StudentProfile/GetStudentProfile?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentProfileMobileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentProfileMobileDto>;
        }));
    }

    protected processGetStudentProfile(response: HttpResponseBase): Observable<StudentProfileMobileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentProfileMobileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentProfileMobileDto>(null as any);
    }

    studentProfileUpdate(): Observable<number> {
        let url_ = this.baseUrl + "/api/StudentProfile/StudentProfileUpdate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentProfileUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentProfileUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentProfileUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getParentProfile(studentId: number | undefined): Observable<ParentProfileMobileResponseDto> {
        let url_ = this.baseUrl + "/api/StudentProfile/GetParentProfile?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentProfileMobileResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentProfileMobileResponseDto>;
        }));
    }

    protected processGetParentProfile(response: HttpResponseBase): Observable<ParentProfileMobileResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParentProfileMobileResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParentProfileMobileResponseDto>(null as any);
    }

    parentProfileUpdate(): Observable<number> {
        let url_ = this.baseUrl + "/api/StudentProfile/ParentProfileUpdate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParentProfileUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParentProfileUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processParentProfileUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class ParentAppServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getParentFeePaymentDetails(studentId: number | undefined): Observable<FeePaymentTopSectionDto> {
        let url_ = this.baseUrl + "/api/ParentApp/GetParentFeePaymentDetails?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentFeePaymentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentFeePaymentDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeePaymentTopSectionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeePaymentTopSectionDto>;
        }));
    }

    protected processGetParentFeePaymentDetails(response: HttpResponseBase): Observable<FeePaymentTopSectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeePaymentTopSectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeePaymentTopSectionDto>(null as any);
    }

    getParentTransportFeePaymentDetails(studentId: number | undefined): Observable<TransportFeePaymentTopSectionDto> {
        let url_ = this.baseUrl + "/api/ParentApp/GetParentTransportFeePaymentDetails?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentTransportFeePaymentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentTransportFeePaymentDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportFeePaymentTopSectionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportFeePaymentTopSectionDto>;
        }));
    }

    protected processGetParentTransportFeePaymentDetails(response: HttpResponseBase): Observable<TransportFeePaymentTopSectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportFeePaymentTopSectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportFeePaymentTopSectionDto>(null as any);
    }

    oneMonthEvent(classId: number | undefined): Observable<OneMonthEventParentAppResponseDto> {
        let url_ = this.baseUrl + "/api/ParentApp/OneMonthEvent?";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOneMonthEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOneMonthEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OneMonthEventParentAppResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OneMonthEventParentAppResponseDto>;
        }));
    }

    protected processOneMonthEvent(response: HttpResponseBase): Observable<OneMonthEventParentAppResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OneMonthEventParentAppResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OneMonthEventParentAppResponseDto>(null as any);
    }

    oneDayLectureSelect(classId: number | undefined, dayNo: number | undefined): Observable<TeacherOneDayLecturesParentAppResponseDto> {
        let url_ = this.baseUrl + "/api/ParentApp/OneDayLectureSelect?";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        if (dayNo === null)
            throw new Error("The parameter 'dayNo' cannot be null.");
        else if (dayNo !== undefined)
            url_ += "DayNo=" + encodeURIComponent("" + dayNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOneDayLectureSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOneDayLectureSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherOneDayLecturesParentAppResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherOneDayLecturesParentAppResponseDto>;
        }));
    }

    protected processOneDayLectureSelect(response: HttpResponseBase): Observable<TeacherOneDayLecturesParentAppResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherOneDayLecturesParentAppResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherOneDayLecturesParentAppResponseDto>(null as any);
    }

    attendanceMissingParent(studentId: number | undefined): Observable<MissingAttendanceParentAppDto> {
        let url_ = this.baseUrl + "/api/ParentApp/AttendanceMissingParent?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttendanceMissingParent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttendanceMissingParent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MissingAttendanceParentAppDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MissingAttendanceParentAppDto>;
        }));
    }

    protected processAttendanceMissingParent(response: HttpResponseBase): Observable<MissingAttendanceParentAppDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MissingAttendanceParentAppDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MissingAttendanceParentAppDto>(null as any);
    }

    studentGradeDivision(parentId: number | undefined): Observable<StudentGradeDivisionParentAppDto> {
        let url_ = this.baseUrl + "/api/ParentApp/StudentGradeDivision?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentGradeDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentGradeDivision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentGradeDivisionParentAppDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentGradeDivisionParentAppDto>;
        }));
    }

    protected processStudentGradeDivision(response: HttpResponseBase): Observable<StudentGradeDivisionParentAppDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentGradeDivisionParentAppDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentGradeDivisionParentAppDto>(null as any);
    }

    getParentAppListSelect(academicYearId: number | undefined, classId: number | undefined): Observable<SchoolParentCalendarResponseDto> {
        let url_ = this.baseUrl + "/api/ParentApp/GetParentAppListSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentAppListSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentAppListSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolParentCalendarResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolParentCalendarResponseDto>;
        }));
    }

    protected processGetParentAppListSelect(response: HttpResponseBase): Observable<SchoolParentCalendarResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolParentCalendarResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolParentCalendarResponseDto>(null as any);
    }

    getAttendanceDetailByStudentId(studentId: number | undefined): Observable<StudentAttendanceMobileResponseDto> {
        let url_ = this.baseUrl + "/api/ParentApp/GetAttendanceDetailByStudentId?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttendanceDetailByStudentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttendanceDetailByStudentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAttendanceMobileResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAttendanceMobileResponseDto>;
        }));
    }

    protected processGetAttendanceDetailByStudentId(response: HttpResponseBase): Observable<StudentAttendanceMobileResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentAttendanceMobileResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentAttendanceMobileResponseDto>(null as any);
    }

    getVehicleTrackListSelect(studentId: number | undefined): Observable<VehicleTrackResponseDto> {
        let url_ = this.baseUrl + "/api/ParentApp/GetVehicleTrackListSelect?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleTrackListSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleTrackListSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleTrackResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleTrackResponseDto>;
        }));
    }

    protected processGetVehicleTrackListSelect(response: HttpResponseBase): Observable<VehicleTrackResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleTrackResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleTrackResponseDto>(null as any);
    }

    getStoppageTrackListSelect(studentId: number | undefined): Observable<StoppageTrackResponseDto> {
        let url_ = this.baseUrl + "/api/ParentApp/GetStoppageTrackListSelect?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoppageTrackListSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoppageTrackListSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoppageTrackResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoppageTrackResponseDto>;
        }));
    }

    protected processGetStoppageTrackListSelect(response: HttpResponseBase): Observable<StoppageTrackResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoppageTrackResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoppageTrackResponseDto>(null as any);
    }
}

@Injectable()
export class MasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getAddressMasterData(): Observable<AddressMasterDto> {
        let url_ = this.baseUrl + "/api/Master/GetAddressMasterData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressMasterData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressMasterData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressMasterDto>;
        }));
    }

    protected processGetAddressMasterData(response: HttpResponseBase): Observable<AddressMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressMasterDto>(null as any);
    }

    getMediumTypeData(): Observable<MediumTypeResponse> {
        let url_ = this.baseUrl + "/api/Master/GetMediumTypeData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMediumTypeData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMediumTypeData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MediumTypeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MediumTypeResponse>;
        }));
    }

    protected processGetMediumTypeData(response: HttpResponseBase): Observable<MediumTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MediumTypeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediumTypeResponse>(null as any);
    }

    getAcademicYearData(): Observable<AcademicYearResponse> {
        let url_ = this.baseUrl + "/api/Master/GetAcademicYearData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAcademicYearData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAcademicYearData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicYearResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicYearResponse>;
        }));
    }

    protected processGetAcademicYearData(response: HttpResponseBase): Observable<AcademicYearResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicYearResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicYearResponse>(null as any);
    }

    getGradeDivisionMasterList(academicYearId: number | undefined): Observable<GradeDivisionMasterDto> {
        let url_ = this.baseUrl + "/api/Master/GetGradeDivisionMasterList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeDivisionMasterList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeDivisionMasterList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDivisionMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDivisionMasterDto>;
        }));
    }

    protected processGetGradeDivisionMasterList(response: HttpResponseBase): Observable<GradeDivisionMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeDivisionMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeDivisionMasterDto>(null as any);
    }

    getMonthMasterList(): Observable<MonthMasterResponse> {
        let url_ = this.baseUrl + "/api/Master/GetMonthMasterList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMonthMasterList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonthMasterList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MonthMasterResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MonthMasterResponse>;
        }));
    }

    protected processGetMonthMasterList(response: HttpResponseBase): Observable<MonthMasterResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MonthMasterResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MonthMasterResponse>(null as any);
    }

    getStudentDropdownData(academicYearId: number | undefined): Observable<CommonDropdownSelectListItemResponseDto> {
        let url_ = this.baseUrl + "/api/Master/GetStudentDropdownData?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentDropdownData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentDropdownData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonDropdownSelectListItemResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonDropdownSelectListItemResponseDto>;
        }));
    }

    protected processGetStudentDropdownData(response: HttpResponseBase): Observable<CommonDropdownSelectListItemResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonDropdownSelectListItemResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDropdownSelectListItemResponseDto>(null as any);
    }

    getTeacherDropdownData(academicYearId: number | undefined): Observable<TeacherDropdownSelectListResponseDto> {
        let url_ = this.baseUrl + "/api/Master/GetTeacherDropdownData?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherDropdownData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherDropdownData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherDropdownSelectListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherDropdownSelectListResponseDto>;
        }));
    }

    protected processGetTeacherDropdownData(response: HttpResponseBase): Observable<TeacherDropdownSelectListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherDropdownSelectListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherDropdownSelectListResponseDto>(null as any);
    }

    getTeacherDropdownWithoutSubject(): Observable<TeacherDropdownSelectListResponseDto> {
        let url_ = this.baseUrl + "/api/Master/GetTeacherDropdownWithoutSubject";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherDropdownWithoutSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherDropdownWithoutSubject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherDropdownSelectListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherDropdownSelectListResponseDto>;
        }));
    }

    protected processGetTeacherDropdownWithoutSubject(response: HttpResponseBase): Observable<TeacherDropdownSelectListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherDropdownSelectListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherDropdownSelectListResponseDto>(null as any);
    }

    getClerkDropdownData(academicYearId: number | undefined): Observable<CommonDropdownSelectListItemResponseDto> {
        let url_ = this.baseUrl + "/api/Master/GetClerkDropdownData?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClerkDropdownData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClerkDropdownData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonDropdownSelectListItemResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonDropdownSelectListItemResponseDto>;
        }));
    }

    protected processGetClerkDropdownData(response: HttpResponseBase): Observable<CommonDropdownSelectListItemResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonDropdownSelectListItemResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDropdownSelectListItemResponseDto>(null as any);
    }

    getCabDriverDropdownData(academicYearId: number | undefined): Observable<CommonDropdownSelectListItemResponseDto> {
        let url_ = this.baseUrl + "/api/Master/GetCabDriverDropdownData?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCabDriverDropdownData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCabDriverDropdownData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonDropdownSelectListItemResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonDropdownSelectListItemResponseDto>;
        }));
    }

    protected processGetCabDriverDropdownData(response: HttpResponseBase): Observable<CommonDropdownSelectListItemResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonDropdownSelectListItemResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDropdownSelectListItemResponseDto>(null as any);
    }
}

@Injectable()
export class SchoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getSchoolProfile(schoolId: number | undefined): Observable<SchoolDto> {
        let url_ = this.baseUrl + "/api/School/GetSchoolProfile?";
        if (schoolId === null)
            throw new Error("The parameter 'schoolId' cannot be null.");
        else if (schoolId !== undefined)
            url_ += "SchoolId=" + encodeURIComponent("" + schoolId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchoolProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchoolProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolDto>;
        }));
    }

    protected processGetSchoolProfile(response: HttpResponseBase): Observable<SchoolDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolDto>(null as any);
    }

    schoolProfileUpsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/School/SchoolProfileUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolProfileUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolProfileUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSchoolProfileUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getSchoolSettingProfile(schoolId: number | undefined, academicYearId: number | undefined): Observable<SchoolSettingDto> {
        let url_ = this.baseUrl + "/api/School/GetSchoolSettingProfile?";
        if (schoolId === null)
            throw new Error("The parameter 'schoolId' cannot be null.");
        else if (schoolId !== undefined)
            url_ += "SchoolId=" + encodeURIComponent("" + schoolId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchoolSettingProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchoolSettingProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolSettingDto>;
        }));
    }

    protected processGetSchoolSettingProfile(response: HttpResponseBase): Observable<SchoolSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchoolSettingDto>(null as any);
    }

    schoolSettingUpsert(schoolModel: SchoolSettingDto): Observable<number> {
        let url_ = this.baseUrl + "/api/School/SchoolSettingUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schoolModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchoolSettingUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchoolSettingUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSchoolSettingUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getCurrentSchoolAppVersion(): Observable<AppVersionDto> {
        let url_ = this.baseUrl + "/api/School/GetCurrentSchoolAppVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentSchoolAppVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentSchoolAppVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppVersionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppVersionDto>;
        }));
    }

    protected processGetCurrentSchoolAppVersion(response: HttpResponseBase): Observable<AppVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppVersionDto>(null as any);
    }
}

@Injectable()
export class StudentsImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    uploadStudentData(): Observable<ResponseImportStudentDataDto> {
        let url_ = this.baseUrl + "/api/StudentsImport/UploadStudentData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadStudentData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadStudentData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseImportStudentDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseImportStudentDataDto>;
        }));
    }

    protected processUploadStudentData(response: HttpResponseBase): Observable<ResponseImportStudentDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseImportStudentDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseImportStudentDataDto>(null as any);
    }
}

@Injectable()
export class SubjectImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    uploadSubjectData(): Observable<ResponseImportSubjectDataDto> {
        let url_ = this.baseUrl + "/api/SubjectImport/UploadSubjectData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadSubjectData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadSubjectData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseImportSubjectDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseImportSubjectDataDto>;
        }));
    }

    protected processUploadSubjectData(response: HttpResponseBase): Observable<ResponseImportSubjectDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseImportSubjectDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseImportSubjectDataDto>(null as any);
    }
}

@Injectable()
export class TeacherImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    uploadTeacherData(): Observable<ResponseImportTeacherDataDto> {
        let url_ = this.baseUrl + "/api/TeacherImport/UploadTeacherData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadTeacherData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadTeacherData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseImportTeacherDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseImportTeacherDataDto>;
        }));
    }

    protected processUploadTeacherData(response: HttpResponseBase): Observable<ResponseImportTeacherDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseImportTeacherDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseImportTeacherDataDto>(null as any);
    }
}

@Injectable()
export class HomeworkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getHomeworkGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Homework/GetHomeworkGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHomeworkGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHomeworkGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetHomeworkGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    homeworkSelect(homeworkId: number | undefined): Observable<HomeworkUpsertDto> {
        let url_ = this.baseUrl + "/api/Homework/HomeworkSelect?";
        if (homeworkId === null)
            throw new Error("The parameter 'homeworkId' cannot be null.");
        else if (homeworkId !== undefined)
            url_ += "HomeworkId=" + encodeURIComponent("" + homeworkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeworkSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeworkSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HomeworkUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HomeworkUpsertDto>;
        }));
    }

    protected processHomeworkSelect(response: HttpResponseBase): Observable<HomeworkUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HomeworkUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeworkUpsertDto>(null as any);
    }

    homeworkUpsert(): Observable<HomeworkUpsertDto> {
        let url_ = this.baseUrl + "/api/Homework/HomeworkUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeworkUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeworkUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HomeworkUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HomeworkUpsertDto>;
        }));
    }

    protected processHomeworkUpsert(response: HttpResponseBase): Observable<HomeworkUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HomeworkUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeworkUpsertDto>(null as any);
    }

    uploadHomeworkMediaChunk(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Homework/UploadHomeworkMediaChunk";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadHomeworkMediaChunk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadHomeworkMediaChunk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadHomeworkMediaChunk(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    homeWorkDelete(homeworkId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Homework/HomeWorkDelete?";
        if (homeworkId === null)
            throw new Error("The parameter 'homeworkId' cannot be null.");
        else if (homeworkId !== undefined)
            url_ += "homeworkId=" + encodeURIComponent("" + homeworkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeWorkDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeWorkDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processHomeWorkDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    publishUnpublishHomeworkParticulars(publishRequest: PublishUnpublishHomeworkDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Homework/PublishUnpublishHomeworkParticulars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishHomeworkParticulars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishHomeworkParticulars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishHomeworkParticulars(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getSubjectMappingDropdown(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<SubjectMappingDropdownResponseDto> {
        let url_ = this.baseUrl + "/api/Homework/GetSubjectMappingDropdown?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectMappingDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectMappingDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectMappingDropdownResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectMappingDropdownResponseDto>;
        }));
    }

    protected processGetSubjectMappingDropdown(response: HttpResponseBase): Observable<SubjectMappingDropdownResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectMappingDropdownResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectMappingDropdownResponseDto>(null as any);
    }

    getAllHomeworkForStudent(requestDto: ParentAppHomeworkRequestDto): Observable<ParentAppHomeworkResponseDto> {
        let url_ = this.baseUrl + "/api/Homework/GetAllHomeworkForStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHomeworkForStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHomeworkForStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentAppHomeworkResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentAppHomeworkResponseDto>;
        }));
    }

    protected processGetAllHomeworkForStudent(response: HttpResponseBase): Observable<ParentAppHomeworkResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParentAppHomeworkResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParentAppHomeworkResponseDto>(null as any);
    }
}

@Injectable()
export class GradeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getGradeData(gradeId: number | null | undefined): Observable<GradeDto> {
        let url_ = this.baseUrl + "/api/Grade/GetGradeData?";
        if (gradeId !== undefined && gradeId !== null)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDto>;
        }));
    }

    protected processGetGradeData(response: HttpResponseBase): Observable<GradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeDto>(null as any);
    }

    gradeDataUpsert(gradeObj: GradeDto): Observable<GradeUpdateRespose> {
        let url_ = this.baseUrl + "/api/Grade/GradeDataUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gradeObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGradeDataUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGradeDataUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeUpdateRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeUpdateRespose>;
        }));
    }

    protected processGradeDataUpsert(response: HttpResponseBase): Observable<GradeUpdateRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeUpdateRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeUpdateRespose>(null as any);
    }

    getGradeList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Grade/GetGradeList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetGradeList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    gradeDataDelete(gradeId: number | undefined, academicYearId: number | undefined): Observable<GradeDeleteRespose> {
        let url_ = this.baseUrl + "/api/Grade/GradeDataDelete?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGradeDataDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGradeDataDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDeleteRespose>;
        }));
    }

    protected processGradeDataDelete(response: HttpResponseBase): Observable<GradeDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeDeleteRespose>(null as any);
    }
}

@Injectable()
export class GradeDivisionMatrixServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getGradeDivisionMatrixData(gradeId: number | null | undefined, academicYearId: number | undefined): Observable<GradeDivisionMatrixDto> {
        let url_ = this.baseUrl + "/api/GradeDivisionMatrix/GetGradeDivisionMatrixData?";
        if (gradeId !== undefined && gradeId !== null)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeDivisionMatrixData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeDivisionMatrixData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDivisionMatrixDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDivisionMatrixDto>;
        }));
    }

    protected processGetGradeDivisionMatrixData(response: HttpResponseBase): Observable<GradeDivisionMatrixDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeDivisionMatrixDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeDivisionMatrixDto>(null as any);
    }

    gradeDivisionMatrixDataUpsert(academicYearId: number | undefined, gradeDivisionObj: GradeDivisionMatrixDto): Observable<number> {
        let url_ = this.baseUrl + "/api/GradeDivisionMatrix/GradeDivisionMatrixDataUpsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gradeDivisionObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGradeDivisionMatrixDataUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGradeDivisionMatrixDataUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGradeDivisionMatrixDataUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getGradeDivisionMatrixList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/GradeDivisionMatrix/GetGradeDivisionMatrixList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeDivisionMatrixList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeDivisionMatrixList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetGradeDivisionMatrixList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    gradeDivisionMatrixDelete(gradeId: number | null | undefined, divisionName: string | null | undefined, academicYearId: number | undefined): Observable<GradeDivisionMatrixDeleteRespose> {
        let url_ = this.baseUrl + "/api/GradeDivisionMatrix/GradeDivisionMatrixDelete?";
        if (gradeId !== undefined && gradeId !== null)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionName !== undefined && divisionName !== null)
            url_ += "divisionName=" + encodeURIComponent("" + divisionName) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGradeDivisionMatrixDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGradeDivisionMatrixDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDivisionMatrixDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDivisionMatrixDeleteRespose>;
        }));
    }

    protected processGradeDivisionMatrixDelete(response: HttpResponseBase): Observable<GradeDivisionMatrixDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeDivisionMatrixDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeDivisionMatrixDeleteRespose>(null as any);
    }
}

@Injectable()
export class GalleryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getGalleryGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Gallery/GetGalleryGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGalleryGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGalleryGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetGalleryGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    gallerySelect(galleryId: number | undefined): Observable<GalleryUpsertDto> {
        let url_ = this.baseUrl + "/api/Gallery/GallerySelect?";
        if (galleryId === null)
            throw new Error("The parameter 'galleryId' cannot be null.");
        else if (galleryId !== undefined)
            url_ += "galleryId=" + encodeURIComponent("" + galleryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGallerySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGallerySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GalleryUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GalleryUpsertDto>;
        }));
    }

    protected processGallerySelect(response: HttpResponseBase): Observable<GalleryUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GalleryUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GalleryUpsertDto>(null as any);
    }

    galleryUpsert(): Observable<GalleryUpsertDto> {
        let url_ = this.baseUrl + "/api/Gallery/GalleryUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGalleryUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGalleryUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GalleryUpsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GalleryUpsertDto>;
        }));
    }

    protected processGalleryUpsert(response: HttpResponseBase): Observable<GalleryUpsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GalleryUpsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GalleryUpsertDto>(null as any);
    }

    uploadGalleryMediaChunk(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Gallery/UploadGalleryMediaChunk";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadGalleryMediaChunk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadGalleryMediaChunk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadGalleryMediaChunk(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    galleryDelete(galleryId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Gallery/GalleryDelete?";
        if (galleryId === null)
            throw new Error("The parameter 'galleryId' cannot be null.");
        else if (galleryId !== undefined)
            url_ += "galleryId=" + encodeURIComponent("" + galleryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGalleryDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGalleryDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGalleryDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    publishUnpublishGalleryParticulars(publishRequest: PublishUnpublishGalleryDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Gallery/PublishUnpublishGalleryParticulars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishGalleryParticulars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishGalleryParticulars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishGalleryParticulars(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getGalleryFromRoleAppSelectList(): Observable<CommonDropdownSelectListItemResponseDto> {
        let url_ = this.baseUrl + "/api/Gallery/GetGalleryFromRoleAppSelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGalleryFromRoleAppSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGalleryFromRoleAppSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonDropdownSelectListItemResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonDropdownSelectListItemResponseDto>;
        }));
    }

    protected processGetGalleryFromRoleAppSelectList(response: HttpResponseBase): Observable<CommonDropdownSelectListItemResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonDropdownSelectListItemResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDropdownSelectListItemResponseDto>(null as any);
    }

    getAllGalleryForStudent(requestDto: ParentAppGalleryRequestDto): Observable<ParentAppGalleryResponseDto> {
        let url_ = this.baseUrl + "/api/Gallery/GetAllGalleryForStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGalleryForStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGalleryForStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentAppGalleryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentAppGalleryResponseDto>;
        }));
    }

    protected processGetAllGalleryForStudent(response: HttpResponseBase): Observable<ParentAppGalleryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParentAppGalleryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParentAppGalleryResponseDto>(null as any);
    }
}

@Injectable()
export class FeeWavierTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getFeeWavierTypeList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/FeeWavierType/GetFeeWavierTypeList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeeWavierTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeeWavierTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetFeeWavierTypeList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getFeeWavierTypeSelect(feeWavierType: number | undefined, academicYearId: number | undefined): Observable<FeeWavierTypeSelectDto> {
        let url_ = this.baseUrl + "/api/FeeWavierType/GetFeeWavierTypeSelect?";
        if (feeWavierType === null)
            throw new Error("The parameter 'feeWavierType' cannot be null.");
        else if (feeWavierType !== undefined)
            url_ += "FeeWavierType=" + encodeURIComponent("" + feeWavierType) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeeWavierTypeSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeeWavierTypeSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeeWavierTypeSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeeWavierTypeSelectDto>;
        }));
    }

    protected processGetFeeWavierTypeSelect(response: HttpResponseBase): Observable<FeeWavierTypeSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeeWavierTypeSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeeWavierTypeSelectDto>(null as any);
    }

    feeWavierTypeUpsert(feeWavierTypeObj: FeeWavierTypeUpsertDto): Observable<CommonSuccessResponse> {
        let url_ = this.baseUrl + "/api/FeeWavierType/FeeWavierTypeUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feeWavierTypeObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeeWavierTypeUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeeWavierTypeUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonSuccessResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonSuccessResponse>;
        }));
    }

    protected processFeeWavierTypeUpsert(response: HttpResponseBase): Observable<CommonSuccessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonSuccessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonSuccessResponse>(null as any);
    }

    feeWavierTypeDelete(feeWavierTypeId: number | undefined): Observable<FeeWavierTypeDeleteResponseDto> {
        let url_ = this.baseUrl + "/api/FeeWavierType/FeeWavierTypeDelete?";
        if (feeWavierTypeId === null)
            throw new Error("The parameter 'feeWavierTypeId' cannot be null.");
        else if (feeWavierTypeId !== undefined)
            url_ += "feeWavierTypeId=" + encodeURIComponent("" + feeWavierTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeeWavierTypeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeeWavierTypeDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeeWavierTypeDeleteResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeeWavierTypeDeleteResponseDto>;
        }));
    }

    protected processFeeWavierTypeDelete(response: HttpResponseBase): Observable<FeeWavierTypeDeleteResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeeWavierTypeDeleteResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeeWavierTypeDeleteResponseDto>(null as any);
    }
}

@Injectable()
export class FeePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getFeePaymentGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/FeePayment/GetFeePaymentGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeePaymentGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeePaymentGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetFeePaymentGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getFeePaymentDueListByAY(studentId: number | undefined, currentAcademicYearInclude: boolean | undefined): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/FeePayment/GetFeePaymentDueListByAY?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (currentAcademicYearInclude === null)
            throw new Error("The parameter 'currentAcademicYearInclude' cannot be null.");
        else if (currentAcademicYearInclude !== undefined)
            url_ += "currentAcademicYearInclude=" + encodeURIComponent("" + currentAcademicYearInclude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeePaymentDueListByAY(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeePaymentDueListByAY(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetFeePaymentDueListByAY(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getFeePaymentSelect(academicYearId: number | undefined, studentId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<FeePaymentSelectDto> {
        let url_ = this.baseUrl + "/api/FeePayment/GetFeePaymentSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeePaymentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeePaymentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeePaymentSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeePaymentSelectDto>;
        }));
    }

    protected processGetFeePaymentSelect(response: HttpResponseBase): Observable<FeePaymentSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeePaymentSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeePaymentSelectDto>(null as any);
    }

    feePaymentUpsert(encryptedString: string | null | undefined, feePaymentUpsertDto: FeePaymentUpsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeePayment/FeePaymentUpsert?";
        if (encryptedString !== undefined && encryptedString !== null)
            url_ += "encryptedString=" + encodeURIComponent("" + encryptedString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feePaymentUpsertDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeePaymentUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeePaymentUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFeePaymentUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    feePaymentPreviousAYPedingFeeUpdate(studentId: number | undefined, previousAcademicYearPendingFeeAmount: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/FeePayment/FeePaymentPreviousAYPedingFeeUpdate?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (previousAcademicYearPendingFeeAmount === null)
            throw new Error("The parameter 'previousAcademicYearPendingFeeAmount' cannot be null.");
        else if (previousAcademicYearPendingFeeAmount !== undefined)
            url_ += "previousAcademicYearPendingFeeAmount=" + encodeURIComponent("" + previousAcademicYearPendingFeeAmount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeePaymentPreviousAYPedingFeeUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeePaymentPreviousAYPedingFeeUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFeePaymentPreviousAYPedingFeeUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getPaymentFeePageMasterActivityList(gradeId: number | undefined, divisionId: number | undefined, academicYearId: number | undefined, studentId: number | undefined): Observable<PaymentFeePageMasterActivityList> {
        let url_ = this.baseUrl + "/api/FeePayment/GetPaymentFeePageMasterActivityList?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentFeePageMasterActivityList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentFeePageMasterActivityList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentFeePageMasterActivityList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentFeePageMasterActivityList>;
        }));
    }

    protected processGetPaymentFeePageMasterActivityList(response: HttpResponseBase): Observable<PaymentFeePageMasterActivityList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentFeePageMasterActivityList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentFeePageMasterActivityList>(null as any);
    }

    getFeePaymentHistoryGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/FeePayment/GetFeePaymentHistoryGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeePaymentHistoryGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeePaymentHistoryGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetFeePaymentHistoryGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getFeePaymentHistorySelect(academicYearId: number | undefined, studentId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, feePaymentId: number | undefined): Observable<FeePaymentHistorySelectDto> {
        let url_ = this.baseUrl + "/api/FeePayment/GetFeePaymentHistorySelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (feePaymentId === null)
            throw new Error("The parameter 'feePaymentId' cannot be null.");
        else if (feePaymentId !== undefined)
            url_ += "feePaymentId=" + encodeURIComponent("" + feePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeePaymentHistorySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeePaymentHistorySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeePaymentHistorySelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeePaymentHistorySelectDto>;
        }));
    }

    protected processGetFeePaymentHistorySelect(response: HttpResponseBase): Observable<FeePaymentHistorySelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeePaymentHistorySelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeePaymentHistorySelectDto>(null as any);
    }

    feePaymentDelete(feePaymentId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/FeePayment/FeePaymentDelete?";
        if (feePaymentId === null)
            throw new Error("The parameter 'feePaymentId' cannot be null.");
        else if (feePaymentId !== undefined)
            url_ += "feePaymentId=" + encodeURIComponent("" + feePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeePaymentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeePaymentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFeePaymentDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    clearCheque(feePaymentId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/FeePayment/ClearCheque?";
        if (feePaymentId === null)
            throw new Error("The parameter 'feePaymentId' cannot be null.");
        else if (feePaymentId !== undefined)
            url_ += "feePaymentId=" + encodeURIComponent("" + feePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCheque(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCheque(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processClearCheque(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    getDayWisePaymentReport(request: DaywisePaymentReportRequest): Observable<DaywisePaymentReportDTO> {
        let url_ = this.baseUrl + "/api/FeePayment/GetDayWisePaymentReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDayWisePaymentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDayWisePaymentReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DaywisePaymentReportDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DaywisePaymentReportDTO>;
        }));
    }

    protected processGetDayWisePaymentReport(response: HttpResponseBase): Observable<DaywisePaymentReportDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DaywisePaymentReportDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DaywisePaymentReportDTO>(null as any);
    }
}

@Injectable()
export class FeeParticularServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getFeeParticularGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableRequestModel> {
        let url_ = this.baseUrl + "/api/FeeParticular/GetFeeParticularGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeeParticularGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeeParticularGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableRequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableRequestModel>;
        }));
    }

    protected processGetFeeParticularGridList(response: HttpResponseBase): Observable<DatatableRequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableRequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableRequestModel>(null as any);
    }

    getFeeParticularSelect(classId: number | undefined, academicYearId: number | undefined): Observable<FeeStructureDto> {
        let url_ = this.baseUrl + "/api/FeeParticular/GetFeeParticularSelect?";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "ClassId=" + encodeURIComponent("" + classId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeeParticularSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeeParticularSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeeStructureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeeStructureDto>;
        }));
    }

    protected processGetFeeParticularSelect(response: HttpResponseBase): Observable<FeeStructureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeeStructureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeeStructureDto>(null as any);
    }

    feeParticularInsert(feeParticularInsertObj: FeeStructureDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/FeeParticularInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feeParticularInsertObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeeParticularInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeeParticularInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFeeParticularInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    feeParticularUpdate(feeParticularUpdateObj: FeeStructureDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/FeeParticularUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feeParticularUpdateObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeeParticularUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeeParticularUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFeeParticularUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getAllApplicableWaiverData(academicYearId: number | undefined): Observable<FeeWaiverResponseDto> {
        let url_ = this.baseUrl + "/api/FeeParticular/GetAllApplicableWaiverData?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllApplicableWaiverData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllApplicableWaiverData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeeWaiverResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeeWaiverResponseDto>;
        }));
    }

    protected processGetAllApplicableWaiverData(response: HttpResponseBase): Observable<FeeWaiverResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeeWaiverResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeeWaiverResponseDto>(null as any);
    }

    getGradeDivisionFeeParticularMasterList(academicYearId: number | undefined): Observable<GradeDivisionWithDisabledCommonMasterDto> {
        let url_ = this.baseUrl + "/api/FeeParticular/GetGradeDivisionFeeParticularMasterList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeDivisionFeeParticularMasterList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeDivisionFeeParticularMasterList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDivisionWithDisabledCommonMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDivisionWithDisabledCommonMasterDto>;
        }));
    }

    protected processGetGradeDivisionFeeParticularMasterList(response: HttpResponseBase): Observable<GradeDivisionWithDisabledCommonMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeDivisionWithDisabledCommonMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeDivisionWithDisabledCommonMasterDto>(null as any);
    }

    publishUnpublishGradeDivisionParticulars(publishRequest: PublishUnpublishParticularDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/PublishUnpublishGradeDivisionParticulars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishGradeDivisionParticulars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishGradeDivisionParticulars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishGradeDivisionParticulars(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    feeParticularClone(cloneRequest: FeeParticularCloneDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/FeeParticularClone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cloneRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeeParticularClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeeParticularClone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFeeParticularClone(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    feeParticularDelete(gradeId: number | undefined, divisionId: number | undefined, academicYearId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/FeeParticularDelete?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeeParticularDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeeParticularDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFeeParticularDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    copyFeeParticularsFromLastAY(gradeId: number | undefined, divisionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/CopyFeeParticularsFromLastAY?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyFeeParticularsFromLastAY(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyFeeParticularsFromLastAY(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCopyFeeParticularsFromLastAY(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getStudentKitFeeParticularGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableRequestModel> {
        let url_ = this.baseUrl + "/api/FeeParticular/GetStudentKitFeeParticularGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitFeeParticularGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitFeeParticularGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableRequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableRequestModel>;
        }));
    }

    protected processGetStudentKitFeeParticularGridList(response: HttpResponseBase): Observable<DatatableRequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableRequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableRequestModel>(null as any);
    }

    getStudentKitFeeParticularByClassId(classId: number | undefined, academicYearId: number | undefined): Observable<StudentKitFeeStructureDto> {
        let url_ = this.baseUrl + "/api/FeeParticular/GetStudentKitFeeParticularByClassId?";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "ClassId=" + encodeURIComponent("" + classId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitFeeParticularByClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitFeeParticularByClassId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitFeeStructureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitFeeStructureDto>;
        }));
    }

    protected processGetStudentKitFeeParticularByClassId(response: HttpResponseBase): Observable<StudentKitFeeStructureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitFeeStructureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitFeeStructureDto>(null as any);
    }

    studentKitFeeParticularInsert(feeParticularInsertObj: StudentKitFeeStructureDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/StudentKitFeeParticularInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feeParticularInsertObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentKitFeeParticularInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentKitFeeParticularInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentKitFeeParticularInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    studentKitFeeParticularUpdate(feeParticularUpdateObj: StudentKitFeeStructureDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/StudentKitFeeParticularUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feeParticularUpdateObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentKitFeeParticularUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentKitFeeParticularUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentKitFeeParticularUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getGradeDivisionStudentKitFeeParticularMasterList(academicYearId: number | undefined): Observable<GradeDivisionWithDisabledCommonMasterDto> {
        let url_ = this.baseUrl + "/api/FeeParticular/GetGradeDivisionStudentKitFeeParticularMasterList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeDivisionStudentKitFeeParticularMasterList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeDivisionStudentKitFeeParticularMasterList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDivisionWithDisabledCommonMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDivisionWithDisabledCommonMasterDto>;
        }));
    }

    protected processGetGradeDivisionStudentKitFeeParticularMasterList(response: HttpResponseBase): Observable<GradeDivisionWithDisabledCommonMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeDivisionWithDisabledCommonMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeDivisionWithDisabledCommonMasterDto>(null as any);
    }

    publishUnpublishGradeDivisionStudentKitParticulars(publishRequest: PublishUnpublishParticularDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/PublishUnpublishGradeDivisionStudentKitParticulars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishGradeDivisionStudentKitParticulars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishGradeDivisionStudentKitParticulars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishGradeDivisionStudentKitParticulars(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    studentKitFeeParticularClone(cloneRequest: FeeParticularCloneDto): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/StudentKitFeeParticularClone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cloneRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentKitFeeParticularClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentKitFeeParticularClone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentKitFeeParticularClone(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    studentKitFeeParticularDelete(gradeId: number | undefined, divisionId: number | undefined, academicYearId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/StudentKitFeeParticularDelete?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentKitFeeParticularDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentKitFeeParticularDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentKitFeeParticularDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    copyStudentKitFeeParticularsFromLastAY(gradeId: number | undefined, divisionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/FeeParticular/CopyStudentKitFeeParticularsFromLastAY?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyStudentKitFeeParticularsFromLastAY(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyStudentKitFeeParticularsFromLastAY(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCopyStudentKitFeeParticularsFromLastAY(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class PaymentAnalyticsExportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getExportPaymentAnalyticsSchool(academicYearId: number | undefined): Observable<PaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/PaymentAnalyticsExport/GetExportPaymentAnalyticsSchool?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportPaymentAnalyticsSchool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportPaymentAnalyticsSchool(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAnalyticsExportDto>;
        }));
    }

    protected processGetExportPaymentAnalyticsSchool(response: HttpResponseBase): Observable<PaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAnalyticsExportDto>(null as any);
    }

    getExportPaymentAnalyticsGrade(academicYearId: number | undefined, gradeId: number | undefined): Observable<PaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/PaymentAnalyticsExport/GetExportPaymentAnalyticsGrade?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportPaymentAnalyticsGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportPaymentAnalyticsGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAnalyticsExportDto>;
        }));
    }

    protected processGetExportPaymentAnalyticsGrade(response: HttpResponseBase): Observable<PaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAnalyticsExportDto>(null as any);
    }

    getExportPaymentAnalyticsDivision(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<PaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/PaymentAnalyticsExport/GetExportPaymentAnalyticsDivision?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportPaymentAnalyticsDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportPaymentAnalyticsDivision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAnalyticsExportDto>;
        }));
    }

    protected processGetExportPaymentAnalyticsDivision(response: HttpResponseBase): Observable<PaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAnalyticsExportDto>(null as any);
    }
}

@Injectable()
export class StudentExportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    exportStudentData(academicYearId: number | undefined): Observable<ResponseExportStudentDataDto> {
        let url_ = this.baseUrl + "/api/StudentExport/ExportStudentData?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportStudentData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportStudentData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseExportStudentDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseExportStudentDataDto>;
        }));
    }

    protected processExportStudentData(response: HttpResponseBase): Observable<ResponseExportStudentDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseExportStudentDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseExportStudentDataDto>(null as any);
    }
}

@Injectable()
export class StudentKitPaymentAnalyticsExportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getStudentKitPaymentAnalyticsExportSchool(academicYearId: number | undefined): Observable<StudentKitPaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/StudentKitPaymentAnalyticsExport/GetStudentKitPaymentAnalyticsExportSchool?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitPaymentAnalyticsExportSchool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitPaymentAnalyticsExportSchool(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitPaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitPaymentAnalyticsExportDto>;
        }));
    }

    protected processGetStudentKitPaymentAnalyticsExportSchool(response: HttpResponseBase): Observable<StudentKitPaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitPaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitPaymentAnalyticsExportDto>(null as any);
    }

    getStudentKitExportPaymentAnalyticsGrade(academicYearId: number | undefined, gradeId: number | undefined): Observable<StudentKitPaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/StudentKitPaymentAnalyticsExport/GetStudentKitExportPaymentAnalyticsGrade?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitExportPaymentAnalyticsGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitExportPaymentAnalyticsGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitPaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitPaymentAnalyticsExportDto>;
        }));
    }

    protected processGetStudentKitExportPaymentAnalyticsGrade(response: HttpResponseBase): Observable<StudentKitPaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitPaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitPaymentAnalyticsExportDto>(null as any);
    }

    getStudentKitExportPaymentAnalyticsDivision(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<StudentKitPaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/StudentKitPaymentAnalyticsExport/GetStudentKitExportPaymentAnalyticsDivision?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentKitExportPaymentAnalyticsDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentKitExportPaymentAnalyticsDivision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentKitPaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentKitPaymentAnalyticsExportDto>;
        }));
    }

    protected processGetStudentKitExportPaymentAnalyticsDivision(response: HttpResponseBase): Observable<StudentKitPaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentKitPaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentKitPaymentAnalyticsExportDto>(null as any);
    }
}

@Injectable()
export class TeacherExportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    exportTeacherData(): Observable<ResponseExportTeacherDataDto> {
        let url_ = this.baseUrl + "/api/TeacherExport/ExportTeacherData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTeacherData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTeacherData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseExportTeacherDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseExportTeacherDataDto>;
        }));
    }

    protected processExportTeacherData(response: HttpResponseBase): Observable<ResponseExportTeacherDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseExportTeacherDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseExportTeacherDataDto>(null as any);
    }
}

@Injectable()
export class TransportPaymentAnalyticsExportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getTransportExportPaymentAnalyticsSchool(academicYearId: number | undefined): Observable<TransportPaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalyticsExport/GetTransportExportPaymentAnalyticsSchool?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportExportPaymentAnalyticsSchool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportExportPaymentAnalyticsSchool(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsExportDto>;
        }));
    }

    protected processGetTransportExportPaymentAnalyticsSchool(response: HttpResponseBase): Observable<TransportPaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsExportDto>(null as any);
    }

    getTransportExportPaymentAnalyticsGrade(academicYearId: number | undefined, gradeId: number | undefined): Observable<TransportPaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalyticsExport/GetTransportExportPaymentAnalyticsGrade?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportExportPaymentAnalyticsGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportExportPaymentAnalyticsGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsExportDto>;
        }));
    }

    protected processGetTransportExportPaymentAnalyticsGrade(response: HttpResponseBase): Observable<TransportPaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsExportDto>(null as any);
    }

    getTransportExportPaymentAnalyticsDivision(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<TransportPaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalyticsExport/GetTransportExportPaymentAnalyticsDivision?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportExportPaymentAnalyticsDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportExportPaymentAnalyticsDivision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsExportDto>;
        }));
    }

    protected processGetTransportExportPaymentAnalyticsDivision(response: HttpResponseBase): Observable<TransportPaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsExportDto>(null as any);
    }

    getTransportExportPaymentAnalyticsStaffList(academicYearId: number | undefined): Observable<TransportPaymentAnalyticsExportDto> {
        let url_ = this.baseUrl + "/api/TransportPaymentAnalyticsExport/GetTransportExportPaymentAnalyticsStaffList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportExportPaymentAnalyticsStaffList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportExportPaymentAnalyticsStaffList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportPaymentAnalyticsExportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportPaymentAnalyticsExportDto>;
        }));
    }

    protected processGetTransportExportPaymentAnalyticsStaffList(response: HttpResponseBase): Observable<TransportPaymentAnalyticsExportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportPaymentAnalyticsExportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportPaymentAnalyticsExportDto>(null as any);
    }
}

@Injectable()
export class DivisionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getDivisionData(divisionId: number | null | undefined): Observable<DivisionDto> {
        let url_ = this.baseUrl + "/api/Division/GetDivisionData?";
        if (divisionId !== undefined && divisionId !== null)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDivisionData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDivisionData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DivisionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DivisionDto>;
        }));
    }

    protected processGetDivisionData(response: HttpResponseBase): Observable<DivisionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DivisionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DivisionDto>(null as any);
    }

    divisionDataUpsert(divisionObj: DivisionDto): Observable<DivisionUpdateleteRespose> {
        let url_ = this.baseUrl + "/api/Division/DivisionDataUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(divisionObj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDivisionDataUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDivisionDataUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DivisionUpdateleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DivisionUpdateleteRespose>;
        }));
    }

    protected processDivisionDataUpsert(response: HttpResponseBase): Observable<DivisionUpdateleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DivisionUpdateleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DivisionUpdateleteRespose>(null as any);
    }

    getDivisionList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Division/GetDivisionList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDivisionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDivisionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetDivisionList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    divisionDataDelete(gradeId: number | undefined, academicYearId: number | undefined): Observable<DivisionDeleteRespose> {
        let url_ = this.baseUrl + "/api/Division/DivisionDataDelete?";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDivisionDataDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDivisionDataDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DivisionDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DivisionDeleteRespose>;
        }));
    }

    protected processDivisionDataDelete(response: HttpResponseBase): Observable<DivisionDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DivisionDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DivisionDeleteRespose>(null as any);
    }
}

@Injectable()
export class DashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getDashboardCount(): Observable<DashboardCountDto> {
        let url_ = this.baseUrl + "/api/DashBoard/GetDashboardCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardCountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardCountDto>;
        }));
    }

    protected processGetDashboardCount(response: HttpResponseBase): Observable<DashboardCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardCountDto>(null as any);
    }

    getDashboardStaffDetails(): Observable<DashBoardStaffDetailsDto> {
        let url_ = this.baseUrl + "/api/DashBoard/GetDashboardStaffDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStaffDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStaffDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashBoardStaffDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashBoardStaffDetailsDto>;
        }));
    }

    protected processGetDashboardStaffDetails(response: HttpResponseBase): Observable<DashBoardStaffDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashBoardStaffDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashBoardStaffDetailsDto>(null as any);
    }

    getDashboardGirlsBoysCount(): Observable<GirlsBoysCountDto> {
        let url_ = this.baseUrl + "/api/DashBoard/GetDashboardGirlsBoysCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardGirlsBoysCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardGirlsBoysCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GirlsBoysCountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GirlsBoysCountDto>;
        }));
    }

    protected processGetDashboardGirlsBoysCount(response: HttpResponseBase): Observable<GirlsBoysCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GirlsBoysCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GirlsBoysCountDto>(null as any);
    }

    getAdminDashboardCount(academicYearId: number | undefined): Observable<AdminDashboardCountDto> {
        let url_ = this.baseUrl + "/api/DashBoard/GetAdminDashboardCount?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminDashboardCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminDashboardCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDashboardCountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDashboardCountDto>;
        }));
    }

    protected processGetAdminDashboardCount(response: HttpResponseBase): Observable<AdminDashboardCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDashboardCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDashboardCountDto>(null as any);
    }

    getIdealTeacherList(academicYearId: number | undefined): Observable<IdealTeacherListResponseDto> {
        let url_ = this.baseUrl + "/api/DashBoard/GetIdealTeacherList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdealTeacherList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdealTeacherList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdealTeacherListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdealTeacherListResponseDto>;
        }));
    }

    protected processGetIdealTeacherList(response: HttpResponseBase): Observable<IdealTeacherListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdealTeacherListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdealTeacherListResponseDto>(null as any);
    }

    getTeacherDashboardCount(academicYearId: number | undefined, teacherId: number | undefined): Observable<TeacherDashboardCountDto> {
        let url_ = this.baseUrl + "/api/DashBoard/GetTeacherDashboardCount?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (teacherId === null)
            throw new Error("The parameter 'teacherId' cannot be null.");
        else if (teacherId !== undefined)
            url_ += "TeacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherDashboardCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherDashboardCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherDashboardCountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherDashboardCountDto>;
        }));
    }

    protected processGetTeacherDashboardCount(response: HttpResponseBase): Observable<TeacherDashboardCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherDashboardCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherDashboardCountDto>(null as any);
    }
}

@Injectable()
export class ClerkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getClerkProfile(clerkId: number | undefined): Observable<ClerkDto> {
        let url_ = this.baseUrl + "/api/Clerk/GetClerkProfile?";
        if (clerkId === null)
            throw new Error("The parameter 'clerkId' cannot be null.");
        else if (clerkId !== undefined)
            url_ += "ClerkId=" + encodeURIComponent("" + clerkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClerkProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClerkProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClerkDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClerkDto>;
        }));
    }

    protected processGetClerkProfile(response: HttpResponseBase): Observable<ClerkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClerkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClerkDto>(null as any);
    }

    clerkProfileUpsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/Clerk/ClerkProfileUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClerkProfileUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClerkProfileUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processClerkProfileUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getClerkList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Clerk/GetClerkList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClerkList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClerkList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetClerkList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    clerkProfileDelete(clerkId: number | undefined): Observable<ClerkDeleteRespose> {
        let url_ = this.baseUrl + "/api/Clerk/ClerkProfileDelete?";
        if (clerkId === null)
            throw new Error("The parameter 'clerkId' cannot be null.");
        else if (clerkId !== undefined)
            url_ += "clerkId=" + encodeURIComponent("" + clerkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClerkProfileDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClerkProfileDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClerkDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClerkDeleteRespose>;
        }));
    }

    protected processClerkProfileDelete(response: HttpResponseBase): Observable<ClerkDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClerkDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClerkDeleteRespose>(null as any);
    }
}

@Injectable()
export class ClassWiseTeacherAndStudentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    classTeacherSelect(academicYearId: number | undefined): Observable<ClassTeacherResponseDto> {
        let url_ = this.baseUrl + "/api/ClassWiseTeacherAndStudent/ClassTeacherSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassTeacherSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassTeacherSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassTeacherResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassTeacherResponseDto>;
        }));
    }

    protected processClassTeacherSelect(response: HttpResponseBase): Observable<ClassTeacherResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassTeacherResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassTeacherResponseDto>(null as any);
    }

    classWiseStudentSelect(academicYearId: number | undefined, classTeacherId: number | undefined): Observable<ClassWiseStudentResponseDto> {
        let url_ = this.baseUrl + "/api/ClassWiseTeacherAndStudent/ClassWiseStudentSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (classTeacherId === null)
            throw new Error("The parameter 'classTeacherId' cannot be null.");
        else if (classTeacherId !== undefined)
            url_ += "ClassTeacherId=" + encodeURIComponent("" + classTeacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassWiseStudentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassWiseStudentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassWiseStudentResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassWiseStudentResponseDto>;
        }));
    }

    protected processClassWiseStudentSelect(response: HttpResponseBase): Observable<ClassWiseStudentResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassWiseStudentResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassWiseStudentResponseDto>(null as any);
    }
}

@Injectable()
export class ClassTimeTableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getClassTimeTable(classId: number | undefined): Observable<ClassTimeTableSelectResponseDto> {
        let url_ = this.baseUrl + "/api/ClassTimeTable/GetClassTimeTable?";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "ClassId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassTimeTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassTimeTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassTimeTableSelectResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassTimeTableSelectResponseDto>;
        }));
    }

    protected processGetClassTimeTable(response: HttpResponseBase): Observable<ClassTimeTableSelectResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassTimeTableSelectResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassTimeTableSelectResponseDto>(null as any);
    }

    getClassTimeTableList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/ClassTimeTable/GetClassTimeTableList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassTimeTableList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassTimeTableList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetClassTimeTableList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    classTimeTableUpsert(classTimeTable: ClassTimeTableDto): Observable<CreateTimeTableResponse> {
        let url_ = this.baseUrl + "/api/ClassTimeTable/ClassTimeTableUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classTimeTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassTimeTableUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassTimeTableUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateTimeTableResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateTimeTableResponse>;
        }));
    }

    protected processClassTimeTableUpsert(response: HttpResponseBase): Observable<CreateTimeTableResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTimeTableResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTimeTableResponse>(null as any);
    }

    classTimeTableDelete(classTimeTableId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/ClassTimeTable/ClassTimeTableDelete?";
        if (classTimeTableId === null)
            throw new Error("The parameter 'classTimeTableId' cannot be null.");
        else if (classTimeTableId !== undefined)
            url_ += "ClassTimeTableId=" + encodeURIComponent("" + classTimeTableId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassTimeTableDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassTimeTableDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processClassTimeTableDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getTeacherClassTimeTable(requestDto: TeacherClassTimeTableRequestDto): Observable<ClassTimeTableSelectResponseDto> {
        let url_ = this.baseUrl + "/api/ClassTimeTable/GetTeacherClassTimeTable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherClassTimeTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherClassTimeTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassTimeTableSelectResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassTimeTableSelectResponseDto>;
        }));
    }

    protected processGetTeacherClassTimeTable(response: HttpResponseBase): Observable<ClassTimeTableSelectResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassTimeTableSelectResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassTimeTableSelectResponseDto>(null as any);
    }

    getStudentClassTimeTable(requestDto: StudentClassTimeTableRequestDto): Observable<ClassTimeTableSelectResponseDto> {
        let url_ = this.baseUrl + "/api/ClassTimeTable/GetStudentClassTimeTable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentClassTimeTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentClassTimeTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassTimeTableSelectResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassTimeTableSelectResponseDto>;
        }));
    }

    protected processGetStudentClassTimeTable(response: HttpResponseBase): Observable<ClassTimeTableSelectResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassTimeTableSelectResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassTimeTableSelectResponseDto>(null as any);
    }

    markTimeTableActiveUpsert(requestModel: MarkTimeTableActiveRequestModel): Observable<number> {
        let url_ = this.baseUrl + "/api/ClassTimeTable/MarkTimeTableActiveUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkTimeTableActiveUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkTimeTableActiveUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processMarkTimeTableActiveUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    validateTimeTable(academicYearId: number | undefined, lstClassTimeTableId: number[]): Observable<CreateTimeTableResponse> {
        let url_ = this.baseUrl + "/api/ClassTimeTable/ValidateTimeTable?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lstClassTimeTableId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateTimeTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateTimeTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateTimeTableResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateTimeTableResponse>;
        }));
    }

    protected processValidateTimeTable(response: HttpResponseBase): Observable<CreateTimeTableResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTimeTableResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTimeTableResponse>(null as any);
    }
}

@Injectable()
export class ClassTeacherDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getClassTeacherData(academicYearId: number | undefined, userId: number | undefined): Observable<ClassTeacherDataDto> {
        let url_ = this.baseUrl + "/api/ClassTeacherData/GetClassTeacherData?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassTeacherData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassTeacherData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassTeacherDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassTeacherDataDto>;
        }));
    }

    protected processGetClassTeacherData(response: HttpResponseBase): Observable<ClassTeacherDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassTeacherDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassTeacherDataDto>(null as any);
    }
}

@Injectable()
export class CertificateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    bonafiedCertificateSelect(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, studentId: number | undefined): Observable<CertificateDto> {
        let url_ = this.baseUrl + "/api/Certificate/BonafiedCertificateSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBonafiedCertificateSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBonafiedCertificateSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CertificateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CertificateDto>;
        }));
    }

    protected processBonafiedCertificateSelect(response: HttpResponseBase): Observable<CertificateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificateDto>(null as any);
    }

    idCardSelect(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, studentId: number | undefined): Observable<CertificateDto> {
        let url_ = this.baseUrl + "/api/Certificate/IdCardSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIdCardSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIdCardSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CertificateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CertificateDto>;
        }));
    }

    protected processIdCardSelect(response: HttpResponseBase): Observable<CertificateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificateDto>(null as any);
    }

    characterCertificateSelect(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, studentId: number | undefined): Observable<CertificateDto> {
        let url_ = this.baseUrl + "/api/Certificate/CharacterCertificateSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCharacterCertificateSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCharacterCertificateSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CertificateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CertificateDto>;
        }));
    }

    protected processCharacterCertificateSelect(response: HttpResponseBase): Observable<CertificateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificateDto>(null as any);
    }

    getCertificateList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Certificate/GetCertificateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetCertificateList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    certificateUpsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/Certificate/CertificateUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCertificateUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCertificateUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCertificateUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getCertificate(certificateAuditsId: number | undefined, academicYearId: number | undefined): Observable<CertificateAuditDto> {
        let url_ = this.baseUrl + "/api/Certificate/GetCertificate?";
        if (certificateAuditsId === null)
            throw new Error("The parameter 'certificateAuditsId' cannot be null.");
        else if (certificateAuditsId !== undefined)
            url_ += "CertificateAuditsId=" + encodeURIComponent("" + certificateAuditsId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CertificateAuditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CertificateAuditDto>;
        }));
    }

    protected processGetCertificate(response: HttpResponseBase): Observable<CertificateAuditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateAuditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificateAuditDto>(null as any);
    }

    getStudentNames(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<StudentNameModelResponse> {
        let url_ = this.baseUrl + "/api/Certificate/GetStudentNames?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentNameModelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentNameModelResponse>;
        }));
    }

    protected processGetStudentNames(response: HttpResponseBase): Observable<StudentNameModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentNameModelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentNameModelResponse>(null as any);
    }

    getStudentNamesWithArchive(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<StudentNameModelResponse> {
        let url_ = this.baseUrl + "/api/Certificate/GetStudentNamesWithArchive?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentNamesWithArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentNamesWithArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentNameModelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentNameModelResponse>;
        }));
    }

    protected processGetStudentNamesWithArchive(response: HttpResponseBase): Observable<StudentNameModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentNameModelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentNameModelResponse>(null as any);
    }

    getLeavingCertificateHistory(studentId: number | undefined): Observable<LeavingCertificateHistory> {
        let url_ = this.baseUrl + "/api/Certificate/GetLeavingCertificateHistory?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeavingCertificateHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeavingCertificateHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeavingCertificateHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeavingCertificateHistory>;
        }));
    }

    protected processGetLeavingCertificateHistory(response: HttpResponseBase): Observable<LeavingCertificateHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavingCertificateHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavingCertificateHistory>(null as any);
    }

    leavingCertificatePrintSelect(leavingCertificateAuditsId: number | undefined, studentId: number | undefined, makeAsDuplicate: boolean | undefined): Observable<CertificateDto> {
        let url_ = this.baseUrl + "/api/Certificate/LeavingCertificatePrintSelect?";
        if (leavingCertificateAuditsId === null)
            throw new Error("The parameter 'leavingCertificateAuditsId' cannot be null.");
        else if (leavingCertificateAuditsId !== undefined)
            url_ += "LeavingCertificateAuditsId=" + encodeURIComponent("" + leavingCertificateAuditsId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (makeAsDuplicate === null)
            throw new Error("The parameter 'makeAsDuplicate' cannot be null.");
        else if (makeAsDuplicate !== undefined)
            url_ += "makeAsDuplicate=" + encodeURIComponent("" + makeAsDuplicate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeavingCertificatePrintSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeavingCertificatePrintSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CertificateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CertificateDto>;
        }));
    }

    protected processLeavingCertificatePrintSelect(response: HttpResponseBase): Observable<CertificateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificateDto>(null as any);
    }

    leavingCertificateStatusUpdate(leavingCertificateAuditsId: number | undefined, studentId: number | undefined, statusId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Certificate/LeavingCertificateStatusUpdate?";
        if (leavingCertificateAuditsId === null)
            throw new Error("The parameter 'leavingCertificateAuditsId' cannot be null.");
        else if (leavingCertificateAuditsId !== undefined)
            url_ += "LeavingCertificateAuditsId=" + encodeURIComponent("" + leavingCertificateAuditsId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (statusId === null)
            throw new Error("The parameter 'statusId' cannot be null.");
        else if (statusId !== undefined)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeavingCertificateStatusUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeavingCertificateStatusUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processLeavingCertificateStatusUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    leavingCertificateGenerateAsDuplicate(leavingCertificateAuditsId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Certificate/LeavingCertificateGenerateAsDuplicate?";
        if (leavingCertificateAuditsId === null)
            throw new Error("The parameter 'leavingCertificateAuditsId' cannot be null.");
        else if (leavingCertificateAuditsId !== undefined)
            url_ += "LeavingCertificateAuditsId=" + encodeURIComponent("" + leavingCertificateAuditsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeavingCertificateGenerateAsDuplicate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeavingCertificateGenerateAsDuplicate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processLeavingCertificateGenerateAsDuplicate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    leavingCertificateUpsert(model: LeavingCertificateDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Certificate/LeavingCertificateUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeavingCertificateUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeavingCertificateUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processLeavingCertificateUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    leavingCertificateSelect(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, studentId: number | undefined): Observable<CertificateDto> {
        let url_ = this.baseUrl + "/api/Certificate/LeavingCertificateSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeavingCertificateSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeavingCertificateSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CertificateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CertificateDto>;
        }));
    }

    protected processLeavingCertificateSelect(response: HttpResponseBase): Observable<CertificateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificateDto>(null as any);
    }

    getListLeavingCertificateSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Certificate/GetListLeavingCertificateSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListLeavingCertificateSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListLeavingCertificateSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetListLeavingCertificateSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }
}

@Injectable()
export class CBSE_ExamResultServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getExamResultGridList(requestDto: CBSE_ExamResultRequestDto): Observable<CBSE_ExamResultDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamResult/GetExamResultGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExamResultGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExamResultGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ExamResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ExamResultDto>;
        }));
    }

    protected processGetExamResultGridList(response: HttpResponseBase): Observable<CBSE_ExamResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ExamResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ExamResultDto>(null as any);
    }

    examResultUpsert(examResultDto: CBSE_ExamResultDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CBSE_ExamResult/ExamResultUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examResultDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExamResultUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExamResultUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processExamResultUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getExamNameList(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<ExamResultResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamResult/GetExamNameList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExamNameList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExamNameList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamResultResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamResultResponseDto>;
        }));
    }

    protected processGetExamNameList(response: HttpResponseBase): Observable<ExamResultResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamResultResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamResultResponseDto>(null as any);
    }

    getSubjectNameList(academicYearId: number | undefined, examMasterId: number | undefined): Observable<ExamResultResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamResult/GetSubjectNameList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (examMasterId === null)
            throw new Error("The parameter 'examMasterId' cannot be null.");
        else if (examMasterId !== undefined)
            url_ += "ExamMasterId=" + encodeURIComponent("" + examMasterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectNameList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectNameList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamResultResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamResultResponseDto>;
        }));
    }

    protected processGetSubjectNameList(response: HttpResponseBase): Observable<ExamResultResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamResultResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamResultResponseDto>(null as any);
    }

    getMarkGradeList(academicYearId: number | undefined): Observable<ExamResultResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamResult/GetMarkGradeList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMarkGradeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMarkGradeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamResultResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamResultResponseDto>;
        }));
    }

    protected processGetMarkGradeList(response: HttpResponseBase): Observable<ExamResultResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamResultResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamResultResponseDto>(null as any);
    }

    uspCBSE_ExamResultGridSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/CBSE_ExamResult/uspCBSE_ExamResultGridSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUspCBSE_ExamResultGridSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUspCBSE_ExamResultGridSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processUspCBSE_ExamResultGridSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }
}

@Injectable()
export class CBSE_ExamReportCardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getExamMasterListForReport(examNameRequestDto: ExamNameRequestDto): Observable<CBSE_ExamNameResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamReportCard/GetExamMasterListForReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examNameRequestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExamMasterListForReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExamMasterListForReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ExamNameResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ExamNameResponseDto>;
        }));
    }

    protected processGetExamMasterListForReport(response: HttpResponseBase): Observable<CBSE_ExamNameResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ExamNameResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ExamNameResponseDto>(null as any);
    }

    getExamReportCardGridSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/CBSE_ExamReportCard/GetExamReportCardGridSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExamReportCardGridSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExamReportCardGridSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetExamReportCardGridSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getExamReportCardSelect(examReportCardNameId: number | undefined, academicYearId: number | undefined): Observable<CBSE_ExamReportCardNameDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamReportCard/GetExamReportCardSelect?";
        if (examReportCardNameId === null)
            throw new Error("The parameter 'examReportCardNameId' cannot be null.");
        else if (examReportCardNameId !== undefined)
            url_ += "examReportCardNameId=" + encodeURIComponent("" + examReportCardNameId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExamReportCardSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExamReportCardSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ExamReportCardNameDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ExamReportCardNameDto>;
        }));
    }

    protected processGetExamReportCardSelect(response: HttpResponseBase): Observable<CBSE_ExamReportCardNameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ExamReportCardNameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ExamReportCardNameDto>(null as any);
    }

    examReportCardDelete(examReportCardNameId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/CBSE_ExamReportCard/ExamReportCardDelete?";
        if (examReportCardNameId === null)
            throw new Error("The parameter 'examReportCardNameId' cannot be null.");
        else if (examReportCardNameId !== undefined)
            url_ += "examReportCardNameId=" + encodeURIComponent("" + examReportCardNameId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExamReportCardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExamReportCardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processExamReportCardDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    examReportCardUpsert(academicYearId: number | undefined, obj: ExamReportCardUpsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CBSE_ExamReportCard/ExamReportCardUpsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExamReportCardUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExamReportCardUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processExamReportCardUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class CBSE_ExamObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    cBSE_ExamMasterGridSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ExamMasterGridSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ExamMasterGridSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ExamMasterGridSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processCBSE_ExamMasterGridSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    cBSE_ExamMasterSelect(examMasterId: number | undefined): Observable<CBSE_ExamMasterDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ExamMasterSelect?";
        if (examMasterId === null)
            throw new Error("The parameter 'examMasterId' cannot be null.");
        else if (examMasterId !== undefined)
            url_ += "ExamMasterId=" + encodeURIComponent("" + examMasterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ExamMasterSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ExamMasterSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ExamMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ExamMasterDto>;
        }));
    }

    protected processCBSE_ExamMasterSelect(response: HttpResponseBase): Observable<CBSE_ExamMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ExamMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ExamMasterDto>(null as any);
    }

    cBSE_ExamMasterDelete(examMasterId: number | undefined): Observable<ExamMasterDeleteResponceDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ExamMasterDelete?";
        if (examMasterId === null)
            throw new Error("The parameter 'examMasterId' cannot be null.");
        else if (examMasterId !== undefined)
            url_ += "ExamMasterId=" + encodeURIComponent("" + examMasterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ExamMasterDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ExamMasterDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamMasterDeleteResponceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamMasterDeleteResponceDto>;
        }));
    }

    protected processCBSE_ExamMasterDelete(response: HttpResponseBase): Observable<ExamMasterDeleteResponceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamMasterDeleteResponceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamMasterDeleteResponceDto>(null as any);
    }

    cBSE_ExamObjectGridSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ExamObjectGridSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ExamObjectGridSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ExamObjectGridSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processCBSE_ExamObjectGridSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    cBSE_ExamMasterUpsert(academicYearId: number | undefined, obj: CBSE_ExamMasterDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ExamMasterUpsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ExamMasterUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ExamMasterUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCBSE_ExamMasterUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    cBSE_ExamObjectSelect(examMasterId: number | undefined, subjectMasterId: number | undefined, academicYearId: number | undefined): Observable<CBSE_ExamObjectDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ExamObjectSelect?";
        if (examMasterId === null)
            throw new Error("The parameter 'examMasterId' cannot be null.");
        else if (examMasterId !== undefined)
            url_ += "ExamMasterId=" + encodeURIComponent("" + examMasterId) + "&";
        if (subjectMasterId === null)
            throw new Error("The parameter 'subjectMasterId' cannot be null.");
        else if (subjectMasterId !== undefined)
            url_ += "SubjectMasterId=" + encodeURIComponent("" + subjectMasterId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ExamObjectSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ExamObjectSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ExamObjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ExamObjectDto>;
        }));
    }

    protected processCBSE_ExamObjectSelect(response: HttpResponseBase): Observable<CBSE_ExamObjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ExamObjectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ExamObjectDto>(null as any);
    }

    publishUnpublishExamObjectParticular(publishRequest: PublishUnpublishExamObjectDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/PublishUnpublishExamObjectParticular";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishUnpublishExamObjectParticular(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishUnpublishExamObjectParticular(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPublishUnpublishExamObjectParticular(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    cBSE_ExamObjectDelete(examMasterId: number | null | undefined, subjectMasterId: number | undefined, academicYearId: number | undefined): Observable<ExamObjectDeleteRespose> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ExamObjectDelete?";
        if (examMasterId !== undefined && examMasterId !== null)
            url_ += "ExamMasterId=" + encodeURIComponent("" + examMasterId) + "&";
        if (subjectMasterId === null)
            throw new Error("The parameter 'subjectMasterId' cannot be null.");
        else if (subjectMasterId !== undefined)
            url_ += "SubjectMasterId=" + encodeURIComponent("" + subjectMasterId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ExamObjectDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ExamObjectDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamObjectDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamObjectDeleteRespose>;
        }));
    }

    protected processCBSE_ExamObjectDelete(response: HttpResponseBase): Observable<ExamObjectDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamObjectDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamObjectDeleteRespose>(null as any);
    }

    cBSE_ExamObjectUpsert(obj: CBSE_ExamObjectDto): Observable<ExamObjectExistResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ExamObjectUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ExamObjectUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ExamObjectUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamObjectExistResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamObjectExistResponseDto>;
        }));
    }

    protected processCBSE_ExamObjectUpsert(response: HttpResponseBase): Observable<ExamObjectExistResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamObjectExistResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamObjectExistResponseDto>(null as any);
    }

    getExamTypeList(): Observable<CBSE_ResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/GetExamTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExamTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExamTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ResponseDto>;
        }));
    }

    protected processGetExamTypeList(response: HttpResponseBase): Observable<CBSE_ResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ResponseDto>(null as any);
    }

    getTermList(): Observable<CBSE_ResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/GetTermList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTermList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTermList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ResponseDto>;
        }));
    }

    protected processGetTermList(response: HttpResponseBase): Observable<CBSE_ResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ResponseDto>(null as any);
    }

    cBSE_ClassExamMappingGridSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ClassExamMappingGridSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ClassExamMappingGridSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ClassExamMappingGridSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processCBSE_ClassExamMappingGridSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    cBSE_ClassExamMappingSelect(classExamMappingId: number | undefined): Observable<CBSE_ClassExamMappingDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ClassExamMappingSelect?";
        if (classExamMappingId === null)
            throw new Error("The parameter 'classExamMappingId' cannot be null.");
        else if (classExamMappingId !== undefined)
            url_ += "ClassExamMappingId=" + encodeURIComponent("" + classExamMappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ClassExamMappingSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ClassExamMappingSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ClassExamMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ClassExamMappingDto>;
        }));
    }

    protected processCBSE_ClassExamMappingSelect(response: HttpResponseBase): Observable<CBSE_ClassExamMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ClassExamMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ClassExamMappingDto>(null as any);
    }

    cBSE_ClassExamMappingDelete(examMasterId: number | undefined, academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ClassExamMappingDelete?";
        if (examMasterId === null)
            throw new Error("The parameter 'examMasterId' cannot be null.");
        else if (examMasterId !== undefined)
            url_ += "examMasterId=" + encodeURIComponent("" + examMasterId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ClassExamMappingDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ClassExamMappingDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCBSE_ClassExamMappingDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    cBSE_ClassExamMappingUpsert(academicYearId: number | undefined, examMasterId: number | undefined, obj: CBSE_ClassExamMappingDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ClassExamMappingUpsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (examMasterId === null)
            throw new Error("The parameter 'examMasterId' cannot be null.");
        else if (examMasterId !== undefined)
            url_ += "examMasterId=" + encodeURIComponent("" + examMasterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ClassExamMappingUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ClassExamMappingUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCBSE_ClassExamMappingUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getExamNameList(academicYearId: number | undefined): Observable<CBSE_ExamNameResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/GetExamNameList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExamNameList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExamNameList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_ExamNameResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_ExamNameResponseDto>;
        }));
    }

    protected processGetExamNameList(response: HttpResponseBase): Observable<CBSE_ExamNameResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_ExamNameResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_ExamNameResponseDto>(null as any);
    }

    cBSE_MarksGradeRelationGridSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_MarksGradeRelationGridSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_MarksGradeRelationGridSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_MarksGradeRelationGridSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processCBSE_MarksGradeRelationGridSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    cBSE_MarksGradeRelationSelect(marksGradeRelationId: number | undefined): Observable<CBSE_MarksGradeRelationDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_MarksGradeRelationSelect?";
        if (marksGradeRelationId === null)
            throw new Error("The parameter 'marksGradeRelationId' cannot be null.");
        else if (marksGradeRelationId !== undefined)
            url_ += "MarksGradeRelationId=" + encodeURIComponent("" + marksGradeRelationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_MarksGradeRelationSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_MarksGradeRelationSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_MarksGradeRelationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_MarksGradeRelationDto>;
        }));
    }

    protected processCBSE_MarksGradeRelationSelect(response: HttpResponseBase): Observable<CBSE_MarksGradeRelationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_MarksGradeRelationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_MarksGradeRelationDto>(null as any);
    }

    cBSE_MarksGradeRelationDelete(marksGradeRelationId: number | undefined): Observable<MarksGradeRelationDeleteRespose> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_MarksGradeRelationDelete?";
        if (marksGradeRelationId === null)
            throw new Error("The parameter 'marksGradeRelationId' cannot be null.");
        else if (marksGradeRelationId !== undefined)
            url_ += "MarksGradeRelationId=" + encodeURIComponent("" + marksGradeRelationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_MarksGradeRelationDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_MarksGradeRelationDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MarksGradeRelationDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MarksGradeRelationDeleteRespose>;
        }));
    }

    protected processCBSE_MarksGradeRelationDelete(response: HttpResponseBase): Observable<MarksGradeRelationDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MarksGradeRelationDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MarksGradeRelationDeleteRespose>(null as any);
    }

    cBSE_MarksGradeRelationUpsert(academicYearId: number | undefined, obj: CBSE_MarksGradeRelationDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_MarksGradeRelationUpsert?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_MarksGradeRelationUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_MarksGradeRelationUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCBSE_MarksGradeRelationUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    cBSE_ObjectDelete(obj: ExamObjectDeleteRequestDto): Observable<ExamObjectDeleteResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_ExamObject/CBSE_ObjectDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCBSE_ObjectDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCBSE_ObjectDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamObjectDeleteResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamObjectDeleteResponseDto>;
        }));
    }

    protected processCBSE_ObjectDelete(response: HttpResponseBase): Observable<ExamObjectDeleteResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamObjectDeleteResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamObjectDeleteResponseDto>(null as any);
    }
}

@Injectable()
export class CBSE_AcademicAssessmentReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    resultReportSearchSelect(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, studentId: number | undefined): Observable<CBSE_AcademicAssessmentReportDto> {
        let url_ = this.baseUrl + "/api/CBSE_AcademicAssessmentReport/ResultReportSearchSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResultReportSearchSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResultReportSearchSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CBSE_AcademicAssessmentReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CBSE_AcademicAssessmentReportDto>;
        }));
    }

    protected processResultReportSearchSelect(response: HttpResponseBase): Observable<CBSE_AcademicAssessmentReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CBSE_AcademicAssessmentReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CBSE_AcademicAssessmentReportDto>(null as any);
    }

    resultTempleteReportSearchSelect(studentId: number | undefined, academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, examReportCardNameId: number | undefined): Observable<ResultTempleteReportSearchResponseDto> {
        let url_ = this.baseUrl + "/api/CBSE_AcademicAssessmentReport/ResultTempleteReportSearchSelect?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (examReportCardNameId === null)
            throw new Error("The parameter 'examReportCardNameId' cannot be null.");
        else if (examReportCardNameId !== undefined)
            url_ += "ExamReportCardNameId=" + encodeURIComponent("" + examReportCardNameId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResultTempleteReportSearchSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResultTempleteReportSearchSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultTempleteReportSearchResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultTempleteReportSearchResponseDto>;
        }));
    }

    protected processResultTempleteReportSearchSelect(response: HttpResponseBase): Observable<ResultTempleteReportSearchResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultTempleteReportSearchResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultTempleteReportSearchResponseDto>(null as any);
    }

    reportCardTemplateDropdown(academicYearId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<ReportCardTempleteDropdownResponceDto> {
        let url_ = this.baseUrl + "/api/CBSE_AcademicAssessmentReport/ReportCardTemplateDropdown?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportCardTemplateDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportCardTemplateDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportCardTempleteDropdownResponceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportCardTempleteDropdownResponceDto>;
        }));
    }

    protected processReportCardTemplateDropdown(response: HttpResponseBase): Observable<ReportCardTempleteDropdownResponceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportCardTempleteDropdownResponceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportCardTempleteDropdownResponceDto>(null as any);
    }

    studentMonthlyAttendanceSelect(studentId: number | undefined, academicYearId: number | undefined): Observable<StudentMonthlyAttendanceResponceDto> {
        let url_ = this.baseUrl + "/api/CBSE_AcademicAssessmentReport/StudentMonthlyAttendanceSelect?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "AcademicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentMonthlyAttendanceSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentMonthlyAttendanceSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentMonthlyAttendanceResponceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentMonthlyAttendanceResponceDto>;
        }));
    }

    protected processStudentMonthlyAttendanceSelect(response: HttpResponseBase): Observable<StudentMonthlyAttendanceResponceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentMonthlyAttendanceResponceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentMonthlyAttendanceResponceDto>(null as any);
    }
}

@Injectable()
export class CabDriverServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getCabDriverProfile(cabDriverId: number | undefined): Observable<CabDriverDto> {
        let url_ = this.baseUrl + "/api/CabDriver/GetCabDriverProfile?";
        if (cabDriverId === null)
            throw new Error("The parameter 'cabDriverId' cannot be null.");
        else if (cabDriverId !== undefined)
            url_ += "CabDriverId=" + encodeURIComponent("" + cabDriverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCabDriverProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCabDriverProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabDriverDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabDriverDto>;
        }));
    }

    protected processGetCabDriverProfile(response: HttpResponseBase): Observable<CabDriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CabDriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabDriverDto>(null as any);
    }

    cabDriverProfileUpsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/CabDriver/CabDriverProfileUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCabDriverProfileUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCabDriverProfileUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCabDriverProfileUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getCabDriverList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/CabDriver/GetCabDriverList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCabDriverList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCabDriverList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetCabDriverList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    cabDriverDelete(cabDriverId: number | undefined): Observable<CabDriverDeleteRespose> {
        let url_ = this.baseUrl + "/api/CabDriver/CabDriverDelete?";
        if (cabDriverId === null)
            throw new Error("The parameter 'cabDriverId' cannot be null.");
        else if (cabDriverId !== undefined)
            url_ += "cabDriverId=" + encodeURIComponent("" + cabDriverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCabDriverDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCabDriverDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabDriverDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabDriverDeleteRespose>;
        }));
    }

    protected processCabDriverDelete(response: HttpResponseBase): Observable<CabDriverDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CabDriverDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabDriverDeleteRespose>(null as any);
    }
}

@Injectable()
export class CabDriverAppServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    cabDrverProfileUpdate(): Observable<number> {
        let url_ = this.baseUrl + "/api/CabDriverApp/CabDrverProfileUpdate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCabDrverProfileUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCabDrverProfileUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCabDrverProfileUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getCabDriverProfile(cabDriverId: number | undefined): Observable<CabDriverProfileAppDto> {
        let url_ = this.baseUrl + "/api/CabDriverApp/GetCabDriverProfile?";
        if (cabDriverId === null)
            throw new Error("The parameter 'cabDriverId' cannot be null.");
        else if (cabDriverId !== undefined)
            url_ += "CabDriverId=" + encodeURIComponent("" + cabDriverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCabDriverProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCabDriverProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabDriverProfileAppDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabDriverProfileAppDto>;
        }));
    }

    protected processGetCabDriverProfile(response: HttpResponseBase): Observable<CabDriverProfileAppDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CabDriverProfileAppDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabDriverProfileAppDto>(null as any);
    }

    getCabDriverAppRouteSelect(cabDriverId: number | undefined): Observable<CabDriverRouteListDto> {
        let url_ = this.baseUrl + "/api/CabDriverApp/GetCabDriverAppRouteSelect?";
        if (cabDriverId === null)
            throw new Error("The parameter 'cabDriverId' cannot be null.");
        else if (cabDriverId !== undefined)
            url_ += "CabDriverId=" + encodeURIComponent("" + cabDriverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCabDriverAppRouteSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCabDriverAppRouteSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabDriverRouteListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabDriverRouteListDto>;
        }));
    }

    protected processGetCabDriverAppRouteSelect(response: HttpResponseBase): Observable<CabDriverRouteListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CabDriverRouteListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabDriverRouteListDto>(null as any);
    }

    getCabDriverAppStoppageStudentSelect(routeId: number | null | undefined, tripType: string | null | undefined): Observable<CabdriverAppStoppageStudentDto> {
        let url_ = this.baseUrl + "/api/CabDriverApp/GetCabDriverAppStoppageStudentSelect?";
        if (routeId !== undefined && routeId !== null)
            url_ += "RouteId=" + encodeURIComponent("" + routeId) + "&";
        if (tripType !== undefined && tripType !== null)
            url_ += "TripType=" + encodeURIComponent("" + tripType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCabDriverAppStoppageStudentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCabDriverAppStoppageStudentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabdriverAppStoppageStudentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabdriverAppStoppageStudentDto>;
        }));
    }

    protected processGetCabDriverAppStoppageStudentSelect(response: HttpResponseBase): Observable<CabdriverAppStoppageStudentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CabdriverAppStoppageStudentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabdriverAppStoppageStudentDto>(null as any);
    }

    cabDriverTripUpsert(trip: CabDriverTripDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CabDriverApp/CabDriverTripUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trip);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCabDriverTripUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCabDriverTripUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCabDriverTripUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    cabDriverTripDetailUpsert(tripDetail: CabDriverAppTripDetailsDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CabDriverApp/CabDriverTripDetailUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tripDetail);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCabDriverTripDetailUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCabDriverTripDetailUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCabDriverTripDetailUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getStudentSelect(qRCode: string | null | undefined): Observable<StudentInformationDto> {
        let url_ = this.baseUrl + "/api/CabDriverApp/GetStudentSelect?";
        if (qRCode !== undefined && qRCode !== null)
            url_ += "QRCode=" + encodeURIComponent("" + qRCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentInformationDto>;
        }));
    }

    protected processGetStudentSelect(response: HttpResponseBase): Observable<StudentInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentInformationDto>(null as any);
    }

    updateCabDriverLocationByTrip(currentLocation: CabDriverLocationDto): Observable<number> {
        let url_ = this.baseUrl + "/api/CabDriverApp/UpdateCabDriverLocationByTrip";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentLocation);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCabDriverLocationByTrip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCabDriverLocationByTrip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateCabDriverLocationByTrip(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getStudentList(tripId: number | undefined): Observable<CabDriverTripNotificationResponceDto> {
        let url_ = this.baseUrl + "/api/CabDriverApp/GetStudentList?";
        if (tripId === null)
            throw new Error("The parameter 'tripId' cannot be null.");
        else if (tripId !== undefined)
            url_ += "TripId=" + encodeURIComponent("" + tripId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabDriverTripNotificationResponceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabDriverTripNotificationResponceDto>;
        }));
    }

    protected processGetStudentList(response: HttpResponseBase): Observable<CabDriverTripNotificationResponceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CabDriverTripNotificationResponceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabDriverTripNotificationResponceDto>(null as any);
    }

    getActivetripSelect(requestDto: CabDriverActiveTripRequestDto): Observable<CabDriverActiveTripDto> {
        let url_ = this.baseUrl + "/api/CabDriverApp/GetActivetripSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivetripSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivetripSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabDriverActiveTripDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabDriverActiveTripDto>;
        }));
    }

    protected processGetActivetripSelect(response: HttpResponseBase): Observable<CabDriverActiveTripDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CabDriverActiveTripDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabDriverActiveTripDto>(null as any);
    }

    getCurrentActiveTripId(cabDriverUserId: number | undefined): Observable<CabDriverActiveTripDto> {
        let url_ = this.baseUrl + "/api/CabDriverApp/GetCurrentActiveTripId?";
        if (cabDriverUserId === null)
            throw new Error("The parameter 'cabDriverUserId' cannot be null.");
        else if (cabDriverUserId !== undefined)
            url_ += "CabDriverUserId=" + encodeURIComponent("" + cabDriverUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentActiveTripId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentActiveTripId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabDriverActiveTripDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabDriverActiveTripDto>;
        }));
    }

    protected processGetCurrentActiveTripId(response: HttpResponseBase): Observable<CabDriverActiveTripDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CabDriverActiveTripDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabDriverActiveTripDto>(null as any);
    }
}

@Injectable()
export class BulkAttendanceUpdateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    classAttendanceStatusGridSelect(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/BulkAttendanceUpdate/ClassAttendanceStatusGridSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassAttendanceStatusGridSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassAttendanceStatusGridSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processClassAttendanceStatusGridSelect(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getStudentAttendanceByMonthSelect(request: StudentAttendanceUpdateRequestDto): Observable<BulkSelectResponseDto> {
        let url_ = this.baseUrl + "/api/BulkAttendanceUpdate/GetStudentAttendanceByMonthSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentAttendanceByMonthSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentAttendanceByMonthSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkSelectResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkSelectResponseDto>;
        }));
    }

    protected processGetStudentAttendanceByMonthSelect(response: HttpResponseBase): Observable<BulkSelectResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkSelectResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkSelectResponseDto>(null as any);
    }

    studentAttendanceByMonthUpsert(attendanceUpdate: BulkAttendanceUpdateDto): Observable<number> {
        let url_ = this.baseUrl + "/api/BulkAttendanceUpdate/StudentAttendanceByMonthUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(attendanceUpdate);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStudentAttendanceByMonthUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStudentAttendanceByMonthUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStudentAttendanceByMonthUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getAttendanceSummaryByMonth(request: StudentAttendanceUpdateRequestDto): Observable<AttendanceSummaryBulkResponseDto> {
        let url_ = this.baseUrl + "/api/BulkAttendanceUpdate/GetAttendanceSummaryByMonth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttendanceSummaryByMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttendanceSummaryByMonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttendanceSummaryBulkResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttendanceSummaryBulkResponseDto>;
        }));
    }

    protected processGetAttendanceSummaryByMonth(response: HttpResponseBase): Observable<AttendanceSummaryBulkResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttendanceSummaryBulkResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttendanceSummaryBulkResponseDto>(null as any);
    }

    statusInsert(request: StudentAttendanceStatusInsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/BulkAttendanceUpdate/StatusInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStatusInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class AdminServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getAdminProfile(adminId: number | undefined): Observable<AdminDto> {
        let url_ = this.baseUrl + "/api/Admin/GetAdminProfile?";
        if (adminId === null)
            throw new Error("The parameter 'adminId' cannot be null.");
        else if (adminId !== undefined)
            url_ += "AdminId=" + encodeURIComponent("" + adminId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDto>;
        }));
    }

    protected processGetAdminProfile(response: HttpResponseBase): Observable<AdminDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDto>(null as any);
    }

    adminProfileUpsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/Admin/AdminProfileUpsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProfileUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProfileUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAdminProfileUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getAdminList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/Admin/GetAdminList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetAdminList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    adminProfileDelete(adminId: number | undefined): Observable<AdminDeleteRespose> {
        let url_ = this.baseUrl + "/api/Admin/AdminProfileDelete?";
        if (adminId === null)
            throw new Error("The parameter 'adminId' cannot be null.");
        else if (adminId !== undefined)
            url_ += "adminId=" + encodeURIComponent("" + adminId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProfileDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProfileDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDeleteRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDeleteRespose>;
        }));
    }

    protected processAdminProfileDelete(response: HttpResponseBase): Observable<AdminDeleteRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDeleteRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDeleteRespose>(null as any);
    }
}

@Injectable()
export class AdhocParticularMasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    adhocParticularMasterInsert(obj: AdhocParticularMasterDto): Observable<AdhocParticularMasterDtoInsertRespose> {
        let url_ = this.baseUrl + "/api/AdhocParticularMaster/AdhocParticularMasterInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obj);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdhocParticularMasterInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdhocParticularMasterInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdhocParticularMasterDtoInsertRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdhocParticularMasterDtoInsertRespose>;
        }));
    }

    protected processAdhocParticularMasterInsert(response: HttpResponseBase): Observable<AdhocParticularMasterDtoInsertRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdhocParticularMasterDtoInsertRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdhocParticularMasterDtoInsertRespose>(null as any);
    }

    getAdhocParticularList(academicYearId: number | undefined): Observable<AdhocParticularMasterDtoListRespose> {
        let url_ = this.baseUrl + "/api/AdhocParticularMaster/GetAdhocParticularList?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdhocParticularList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdhocParticularList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdhocParticularMasterDtoListRespose>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdhocParticularMasterDtoListRespose>;
        }));
    }

    protected processGetAdhocParticularList(response: HttpResponseBase): Observable<AdhocParticularMasterDtoListRespose> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdhocParticularMasterDtoListRespose.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdhocParticularMasterDtoListRespose>(null as any);
    }
}

@Injectable()
export class AdhocFeePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    getAdhocFeePaymentGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/AdhocFeePayment/GetAdhocFeePaymentGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdhocFeePaymentGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdhocFeePaymentGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetAdhocFeePaymentGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getAdhocFeePaymentSelect(academicYearId: number | undefined, studentId: number | undefined, gradeId: number | undefined, divisionId: number | undefined): Observable<AdhocFeePaymentSelectDto> {
        let url_ = this.baseUrl + "/api/AdhocFeePayment/GetAdhocFeePaymentSelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "GradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdhocFeePaymentSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdhocFeePaymentSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdhocFeePaymentSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdhocFeePaymentSelectDto>;
        }));
    }

    protected processGetAdhocFeePaymentSelect(response: HttpResponseBase): Observable<AdhocFeePaymentSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdhocFeePaymentSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdhocFeePaymentSelectDto>(null as any);
    }

    adhocFeePaymentUpsert(encryptedString: string | null | undefined, feePaymentUpsertDto: AdhocFeePaymentUpsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/AdhocFeePayment/AdhocFeePaymentUpsert?";
        if (encryptedString !== undefined && encryptedString !== null)
            url_ += "encryptedString=" + encodeURIComponent("" + encryptedString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feePaymentUpsertDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdhocFeePaymentUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdhocFeePaymentUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAdhocFeePaymentUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getAdhocFeePaymentHistoryGridList(requestObjectWrapper: DatatableRequestWrapper): Observable<DatatableResponseModel> {
        let url_ = this.baseUrl + "/api/AdhocFeePayment/GetAdhocFeePaymentHistoryGridList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestObjectWrapper);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdhocFeePaymentHistoryGridList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdhocFeePaymentHistoryGridList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatatableResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatatableResponseModel>;
        }));
    }

    protected processGetAdhocFeePaymentHistoryGridList(response: HttpResponseBase): Observable<DatatableResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatatableResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatatableResponseModel>(null as any);
    }

    getAdhocFeePaymentHistorySelect(academicYearId: number | undefined, studentId: number | undefined, gradeId: number | undefined, divisionId: number | undefined, feePaymentId: number | undefined): Observable<AdhocFeePaymentHistorySelectDto> {
        let url_ = this.baseUrl + "/api/AdhocFeePayment/GetAdhocFeePaymentHistorySelect?";
        if (academicYearId === null)
            throw new Error("The parameter 'academicYearId' cannot be null.");
        else if (academicYearId !== undefined)
            url_ += "academicYearId=" + encodeURIComponent("" + academicYearId) + "&";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        if (feePaymentId === null)
            throw new Error("The parameter 'feePaymentId' cannot be null.");
        else if (feePaymentId !== undefined)
            url_ += "feePaymentId=" + encodeURIComponent("" + feePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdhocFeePaymentHistorySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdhocFeePaymentHistorySelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdhocFeePaymentHistorySelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdhocFeePaymentHistorySelectDto>;
        }));
    }

    protected processGetAdhocFeePaymentHistorySelect(response: HttpResponseBase): Observable<AdhocFeePaymentHistorySelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdhocFeePaymentHistorySelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdhocFeePaymentHistorySelectDto>(null as any);
    }

    adhocFeePaymentDelete(feePaymentId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/AdhocFeePayment/AdhocFeePaymentDelete?";
        if (feePaymentId === null)
            throw new Error("The parameter 'feePaymentId' cannot be null.");
        else if (feePaymentId !== undefined)
            url_ += "feePaymentId=" + encodeURIComponent("" + feePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdhocFeePaymentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdhocFeePaymentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAdhocFeePaymentDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    adhocClearCheque(feePaymentId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdhocFeePayment/AdhocClearCheque?";
        if (feePaymentId === null)
            throw new Error("The parameter 'feePaymentId' cannot be null.");
        else if (feePaymentId !== undefined)
            url_ += "feePaymentId=" + encodeURIComponent("" + feePaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdhocClearCheque(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdhocClearCheque(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdhocClearCheque(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    getDayWiseAdhocPaymentReport(request: DaywiseAdhocPaymentReportRequest): Observable<AdhocFeePaymentDaywiseReportDto> {
        let url_ = this.baseUrl + "/api/AdhocFeePayment/GetDayWiseAdhocPaymentReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDayWiseAdhocPaymentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDayWiseAdhocPaymentReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdhocFeePaymentDaywiseReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdhocFeePaymentDaywiseReportDto>;
        }));
    }

    protected processGetDayWiseAdhocPaymentReport(response: HttpResponseBase): Observable<AdhocFeePaymentDaywiseReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdhocFeePaymentDaywiseReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdhocFeePaymentDaywiseReportDto>(null as any);
    }
}

@Injectable()
export class AccessServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7068";
    }

    rolePermissionUpsert(rolePermissionModel: PermissionDto[]): Observable<number> {
        let url_ = this.baseUrl + "/api/Access/RolePermissionUpsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rolePermissionModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermissionUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermissionUpsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRolePermissionUpsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getModulesPermissions(roleId: number | undefined): Observable<RoleModuleDto> {
        let url_ = this.baseUrl + "/api/Access/GetModulesPermissions?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModulesPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModulesPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleModuleDto>;
        }));
    }

    protected processGetModulesPermissions(response: HttpResponseBase): Observable<RoleModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleModuleDto>(null as any);
    }

    getRoleList(): Observable<RoleMasterDto> {
        let url_ = this.baseUrl + "/api/Access/GetRoleList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleMasterDto>;
        }));
    }

    protected processGetRoleList(response: HttpResponseBase): Observable<RoleMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleMasterDto>(null as any);
    }

    getPermissionsList(): Observable<PermissionMasterDto> {
        let url_ = this.baseUrl + "/api/Access/GetPermissionsList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionMasterDto>;
        }));
    }

    protected processGetPermissionsList(response: HttpResponseBase): Observable<PermissionMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionMasterDto>(null as any);
    }

    getModuleList(): Observable<ModuleMasterDto> {
        let url_ = this.baseUrl + "/api/Access/GetModuleList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleMasterDto>;
        }));
    }

    protected processGetModuleList(response: HttpResponseBase): Observable<ModuleMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleMasterDto>(null as any);
    }
}

export class WeeklyDayOffDto implements IWeeklyDayOffDto {
    academicYearId!: number;
    weeklyOffId!: number;
    multipleDayList!: WeeklyDayOffListDto[] | undefined;

    constructor(data?: IWeeklyDayOffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.weeklyOffId = _data["weeklyOffId"];
            if (Array.isArray(_data["multipleDayList"])) {
                this.multipleDayList = [] as any;
                for (let item of _data["multipleDayList"])
                    this.multipleDayList!.push(WeeklyDayOffListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeeklyDayOffDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeeklyDayOffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["weeklyOffId"] = this.weeklyOffId;
        if (Array.isArray(this.multipleDayList)) {
            data["multipleDayList"] = [];
            for (let item of this.multipleDayList)
                data["multipleDayList"].push(item.toJSON());
        }
        return data;
    }

    clone(): WeeklyDayOffDto {
        const json = this.toJSON();
        let result = new WeeklyDayOffDto();
        result.init(json);
        return result;
    }
}

export interface IWeeklyDayOffDto {
    academicYearId: number;
    weeklyOffId: number;
    multipleDayList: WeeklyDayOffListDto[] | undefined;
}

export class WeeklyDayOffListDto implements IWeeklyDayOffListDto {
    dayNo!: number;

    constructor(data?: IWeeklyDayOffListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dayNo = _data["dayNo"];
        }
    }

    static fromJS(data: any): WeeklyDayOffListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeeklyDayOffListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dayNo"] = this.dayNo;
        return data;
    }

    clone(): WeeklyDayOffListDto {
        const json = this.toJSON();
        let result = new WeeklyDayOffListDto();
        result.init(json);
        return result;
    }
}

export interface IWeeklyDayOffListDto {
    dayNo: number;
}

export class UserLoginResponse implements IUserLoginResponse {
    academicYearId!: number | undefined;
    schoolName!: string | undefined;
    langaugeCode!: string | undefined;
    token!: string;
    isFirstTimeLogin!: boolean;
    roles!: UserRolesDto[];
    resetPasswordObj!: ResetPasswordRequestDto;

    constructor(data?: IUserLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.schoolName = _data["schoolName"];
            this.langaugeCode = _data["langaugeCode"];
            this.token = _data["token"];
            this.isFirstTimeLogin = _data["isFirstTimeLogin"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRolesDto.fromJS(item));
            }
            this.resetPasswordObj = _data["resetPasswordObj"] ? ResetPasswordRequestDto.fromJS(_data["resetPasswordObj"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["schoolName"] = this.schoolName;
        data["langaugeCode"] = this.langaugeCode;
        data["token"] = this.token;
        data["isFirstTimeLogin"] = this.isFirstTimeLogin;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["resetPasswordObj"] = this.resetPasswordObj ? this.resetPasswordObj.toJSON() : <any>undefined;
        return data;
    }

    clone(): UserLoginResponse {
        const json = this.toJSON();
        let result = new UserLoginResponse();
        result.init(json);
        return result;
    }
}

export interface IUserLoginResponse {
    academicYearId: number | undefined;
    schoolName: string | undefined;
    langaugeCode: string | undefined;
    token: string;
    isFirstTimeLogin: boolean;
    roles: UserRolesDto[];
    resetPasswordObj: ResetPasswordRequestDto;
}

export class UserRolesDto implements IUserRolesDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleKey!: string | undefined;
    refId!: number | undefined;

    constructor(data?: IUserRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleKey = _data["roleKey"];
            this.refId = _data["refId"];
        }
    }

    static fromJS(data: any): UserRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleKey"] = this.roleKey;
        data["refId"] = this.refId;
        return data;
    }

    clone(): UserRolesDto {
        const json = this.toJSON();
        let result = new UserRolesDto();
        result.init(json);
        return result;
    }
}

export interface IUserRolesDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleKey: string | undefined;
    refId: number | undefined;
}

export class ResetPasswordRequestDto implements IResetPasswordRequestDto {
    userId!: number;
    password!: string;
    confirmPassword!: string;
    token!: string;
    schoolCode!: string;

    constructor(data?: IResetPasswordRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.token = _data["token"];
            this.schoolCode = _data["schoolCode"];
        }
    }

    static fromJS(data: any): ResetPasswordRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["token"] = this.token;
        data["schoolCode"] = this.schoolCode;
        return data;
    }

    clone(): ResetPasswordRequestDto {
        const json = this.toJSON();
        let result = new ResetPasswordRequestDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordRequestDto {
    userId: number;
    password: string;
    confirmPassword: string;
    token: string;
    schoolCode: string;
}

export class LoginDto implements ILoginDto {
    code!: string;
    username!: string;
    password!: string;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }

    clone(): LoginDto {
        const json = this.toJSON();
        let result = new LoginDto();
        result.init(json);
        return result;
    }
}

export interface ILoginDto {
    code: string;
    username: string;
    password: string;
}

export class UserRoleModulePermissionDto implements IUserRoleModulePermissionDto {
    logoUrl!: string | undefined;
    userId!: number;
    uname!: string | undefined;
    academicYearId!: number | undefined;
    schoolCode!: string | undefined;
    schoolName!: string | undefined;
    schoolId!: number | undefined;
    refId!: number | undefined;
    userIdByRole!: number | undefined;
    userFullNameByRole!: string;
    profileImageURL!: string;
    roleDetails!: UserRoleDetailDto[] | undefined;

    constructor(data?: IUserRoleModulePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logoUrl = _data["logoUrl"];
            this.userId = _data["userId"];
            this.uname = _data["uname"];
            this.academicYearId = _data["academicYearId"];
            this.schoolCode = _data["schoolCode"];
            this.schoolName = _data["schoolName"];
            this.schoolId = _data["schoolId"];
            this.refId = _data["refId"];
            this.userIdByRole = _data["userIdByRole"];
            this.userFullNameByRole = _data["userFullNameByRole"];
            this.profileImageURL = _data["profileImageURL"];
            if (Array.isArray(_data["roleDetails"])) {
                this.roleDetails = [] as any;
                for (let item of _data["roleDetails"])
                    this.roleDetails!.push(UserRoleDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleModulePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleModulePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logoUrl"] = this.logoUrl;
        data["userId"] = this.userId;
        data["uname"] = this.uname;
        data["academicYearId"] = this.academicYearId;
        data["schoolCode"] = this.schoolCode;
        data["schoolName"] = this.schoolName;
        data["schoolId"] = this.schoolId;
        data["refId"] = this.refId;
        data["userIdByRole"] = this.userIdByRole;
        data["userFullNameByRole"] = this.userFullNameByRole;
        data["profileImageURL"] = this.profileImageURL;
        if (Array.isArray(this.roleDetails)) {
            data["roleDetails"] = [];
            for (let item of this.roleDetails)
                data["roleDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserRoleModulePermissionDto {
        const json = this.toJSON();
        let result = new UserRoleModulePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleModulePermissionDto {
    logoUrl: string | undefined;
    userId: number;
    uname: string | undefined;
    academicYearId: number | undefined;
    schoolCode: string | undefined;
    schoolName: string | undefined;
    schoolId: number | undefined;
    refId: number | undefined;
    userIdByRole: number | undefined;
    userFullNameByRole: string;
    profileImageURL: string;
    roleDetails: UserRoleDetailDto[] | undefined;
}

export class UserRoleDetailDto implements IUserRoleDetailDto {
    refId!: number | undefined;
    roleId!: number;
    roleName!: string | undefined;
    roleKey!: string | undefined;
    allowedModules!: Module[] | undefined;

    constructor(data?: IUserRoleDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refId = _data["refId"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleKey = _data["roleKey"];
            if (Array.isArray(_data["allowedModules"])) {
                this.allowedModules = [] as any;
                for (let item of _data["allowedModules"])
                    this.allowedModules!.push(Module.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refId"] = this.refId;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleKey"] = this.roleKey;
        if (Array.isArray(this.allowedModules)) {
            data["allowedModules"] = [];
            for (let item of this.allowedModules)
                data["allowedModules"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserRoleDetailDto {
        const json = this.toJSON();
        let result = new UserRoleDetailDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDetailDto {
    refId: number | undefined;
    roleId: number;
    roleName: string | undefined;
    roleKey: string | undefined;
    allowedModules: Module[] | undefined;
}

export class Module implements IModule {
    moduleId!: number;
    moduleName!: string | undefined;
    moduleKey!: string | undefined;
    menuTypeId!: number | undefined;
    menuUrl!: string | undefined;
    menuIcon!: string | undefined;
    menuSort!: number;
    allowedPermissions!: Permission[] | undefined;
    childModules!: Module[] | undefined;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.moduleKey = _data["moduleKey"];
            this.menuTypeId = _data["menuTypeId"];
            this.menuUrl = _data["menuUrl"];
            this.menuIcon = _data["menuIcon"];
            this.menuSort = _data["menuSort"];
            if (Array.isArray(_data["allowedPermissions"])) {
                this.allowedPermissions = [] as any;
                for (let item of _data["allowedPermissions"])
                    this.allowedPermissions!.push(Permission.fromJS(item));
            }
            if (Array.isArray(_data["childModules"])) {
                this.childModules = [] as any;
                for (let item of _data["childModules"])
                    this.childModules!.push(Module.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["moduleKey"] = this.moduleKey;
        data["menuTypeId"] = this.menuTypeId;
        data["menuUrl"] = this.menuUrl;
        data["menuIcon"] = this.menuIcon;
        data["menuSort"] = this.menuSort;
        if (Array.isArray(this.allowedPermissions)) {
            data["allowedPermissions"] = [];
            for (let item of this.allowedPermissions)
                data["allowedPermissions"].push(item.toJSON());
        }
        if (Array.isArray(this.childModules)) {
            data["childModules"] = [];
            for (let item of this.childModules)
                data["childModules"].push(item.toJSON());
        }
        return data;
    }

    clone(): Module {
        const json = this.toJSON();
        let result = new Module();
        result.init(json);
        return result;
    }
}

export interface IModule {
    moduleId: number;
    moduleName: string | undefined;
    moduleKey: string | undefined;
    menuTypeId: number | undefined;
    menuUrl: string | undefined;
    menuIcon: string | undefined;
    menuSort: number;
    allowedPermissions: Permission[] | undefined;
    childModules: Module[] | undefined;
}

export class Permission implements IPermission {
    permissionId!: number;
    permissionName!: string | undefined;
    permissionKey!: string | undefined;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionId = _data["permissionId"];
            this.permissionName = _data["permissionName"];
            this.permissionKey = _data["permissionKey"];
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionId"] = this.permissionId;
        data["permissionName"] = this.permissionName;
        data["permissionKey"] = this.permissionKey;
        return data;
    }

    clone(): Permission {
        const json = this.toJSON();
        let result = new Permission();
        result.init(json);
        return result;
    }
}

export interface IPermission {
    permissionId: number;
    permissionName: string | undefined;
    permissionKey: string | undefined;
}

export class ForgotPasswordRequestDto implements IForgotPasswordRequestDto {
    schoolCode!: string;
    username!: string;

    constructor(data?: IForgotPasswordRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolCode = _data["schoolCode"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolCode"] = this.schoolCode;
        data["username"] = this.username;
        return data;
    }

    clone(): ForgotPasswordRequestDto {
        const json = this.toJSON();
        let result = new ForgotPasswordRequestDto();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordRequestDto {
    schoolCode: string;
    username: string;
}

export class TransportPaymentAnalyticsDto implements ITransportPaymentAnalyticsDto {
    transportPaymentAnalyticsSchool!: TransportPaymentAnalyticsSchoolDto;
    transportPaymentAnalyticsGrade!: TransportPaymentAnalyticsGradeDto[];
    transportPaymentAnalyticsDivision!: TransportPaymentAnalyticsDivisionDto[];
    transportPaymentAnalyticsStudent!: TransportPaymentAnalyticsStudentDto[];
    transportPaymentAnalyticsStaffList!: TransportPaymentAnalyticsStaffListDto[];
    transportPaymentAnalyticsStaff!: TransportPaymentAnalyticsStaffDto;

    constructor(data?: ITransportPaymentAnalyticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transportPaymentAnalyticsSchool = _data["transportPaymentAnalyticsSchool"] ? TransportPaymentAnalyticsSchoolDto.fromJS(_data["transportPaymentAnalyticsSchool"]) : <any>undefined;
            if (Array.isArray(_data["transportPaymentAnalyticsGrade"])) {
                this.transportPaymentAnalyticsGrade = [] as any;
                for (let item of _data["transportPaymentAnalyticsGrade"])
                    this.transportPaymentAnalyticsGrade!.push(TransportPaymentAnalyticsGradeDto.fromJS(item));
            }
            if (Array.isArray(_data["transportPaymentAnalyticsDivision"])) {
                this.transportPaymentAnalyticsDivision = [] as any;
                for (let item of _data["transportPaymentAnalyticsDivision"])
                    this.transportPaymentAnalyticsDivision!.push(TransportPaymentAnalyticsDivisionDto.fromJS(item));
            }
            if (Array.isArray(_data["transportPaymentAnalyticsStudent"])) {
                this.transportPaymentAnalyticsStudent = [] as any;
                for (let item of _data["transportPaymentAnalyticsStudent"])
                    this.transportPaymentAnalyticsStudent!.push(TransportPaymentAnalyticsStudentDto.fromJS(item));
            }
            if (Array.isArray(_data["transportPaymentAnalyticsStaffList"])) {
                this.transportPaymentAnalyticsStaffList = [] as any;
                for (let item of _data["transportPaymentAnalyticsStaffList"])
                    this.transportPaymentAnalyticsStaffList!.push(TransportPaymentAnalyticsStaffListDto.fromJS(item));
            }
            this.transportPaymentAnalyticsStaff = _data["transportPaymentAnalyticsStaff"] ? TransportPaymentAnalyticsStaffDto.fromJS(_data["transportPaymentAnalyticsStaff"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transportPaymentAnalyticsSchool"] = this.transportPaymentAnalyticsSchool ? this.transportPaymentAnalyticsSchool.toJSON() : <any>undefined;
        if (Array.isArray(this.transportPaymentAnalyticsGrade)) {
            data["transportPaymentAnalyticsGrade"] = [];
            for (let item of this.transportPaymentAnalyticsGrade)
                data["transportPaymentAnalyticsGrade"].push(item.toJSON());
        }
        if (Array.isArray(this.transportPaymentAnalyticsDivision)) {
            data["transportPaymentAnalyticsDivision"] = [];
            for (let item of this.transportPaymentAnalyticsDivision)
                data["transportPaymentAnalyticsDivision"].push(item.toJSON());
        }
        if (Array.isArray(this.transportPaymentAnalyticsStudent)) {
            data["transportPaymentAnalyticsStudent"] = [];
            for (let item of this.transportPaymentAnalyticsStudent)
                data["transportPaymentAnalyticsStudent"].push(item.toJSON());
        }
        if (Array.isArray(this.transportPaymentAnalyticsStaffList)) {
            data["transportPaymentAnalyticsStaffList"] = [];
            for (let item of this.transportPaymentAnalyticsStaffList)
                data["transportPaymentAnalyticsStaffList"].push(item.toJSON());
        }
        data["transportPaymentAnalyticsStaff"] = this.transportPaymentAnalyticsStaff ? this.transportPaymentAnalyticsStaff.toJSON() : <any>undefined;
        return data;
    }

    clone(): TransportPaymentAnalyticsDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsDto {
    transportPaymentAnalyticsSchool: TransportPaymentAnalyticsSchoolDto;
    transportPaymentAnalyticsGrade: TransportPaymentAnalyticsGradeDto[];
    transportPaymentAnalyticsDivision: TransportPaymentAnalyticsDivisionDto[];
    transportPaymentAnalyticsStudent: TransportPaymentAnalyticsStudentDto[];
    transportPaymentAnalyticsStaffList: TransportPaymentAnalyticsStaffListDto[];
    transportPaymentAnalyticsStaff: TransportPaymentAnalyticsStaffDto;
}

export class TransportPaymentAnalyticsSchoolDto implements ITransportPaymentAnalyticsSchoolDto {
    studentId!: number;
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    schoolName!: string | undefined;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;

    constructor(data?: ITransportPaymentAnalyticsSchoolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.schoolName = _data["schoolName"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsSchoolDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsSchoolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["schoolName"] = this.schoolName;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        return data;
    }

    clone(): TransportPaymentAnalyticsSchoolDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsSchoolDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsSchoolDto {
    studentId: number;
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    schoolName: string | undefined;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
}

export class TransportPaymentAnalyticsGradeDto implements ITransportPaymentAnalyticsGradeDto {
    studentId!: number;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    gradeName!: string | undefined;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;

    constructor(data?: ITransportPaymentAnalyticsGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeName = _data["gradeName"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["gradeName"] = this.gradeName;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        return data;
    }

    clone(): TransportPaymentAnalyticsGradeDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsGradeDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsGradeDto {
    studentId: number;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    gradeName: string | undefined;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
}

export class TransportPaymentAnalyticsDivisionDto implements ITransportPaymentAnalyticsDivisionDto {
    studentId!: number;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    divisionName!: string | undefined;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;

    constructor(data?: ITransportPaymentAnalyticsDivisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.divisionName = _data["divisionName"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsDivisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsDivisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["divisionName"] = this.divisionName;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        return data;
    }

    clone(): TransportPaymentAnalyticsDivisionDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsDivisionDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsDivisionDto {
    studentId: number;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    divisionName: string | undefined;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
}

export class TransportPaymentAnalyticsStudentDto implements ITransportPaymentAnalyticsStudentDto {
    studentId!: number;
    studentName!: string;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;

    constructor(data?: ITransportPaymentAnalyticsStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        return data;
    }

    clone(): TransportPaymentAnalyticsStudentDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsStudentDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsStudentDto {
    studentId: number;
    studentName: string;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
}

export class TransportPaymentAnalyticsStaffListDto implements ITransportPaymentAnalyticsStaffListDto {
    consumerName!: string;
    academicYearId!: number;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;

    constructor(data?: ITransportPaymentAnalyticsStaffListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerName = _data["consumerName"];
            this.academicYearId = _data["academicYearId"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsStaffListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsStaffListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerName"] = this.consumerName;
        data["academicYearId"] = this.academicYearId;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        return data;
    }

    clone(): TransportPaymentAnalyticsStaffListDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsStaffListDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsStaffListDto {
    consumerName: string;
    academicYearId: number;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
}

export class TransportPaymentAnalyticsStaffDto implements ITransportPaymentAnalyticsStaffDto {
    schoolName!: string;
    academicYearId!: number;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;

    constructor(data?: ITransportPaymentAnalyticsStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.academicYearId = _data["academicYearId"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsStaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsStaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["academicYearId"] = this.academicYearId;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        return data;
    }

    clone(): TransportPaymentAnalyticsStaffDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsStaffDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsStaffDto {
    schoolName: string;
    academicYearId: number;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
}

export class AreaDto implements IAreaDto {
    areaId!: number;
    areaName!: string;
    pickPrice!: number;
    dropPrice!: number;
    pickAndDropPrice!: number;
    description!: string;
    academicYearId!: number;

    constructor(data?: IAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaId = _data["areaId"];
            this.areaName = _data["areaName"];
            this.pickPrice = _data["pickPrice"];
            this.dropPrice = _data["dropPrice"];
            this.pickAndDropPrice = _data["pickAndDropPrice"];
            this.description = _data["description"];
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): AreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaId"] = this.areaId;
        data["areaName"] = this.areaName;
        data["pickPrice"] = this.pickPrice;
        data["dropPrice"] = this.dropPrice;
        data["pickAndDropPrice"] = this.pickAndDropPrice;
        data["description"] = this.description;
        data["academicYearId"] = this.academicYearId;
        return data;
    }

    clone(): AreaDto {
        const json = this.toJSON();
        let result = new AreaDto();
        result.init(json);
        return result;
    }
}

export interface IAreaDto {
    areaId: number;
    areaName: string;
    pickPrice: number;
    dropPrice: number;
    pickAndDropPrice: number;
    description: string;
    academicYearId: number;
}

export class DatatableResponseModel implements IDatatableResponseModel {
    data!: any | undefined;
    draw!: number;
    recordsFiltered!: number;
    recordsTotal!: number;

    constructor(data?: IDatatableResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.draw = _data["draw"];
            this.recordsFiltered = _data["recordsFiltered"];
            this.recordsTotal = _data["recordsTotal"];
        }
    }

    static fromJS(data: any): DatatableResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new DatatableResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["draw"] = this.draw;
        data["recordsFiltered"] = this.recordsFiltered;
        data["recordsTotal"] = this.recordsTotal;
        return data;
    }

    clone(): DatatableResponseModel {
        const json = this.toJSON();
        let result = new DatatableResponseModel();
        result.init(json);
        return result;
    }
}

export interface IDatatableResponseModel {
    data: any | undefined;
    draw: number;
    recordsFiltered: number;
    recordsTotal: number;
}

export class DatatableRequestWrapper implements IDatatableRequestWrapper {
    getListModel!: DatatableRequestModel | undefined;
    academicYearId!: number | undefined;
    noticeTypeTo!: number | undefined;
    surveyTypeTo!: number | undefined;
    galleryTypeTo!: number | undefined;
    refId!: number | undefined;
    roleId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    subjectMasterId!: number | undefined;
    examMasterId!: number | undefined;
    classIds!: number[] | undefined;
    studentId!: number | undefined;
    studentEnquiryId!: number | undefined;
    consumerId!: number | undefined;
    transportConsumerStoppageMappingId!: number | undefined;
    fromDate!: moment.Moment | undefined;
    ngbfromDate!: SchoolNgbDateModel | undefined;
    tillDate!: moment.Moment | undefined;
    ngbtillDate!: SchoolNgbDateModel | undefined;
    takenOn!: moment.Moment | undefined;
    ngbtakenOn!: SchoolNgbDateModel | undefined;

    constructor(data?: IDatatableRequestWrapper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.getListModel = _data["getListModel"] ? DatatableRequestModel.fromJS(_data["getListModel"]) : <any>undefined;
            this.academicYearId = _data["academicYearId"];
            this.noticeTypeTo = _data["noticeTypeTo"];
            this.surveyTypeTo = _data["surveyTypeTo"];
            this.galleryTypeTo = _data["galleryTypeTo"];
            this.refId = _data["refId"];
            this.roleId = _data["roleId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.subjectMasterId = _data["subjectMasterId"];
            this.examMasterId = _data["examMasterId"];
            if (Array.isArray(_data["classIds"])) {
                this.classIds = [] as any;
                for (let item of _data["classIds"])
                    this.classIds!.push(item);
            }
            this.studentId = _data["studentId"];
            this.studentEnquiryId = _data["studentEnquiryId"];
            this.consumerId = _data["consumerId"];
            this.transportConsumerStoppageMappingId = _data["transportConsumerStoppageMappingId"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.ngbfromDate = _data["ngbfromDate"] ? SchoolNgbDateModel.fromJS(_data["ngbfromDate"]) : <any>undefined;
            this.tillDate = _data["tillDate"] ? moment(_data["tillDate"].toString()) : <any>undefined;
            this.ngbtillDate = _data["ngbtillDate"] ? SchoolNgbDateModel.fromJS(_data["ngbtillDate"]) : <any>undefined;
            this.takenOn = _data["takenOn"] ? moment(_data["takenOn"].toString()) : <any>undefined;
            this.ngbtakenOn = _data["ngbtakenOn"] ? SchoolNgbDateModel.fromJS(_data["ngbtakenOn"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DatatableRequestWrapper {
        data = typeof data === 'object' ? data : {};
        let result = new DatatableRequestWrapper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["getListModel"] = this.getListModel ? this.getListModel.toJSON() : <any>undefined;
        data["academicYearId"] = this.academicYearId;
        data["noticeTypeTo"] = this.noticeTypeTo;
        data["surveyTypeTo"] = this.surveyTypeTo;
        data["galleryTypeTo"] = this.galleryTypeTo;
        data["refId"] = this.refId;
        data["roleId"] = this.roleId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["subjectMasterId"] = this.subjectMasterId;
        data["examMasterId"] = this.examMasterId;
        if (Array.isArray(this.classIds)) {
            data["classIds"] = [];
            for (let item of this.classIds)
                data["classIds"].push(item);
        }
        data["studentId"] = this.studentId;
        data["studentEnquiryId"] = this.studentEnquiryId;
        data["consumerId"] = this.consumerId;
        data["transportConsumerStoppageMappingId"] = this.transportConsumerStoppageMappingId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["ngbfromDate"] = this.ngbfromDate ? this.ngbfromDate.toJSON() : <any>undefined;
        data["tillDate"] = this.tillDate ? this.tillDate.toISOString() : <any>undefined;
        data["ngbtillDate"] = this.ngbtillDate ? this.ngbtillDate.toJSON() : <any>undefined;
        data["takenOn"] = this.takenOn ? this.takenOn.toISOString() : <any>undefined;
        data["ngbtakenOn"] = this.ngbtakenOn ? this.ngbtakenOn.toJSON() : <any>undefined;
        return data;
    }

    clone(): DatatableRequestWrapper {
        const json = this.toJSON();
        let result = new DatatableRequestWrapper();
        result.init(json);
        return result;
    }
}

export interface IDatatableRequestWrapper {
    getListModel: DatatableRequestModel | undefined;
    academicYearId: number | undefined;
    noticeTypeTo: number | undefined;
    surveyTypeTo: number | undefined;
    galleryTypeTo: number | undefined;
    refId: number | undefined;
    roleId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    subjectMasterId: number | undefined;
    examMasterId: number | undefined;
    classIds: number[] | undefined;
    studentId: number | undefined;
    studentEnquiryId: number | undefined;
    consumerId: number | undefined;
    transportConsumerStoppageMappingId: number | undefined;
    fromDate: moment.Moment | undefined;
    ngbfromDate: SchoolNgbDateModel | undefined;
    tillDate: moment.Moment | undefined;
    ngbtillDate: SchoolNgbDateModel | undefined;
    takenOn: moment.Moment | undefined;
    ngbtakenOn: SchoolNgbDateModel | undefined;
}

export class DatatableRequestModel implements IDatatableRequestModel {
    draw!: number;
    columns!: Columns[] | undefined;
    order!: Order[] | undefined;
    start!: number;
    length!: number;
    search!: Search | undefined;

    constructor(data?: IDatatableRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(Columns.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order!.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.search = _data["search"] ? Search.fromJS(_data["search"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DatatableRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new DatatableRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        return data;
    }

    clone(): DatatableRequestModel {
        const json = this.toJSON();
        let result = new DatatableRequestModel();
        result.init(json);
        return result;
    }
}

export interface IDatatableRequestModel {
    draw: number;
    columns: Columns[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    search: Search | undefined;
}

export class Columns implements IColumns {
    data!: string | undefined;
    name!: string | undefined;
    searchable!: boolean;
    orderable!: boolean;
    search!: Search | undefined;

    constructor(data?: IColumns) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.name = _data["name"];
            this.searchable = _data["searchable"];
            this.orderable = _data["orderable"];
            this.search = _data["search"] ? Search.fromJS(_data["search"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Columns {
        data = typeof data === 'object' ? data : {};
        let result = new Columns();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["name"] = this.name;
        data["searchable"] = this.searchable;
        data["orderable"] = this.orderable;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        return data;
    }

    clone(): Columns {
        const json = this.toJSON();
        let result = new Columns();
        result.init(json);
        return result;
    }
}

export interface IColumns {
    data: string | undefined;
    name: string | undefined;
    searchable: boolean;
    orderable: boolean;
    search: Search | undefined;
}

export class Search implements ISearch {
    value!: string | undefined;
    regex!: boolean;

    constructor(data?: ISearch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.regex = _data["regex"];
        }
    }

    static fromJS(data: any): Search {
        data = typeof data === 'object' ? data : {};
        let result = new Search();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["regex"] = this.regex;
        return data;
    }

    clone(): Search {
        const json = this.toJSON();
        let result = new Search();
        result.init(json);
        return result;
    }
}

export interface ISearch {
    value: string | undefined;
    regex: boolean;
}

export class Order implements IOrder {
    column!: number;
    dir!: string | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.dir = _data["dir"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["dir"] = this.dir;
        return data;
    }

    clone(): Order {
        const json = this.toJSON();
        let result = new Order();
        result.init(json);
        return result;
    }
}

export interface IOrder {
    column: number;
    dir: string | undefined;
}

export class SchoolNgbDateModel implements ISchoolNgbDateModel {
    year!: number;
    month!: number;
    day!: number;

    constructor(data?: ISchoolNgbDateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.day = _data["day"];
        }
    }

    static fromJS(data: any): SchoolNgbDateModel {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolNgbDateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        return data;
    }

    clone(): SchoolNgbDateModel {
        const json = this.toJSON();
        let result = new SchoolNgbDateModel();
        result.init(json);
        return result;
    }
}

export interface ISchoolNgbDateModel {
    year: number;
    month: number;
    day: number;
}

export class AreaDeleteRespose implements IAreaDeleteRespose {
    affectedRows!: number;

    constructor(data?: IAreaDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): AreaDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): AreaDeleteRespose {
        const json = this.toJSON();
        let result = new AreaDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IAreaDeleteRespose {
    affectedRows: number;
}

export class RouteDto implements IRouteDto {
    routeId!: number;
    routeName!: string;
    firstPickUpTime!: moment.Moment | undefined;
    formattedFirstPickUpTime!: string;
    lastPickUpTime!: moment.Moment | undefined;
    formattedLastPickUpTime!: string;
    ngbFirstPickUpTime!: SchoolNgbTimeModel | undefined;
    ngbLastPickUpTime!: SchoolNgbTimeModel | undefined;
    coOrdinatorId!: string | undefined;
    coOrdinatorName!: string;
    coOrdinatorRoleId!: number;
    vehicleId!: number;
    isSharedVehicle!: boolean;
    sharedRouteId!: string;
    academicYearId!: number;
    vehicleNumber!: string;
    ragistrationNumber!: string;
    type!: string;
    totalSeats!: number;
    availableSeat!: number;

    constructor(data?: IRouteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeId = _data["routeId"];
            this.routeName = _data["routeName"];
            this.firstPickUpTime = _data["firstPickUpTime"] ? moment(_data["firstPickUpTime"].toString()) : <any>undefined;
            this.formattedFirstPickUpTime = _data["formattedFirstPickUpTime"];
            this.lastPickUpTime = _data["lastPickUpTime"] ? moment(_data["lastPickUpTime"].toString()) : <any>undefined;
            this.formattedLastPickUpTime = _data["formattedLastPickUpTime"];
            this.ngbFirstPickUpTime = _data["ngbFirstPickUpTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbFirstPickUpTime"]) : <any>undefined;
            this.ngbLastPickUpTime = _data["ngbLastPickUpTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbLastPickUpTime"]) : <any>undefined;
            this.coOrdinatorId = _data["coOrdinatorId"];
            this.coOrdinatorName = _data["coOrdinatorName"];
            this.coOrdinatorRoleId = _data["coOrdinatorRoleId"];
            this.vehicleId = _data["vehicleId"];
            this.isSharedVehicle = _data["isSharedVehicle"];
            this.sharedRouteId = _data["sharedRouteId"];
            this.academicYearId = _data["academicYearId"];
            this.vehicleNumber = _data["vehicleNumber"];
            this.ragistrationNumber = _data["ragistrationNumber"];
            this.type = _data["type"];
            this.totalSeats = _data["totalSeats"];
            this.availableSeat = _data["availableSeat"];
        }
    }

    static fromJS(data: any): RouteDto {
        data = typeof data === 'object' ? data : {};
        let result = new RouteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeId"] = this.routeId;
        data["routeName"] = this.routeName;
        data["firstPickUpTime"] = this.firstPickUpTime ? this.firstPickUpTime.toISOString() : <any>undefined;
        data["formattedFirstPickUpTime"] = this.formattedFirstPickUpTime;
        data["lastPickUpTime"] = this.lastPickUpTime ? this.lastPickUpTime.toISOString() : <any>undefined;
        data["formattedLastPickUpTime"] = this.formattedLastPickUpTime;
        data["ngbFirstPickUpTime"] = this.ngbFirstPickUpTime ? this.ngbFirstPickUpTime.toJSON() : <any>undefined;
        data["ngbLastPickUpTime"] = this.ngbLastPickUpTime ? this.ngbLastPickUpTime.toJSON() : <any>undefined;
        data["coOrdinatorId"] = this.coOrdinatorId;
        data["coOrdinatorName"] = this.coOrdinatorName;
        data["coOrdinatorRoleId"] = this.coOrdinatorRoleId;
        data["vehicleId"] = this.vehicleId;
        data["isSharedVehicle"] = this.isSharedVehicle;
        data["sharedRouteId"] = this.sharedRouteId;
        data["academicYearId"] = this.academicYearId;
        data["vehicleNumber"] = this.vehicleNumber;
        data["ragistrationNumber"] = this.ragistrationNumber;
        data["type"] = this.type;
        data["totalSeats"] = this.totalSeats;
        data["availableSeat"] = this.availableSeat;
        return data;
    }

    clone(): RouteDto {
        const json = this.toJSON();
        let result = new RouteDto();
        result.init(json);
        return result;
    }
}

export interface IRouteDto {
    routeId: number;
    routeName: string;
    firstPickUpTime: moment.Moment | undefined;
    formattedFirstPickUpTime: string;
    lastPickUpTime: moment.Moment | undefined;
    formattedLastPickUpTime: string;
    ngbFirstPickUpTime: SchoolNgbTimeModel | undefined;
    ngbLastPickUpTime: SchoolNgbTimeModel | undefined;
    coOrdinatorId: string | undefined;
    coOrdinatorName: string;
    coOrdinatorRoleId: number;
    vehicleId: number;
    isSharedVehicle: boolean;
    sharedRouteId: string;
    academicYearId: number;
    vehicleNumber: string;
    ragistrationNumber: string;
    type: string;
    totalSeats: number;
    availableSeat: number;
}

export class SchoolNgbTimeModel implements ISchoolNgbTimeModel {
    hour!: number;
    minute!: number;
    second!: number;

    constructor(data?: ISchoolNgbTimeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hour = _data["hour"];
            this.minute = _data["minute"];
            this.second = _data["second"];
        }
    }

    static fromJS(data: any): SchoolNgbTimeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolNgbTimeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["second"] = this.second;
        return data;
    }

    clone(): SchoolNgbTimeModel {
        const json = this.toJSON();
        let result = new SchoolNgbTimeModel();
        result.init(json);
        return result;
    }
}

export interface ISchoolNgbTimeModel {
    hour: number;
    minute: number;
    second: number;
}

export class RouteListResponse implements IRouteListResponse {
    routeList!: RouteDto[] | undefined;

    constructor(data?: IRouteListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routeList"])) {
                this.routeList = [] as any;
                for (let item of _data["routeList"])
                    this.routeList!.push(RouteDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RouteListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RouteListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routeList)) {
            data["routeList"] = [];
            for (let item of this.routeList)
                data["routeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): RouteListResponse {
        const json = this.toJSON();
        let result = new RouteListResponse();
        result.init(json);
        return result;
    }
}

export interface IRouteListResponse {
    routeList: RouteDto[] | undefined;
}

export class RouteGridInputRequestDto implements IRouteGridInputRequestDto {
    academicYearId!: number;
    consumerName!: string;

    constructor(data?: IRouteGridInputRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.consumerName = _data["consumerName"];
        }
    }

    static fromJS(data: any): RouteGridInputRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RouteGridInputRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["consumerName"] = this.consumerName;
        return data;
    }

    clone(): RouteGridInputRequestDto {
        const json = this.toJSON();
        let result = new RouteGridInputRequestDto();
        result.init(json);
        return result;
    }
}

export interface IRouteGridInputRequestDto {
    academicYearId: number;
    consumerName: string;
}

export class RouteDeleteRespose implements IRouteDeleteRespose {
    affectedRows!: number;

    constructor(data?: IRouteDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): RouteDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new RouteDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): RouteDeleteRespose {
        const json = this.toJSON();
        let result = new RouteDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IRouteDeleteRespose {
    affectedRows: number;
}

export class StoppageDto implements IStoppageDto {
    stoppageId!: number;
    orderNo!: number;
    stoppageName!: string;
    areaName!: string;
    areaId!: number;
    pickPrice!: number;
    dropPrice!: number;
    pickAndDropPrice!: number;
    pickUpTime!: moment.Moment | undefined;
    formattedPickUpTime!: string;
    ngbPickUpTime!: SchoolNgbTimeModel | undefined;
    ngbDropPickUpTime!: SchoolNgbTimeModel | undefined;
    dropPickUpTime!: moment.Moment | undefined;
    formattedDropPickUpTime!: string;
    kiloMeter!: string;
    academicYearId!: number;
    stopLat!: string;
    stopLng!: string;

    constructor(data?: IStoppageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stoppageId = _data["stoppageId"];
            this.orderNo = _data["orderNo"];
            this.stoppageName = _data["stoppageName"];
            this.areaName = _data["areaName"];
            this.areaId = _data["areaId"];
            this.pickPrice = _data["pickPrice"];
            this.dropPrice = _data["dropPrice"];
            this.pickAndDropPrice = _data["pickAndDropPrice"];
            this.pickUpTime = _data["pickUpTime"] ? moment(_data["pickUpTime"].toString()) : <any>undefined;
            this.formattedPickUpTime = _data["formattedPickUpTime"];
            this.ngbPickUpTime = _data["ngbPickUpTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbPickUpTime"]) : <any>undefined;
            this.ngbDropPickUpTime = _data["ngbDropPickUpTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbDropPickUpTime"]) : <any>undefined;
            this.dropPickUpTime = _data["dropPickUpTime"] ? moment(_data["dropPickUpTime"].toString()) : <any>undefined;
            this.formattedDropPickUpTime = _data["formattedDropPickUpTime"];
            this.kiloMeter = _data["kiloMeter"];
            this.academicYearId = _data["academicYearId"];
            this.stopLat = _data["stopLat"];
            this.stopLng = _data["stopLng"];
        }
    }

    static fromJS(data: any): StoppageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoppageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stoppageId"] = this.stoppageId;
        data["orderNo"] = this.orderNo;
        data["stoppageName"] = this.stoppageName;
        data["areaName"] = this.areaName;
        data["areaId"] = this.areaId;
        data["pickPrice"] = this.pickPrice;
        data["dropPrice"] = this.dropPrice;
        data["pickAndDropPrice"] = this.pickAndDropPrice;
        data["pickUpTime"] = this.pickUpTime ? this.pickUpTime.toISOString() : <any>undefined;
        data["formattedPickUpTime"] = this.formattedPickUpTime;
        data["ngbPickUpTime"] = this.ngbPickUpTime ? this.ngbPickUpTime.toJSON() : <any>undefined;
        data["ngbDropPickUpTime"] = this.ngbDropPickUpTime ? this.ngbDropPickUpTime.toJSON() : <any>undefined;
        data["dropPickUpTime"] = this.dropPickUpTime ? this.dropPickUpTime.toISOString() : <any>undefined;
        data["formattedDropPickUpTime"] = this.formattedDropPickUpTime;
        data["kiloMeter"] = this.kiloMeter;
        data["academicYearId"] = this.academicYearId;
        data["stopLat"] = this.stopLat;
        data["stopLng"] = this.stopLng;
        return data;
    }

    clone(): StoppageDto {
        const json = this.toJSON();
        let result = new StoppageDto();
        result.init(json);
        return result;
    }
}

export interface IStoppageDto {
    stoppageId: number;
    orderNo: number;
    stoppageName: string;
    areaName: string;
    areaId: number;
    pickPrice: number;
    dropPrice: number;
    pickAndDropPrice: number;
    pickUpTime: moment.Moment | undefined;
    formattedPickUpTime: string;
    ngbPickUpTime: SchoolNgbTimeModel | undefined;
    ngbDropPickUpTime: SchoolNgbTimeModel | undefined;
    dropPickUpTime: moment.Moment | undefined;
    formattedDropPickUpTime: string;
    kiloMeter: string;
    academicYearId: number;
    stopLat: string;
    stopLng: string;
}

export class StoppageListResponse implements IStoppageListResponse {
    stoppageList!: StoppageDto[] | undefined;

    constructor(data?: IStoppageListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stoppageList"])) {
                this.stoppageList = [] as any;
                for (let item of _data["stoppageList"])
                    this.stoppageList!.push(StoppageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoppageListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StoppageListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stoppageList)) {
            data["stoppageList"] = [];
            for (let item of this.stoppageList)
                data["stoppageList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StoppageListResponse {
        const json = this.toJSON();
        let result = new StoppageListResponse();
        result.init(json);
        return result;
    }
}

export interface IStoppageListResponse {
    stoppageList: StoppageDto[] | undefined;
}

export class StoppageGridInputDto implements IStoppageGridInputDto {
    academicYearId!: number;
    routeId!: number;
    consumerName!: string;

    constructor(data?: IStoppageGridInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.routeId = _data["routeId"];
            this.consumerName = _data["consumerName"];
        }
    }

    static fromJS(data: any): StoppageGridInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoppageGridInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["routeId"] = this.routeId;
        data["consumerName"] = this.consumerName;
        return data;
    }

    clone(): StoppageGridInputDto {
        const json = this.toJSON();
        let result = new StoppageGridInputDto();
        result.init(json);
        return result;
    }
}

export interface IStoppageGridInputDto {
    academicYearId: number;
    routeId: number;
    consumerName: string;
}

export class StoppageDeleteRespose implements IStoppageDeleteRespose {
    affectedRows!: number;

    constructor(data?: IStoppageDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): StoppageDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new StoppageDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): StoppageDeleteRespose {
        const json = this.toJSON();
        let result = new StoppageDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IStoppageDeleteRespose {
    affectedRows: number;
}

export class VehicleDto implements IVehicleDto {
    vehicleId!: number | undefined;
    academicYearId!: number | undefined;
    vehicleNumber!: string;
    totalSeats!: number | undefined;
    ragistrationNumber!: string;
    chassisNumber!: string;
    ownerName!: string;
    financerName!: string;
    enginNumber!: string;
    companyName!: string;
    tankCapacity!: string;
    model!: string;
    type!: string;
    fuelType!: string;
    cabDriverName!: string;
    cabDriverId!: number | undefined;
    conductor!: string;
    deviceId!: string;
    providerName!: string;
    isActive!: boolean;
    status!: string;
    vehicleDetailId!: number | undefined;
    vehicleRegistrationStartDate!: moment.Moment | undefined;
    ngbVehicleRegistrationStartDate!: SchoolNgbDateModel | undefined;
    vehicleRegistrationEndDate!: moment.Moment | undefined;
    ngbVehicleRegistrationEndDate!: SchoolNgbDateModel | undefined;
    vehiclePermitStartDate!: moment.Moment | undefined;
    ngbVehiclePermitStartDate!: SchoolNgbDateModel | undefined;
    vehiclePermitEndDate!: moment.Moment | undefined;
    ngbVehiclePermitEndDate!: SchoolNgbDateModel | undefined;
    vehicleInsuranceStartDate!: moment.Moment | undefined;
    ngbVehicleInsuranceStartDate!: SchoolNgbDateModel | undefined;
    vehicleInsuranceEndDate!: moment.Moment | undefined;
    ngbVehicleInsuranceEndDate!: SchoolNgbDateModel | undefined;
    vehiclePollutionStartDate!: moment.Moment | undefined;
    ngbVehiclePollutionStartDate!: SchoolNgbDateModel | undefined;
    vehiclePollutionEndDate!: moment.Moment | undefined;
    ngbVehiclePollutionEndDate!: SchoolNgbDateModel | undefined;
    vehicleRoadTaxStartDate!: moment.Moment | undefined;
    ngbVehicleRoadTaxStartDate!: SchoolNgbDateModel | undefined;
    vehicleRoadTaxEndDate!: moment.Moment | undefined;
    ngbVehicleRoadTaxEndDate!: SchoolNgbDateModel | undefined;
    vehicleFitnessStartDate!: moment.Moment | undefined;
    ngbVehicleFitnessStartDate!: SchoolNgbDateModel | undefined;
    vehicleFitnessEndDate!: moment.Moment | undefined;
    ngbVehicleFitnessEndDate!: SchoolNgbDateModel | undefined;
    description!: string | undefined;
    userId!: number;

    constructor(data?: IVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"];
            this.academicYearId = _data["academicYearId"];
            this.vehicleNumber = _data["vehicleNumber"];
            this.totalSeats = _data["totalSeats"];
            this.ragistrationNumber = _data["ragistrationNumber"];
            this.chassisNumber = _data["chassisNumber"];
            this.ownerName = _data["ownerName"];
            this.financerName = _data["financerName"];
            this.enginNumber = _data["enginNumber"];
            this.companyName = _data["companyName"];
            this.tankCapacity = _data["tankCapacity"];
            this.model = _data["model"];
            this.type = _data["type"];
            this.fuelType = _data["fuelType"];
            this.cabDriverName = _data["cabDriverName"];
            this.cabDriverId = _data["cabDriverId"];
            this.conductor = _data["conductor"];
            this.deviceId = _data["deviceId"];
            this.providerName = _data["providerName"];
            this.isActive = _data["isActive"];
            this.status = _data["status"];
            this.vehicleDetailId = _data["vehicleDetailId"];
            this.vehicleRegistrationStartDate = _data["vehicleRegistrationStartDate"] ? moment(_data["vehicleRegistrationStartDate"].toString()) : <any>undefined;
            this.ngbVehicleRegistrationStartDate = _data["ngbVehicleRegistrationStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehicleRegistrationStartDate"]) : <any>undefined;
            this.vehicleRegistrationEndDate = _data["vehicleRegistrationEndDate"] ? moment(_data["vehicleRegistrationEndDate"].toString()) : <any>undefined;
            this.ngbVehicleRegistrationEndDate = _data["ngbVehicleRegistrationEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehicleRegistrationEndDate"]) : <any>undefined;
            this.vehiclePermitStartDate = _data["vehiclePermitStartDate"] ? moment(_data["vehiclePermitStartDate"].toString()) : <any>undefined;
            this.ngbVehiclePermitStartDate = _data["ngbVehiclePermitStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehiclePermitStartDate"]) : <any>undefined;
            this.vehiclePermitEndDate = _data["vehiclePermitEndDate"] ? moment(_data["vehiclePermitEndDate"].toString()) : <any>undefined;
            this.ngbVehiclePermitEndDate = _data["ngbVehiclePermitEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehiclePermitEndDate"]) : <any>undefined;
            this.vehicleInsuranceStartDate = _data["vehicleInsuranceStartDate"] ? moment(_data["vehicleInsuranceStartDate"].toString()) : <any>undefined;
            this.ngbVehicleInsuranceStartDate = _data["ngbVehicleInsuranceStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehicleInsuranceStartDate"]) : <any>undefined;
            this.vehicleInsuranceEndDate = _data["vehicleInsuranceEndDate"] ? moment(_data["vehicleInsuranceEndDate"].toString()) : <any>undefined;
            this.ngbVehicleInsuranceEndDate = _data["ngbVehicleInsuranceEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehicleInsuranceEndDate"]) : <any>undefined;
            this.vehiclePollutionStartDate = _data["vehiclePollutionStartDate"] ? moment(_data["vehiclePollutionStartDate"].toString()) : <any>undefined;
            this.ngbVehiclePollutionStartDate = _data["ngbVehiclePollutionStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehiclePollutionStartDate"]) : <any>undefined;
            this.vehiclePollutionEndDate = _data["vehiclePollutionEndDate"] ? moment(_data["vehiclePollutionEndDate"].toString()) : <any>undefined;
            this.ngbVehiclePollutionEndDate = _data["ngbVehiclePollutionEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehiclePollutionEndDate"]) : <any>undefined;
            this.vehicleRoadTaxStartDate = _data["vehicleRoadTaxStartDate"] ? moment(_data["vehicleRoadTaxStartDate"].toString()) : <any>undefined;
            this.ngbVehicleRoadTaxStartDate = _data["ngbVehicleRoadTaxStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehicleRoadTaxStartDate"]) : <any>undefined;
            this.vehicleRoadTaxEndDate = _data["vehicleRoadTaxEndDate"] ? moment(_data["vehicleRoadTaxEndDate"].toString()) : <any>undefined;
            this.ngbVehicleRoadTaxEndDate = _data["ngbVehicleRoadTaxEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehicleRoadTaxEndDate"]) : <any>undefined;
            this.vehicleFitnessStartDate = _data["vehicleFitnessStartDate"] ? moment(_data["vehicleFitnessStartDate"].toString()) : <any>undefined;
            this.ngbVehicleFitnessStartDate = _data["ngbVehicleFitnessStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehicleFitnessStartDate"]) : <any>undefined;
            this.vehicleFitnessEndDate = _data["vehicleFitnessEndDate"] ? moment(_data["vehicleFitnessEndDate"].toString()) : <any>undefined;
            this.ngbVehicleFitnessEndDate = _data["ngbVehicleFitnessEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVehicleFitnessEndDate"]) : <any>undefined;
            this.description = _data["description"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): VehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId;
        data["academicYearId"] = this.academicYearId;
        data["vehicleNumber"] = this.vehicleNumber;
        data["totalSeats"] = this.totalSeats;
        data["ragistrationNumber"] = this.ragistrationNumber;
        data["chassisNumber"] = this.chassisNumber;
        data["ownerName"] = this.ownerName;
        data["financerName"] = this.financerName;
        data["enginNumber"] = this.enginNumber;
        data["companyName"] = this.companyName;
        data["tankCapacity"] = this.tankCapacity;
        data["model"] = this.model;
        data["type"] = this.type;
        data["fuelType"] = this.fuelType;
        data["cabDriverName"] = this.cabDriverName;
        data["cabDriverId"] = this.cabDriverId;
        data["conductor"] = this.conductor;
        data["deviceId"] = this.deviceId;
        data["providerName"] = this.providerName;
        data["isActive"] = this.isActive;
        data["status"] = this.status;
        data["vehicleDetailId"] = this.vehicleDetailId;
        data["vehicleRegistrationStartDate"] = this.vehicleRegistrationStartDate ? this.vehicleRegistrationStartDate.toISOString() : <any>undefined;
        data["ngbVehicleRegistrationStartDate"] = this.ngbVehicleRegistrationStartDate ? this.ngbVehicleRegistrationStartDate.toJSON() : <any>undefined;
        data["vehicleRegistrationEndDate"] = this.vehicleRegistrationEndDate ? this.vehicleRegistrationEndDate.toISOString() : <any>undefined;
        data["ngbVehicleRegistrationEndDate"] = this.ngbVehicleRegistrationEndDate ? this.ngbVehicleRegistrationEndDate.toJSON() : <any>undefined;
        data["vehiclePermitStartDate"] = this.vehiclePermitStartDate ? this.vehiclePermitStartDate.toISOString() : <any>undefined;
        data["ngbVehiclePermitStartDate"] = this.ngbVehiclePermitStartDate ? this.ngbVehiclePermitStartDate.toJSON() : <any>undefined;
        data["vehiclePermitEndDate"] = this.vehiclePermitEndDate ? this.vehiclePermitEndDate.toISOString() : <any>undefined;
        data["ngbVehiclePermitEndDate"] = this.ngbVehiclePermitEndDate ? this.ngbVehiclePermitEndDate.toJSON() : <any>undefined;
        data["vehicleInsuranceStartDate"] = this.vehicleInsuranceStartDate ? this.vehicleInsuranceStartDate.toISOString() : <any>undefined;
        data["ngbVehicleInsuranceStartDate"] = this.ngbVehicleInsuranceStartDate ? this.ngbVehicleInsuranceStartDate.toJSON() : <any>undefined;
        data["vehicleInsuranceEndDate"] = this.vehicleInsuranceEndDate ? this.vehicleInsuranceEndDate.toISOString() : <any>undefined;
        data["ngbVehicleInsuranceEndDate"] = this.ngbVehicleInsuranceEndDate ? this.ngbVehicleInsuranceEndDate.toJSON() : <any>undefined;
        data["vehiclePollutionStartDate"] = this.vehiclePollutionStartDate ? this.vehiclePollutionStartDate.toISOString() : <any>undefined;
        data["ngbVehiclePollutionStartDate"] = this.ngbVehiclePollutionStartDate ? this.ngbVehiclePollutionStartDate.toJSON() : <any>undefined;
        data["vehiclePollutionEndDate"] = this.vehiclePollutionEndDate ? this.vehiclePollutionEndDate.toISOString() : <any>undefined;
        data["ngbVehiclePollutionEndDate"] = this.ngbVehiclePollutionEndDate ? this.ngbVehiclePollutionEndDate.toJSON() : <any>undefined;
        data["vehicleRoadTaxStartDate"] = this.vehicleRoadTaxStartDate ? this.vehicleRoadTaxStartDate.toISOString() : <any>undefined;
        data["ngbVehicleRoadTaxStartDate"] = this.ngbVehicleRoadTaxStartDate ? this.ngbVehicleRoadTaxStartDate.toJSON() : <any>undefined;
        data["vehicleRoadTaxEndDate"] = this.vehicleRoadTaxEndDate ? this.vehicleRoadTaxEndDate.toISOString() : <any>undefined;
        data["ngbVehicleRoadTaxEndDate"] = this.ngbVehicleRoadTaxEndDate ? this.ngbVehicleRoadTaxEndDate.toJSON() : <any>undefined;
        data["vehicleFitnessStartDate"] = this.vehicleFitnessStartDate ? this.vehicleFitnessStartDate.toISOString() : <any>undefined;
        data["ngbVehicleFitnessStartDate"] = this.ngbVehicleFitnessStartDate ? this.ngbVehicleFitnessStartDate.toJSON() : <any>undefined;
        data["vehicleFitnessEndDate"] = this.vehicleFitnessEndDate ? this.vehicleFitnessEndDate.toISOString() : <any>undefined;
        data["ngbVehicleFitnessEndDate"] = this.ngbVehicleFitnessEndDate ? this.ngbVehicleFitnessEndDate.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["userId"] = this.userId;
        return data;
    }

    clone(): VehicleDto {
        const json = this.toJSON();
        let result = new VehicleDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleDto {
    vehicleId: number | undefined;
    academicYearId: number | undefined;
    vehicleNumber: string;
    totalSeats: number | undefined;
    ragistrationNumber: string;
    chassisNumber: string;
    ownerName: string;
    financerName: string;
    enginNumber: string;
    companyName: string;
    tankCapacity: string;
    model: string;
    type: string;
    fuelType: string;
    cabDriverName: string;
    cabDriverId: number | undefined;
    conductor: string;
    deviceId: string;
    providerName: string;
    isActive: boolean;
    status: string;
    vehicleDetailId: number | undefined;
    vehicleRegistrationStartDate: moment.Moment | undefined;
    ngbVehicleRegistrationStartDate: SchoolNgbDateModel | undefined;
    vehicleRegistrationEndDate: moment.Moment | undefined;
    ngbVehicleRegistrationEndDate: SchoolNgbDateModel | undefined;
    vehiclePermitStartDate: moment.Moment | undefined;
    ngbVehiclePermitStartDate: SchoolNgbDateModel | undefined;
    vehiclePermitEndDate: moment.Moment | undefined;
    ngbVehiclePermitEndDate: SchoolNgbDateModel | undefined;
    vehicleInsuranceStartDate: moment.Moment | undefined;
    ngbVehicleInsuranceStartDate: SchoolNgbDateModel | undefined;
    vehicleInsuranceEndDate: moment.Moment | undefined;
    ngbVehicleInsuranceEndDate: SchoolNgbDateModel | undefined;
    vehiclePollutionStartDate: moment.Moment | undefined;
    ngbVehiclePollutionStartDate: SchoolNgbDateModel | undefined;
    vehiclePollutionEndDate: moment.Moment | undefined;
    ngbVehiclePollutionEndDate: SchoolNgbDateModel | undefined;
    vehicleRoadTaxStartDate: moment.Moment | undefined;
    ngbVehicleRoadTaxStartDate: SchoolNgbDateModel | undefined;
    vehicleRoadTaxEndDate: moment.Moment | undefined;
    ngbVehicleRoadTaxEndDate: SchoolNgbDateModel | undefined;
    vehicleFitnessStartDate: moment.Moment | undefined;
    ngbVehicleFitnessStartDate: SchoolNgbDateModel | undefined;
    vehicleFitnessEndDate: moment.Moment | undefined;
    ngbVehicleFitnessEndDate: SchoolNgbDateModel | undefined;
    description: string | undefined;
    userId: number;
}

export class ActiceInActiveVehicleDto implements IActiceInActiveVehicleDto {
    vehicleId!: number | undefined;
    isActive!: boolean;

    constructor(data?: IActiceInActiveVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActiceInActiveVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiceInActiveVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ActiceInActiveVehicleDto {
        const json = this.toJSON();
        let result = new ActiceInActiveVehicleDto();
        result.init(json);
        return result;
    }
}

export interface IActiceInActiveVehicleDto {
    vehicleId: number | undefined;
    isActive: boolean;
}

export class VehicleDeleteResposeDto implements IVehicleDeleteResposeDto {
    affectedRows!: number;
    vehicleCount!: number;

    constructor(data?: IVehicleDeleteResposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
            this.vehicleCount = _data["vehicleCount"];
        }
    }

    static fromJS(data: any): VehicleDeleteResposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDeleteResposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        data["vehicleCount"] = this.vehicleCount;
        return data;
    }

    clone(): VehicleDeleteResposeDto {
        const json = this.toJSON();
        let result = new VehicleDeleteResposeDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleDeleteResposeDto {
    affectedRows: number;
    vehicleCount: number;
}

export class DropdownResponseDto implements IDropdownResponseDto {
    cabDriverDropdownList!: CabDriverDropDownReasponseDto[];
    areaNameDropdownList!: AreaNameDropDownReasponseDto[];
    vehicleDropdownList!: VehicleDropDownReasponseDto[];

    constructor(data?: IDropdownResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cabDriverDropdownList"])) {
                this.cabDriverDropdownList = [] as any;
                for (let item of _data["cabDriverDropdownList"])
                    this.cabDriverDropdownList!.push(CabDriverDropDownReasponseDto.fromJS(item));
            }
            if (Array.isArray(_data["areaNameDropdownList"])) {
                this.areaNameDropdownList = [] as any;
                for (let item of _data["areaNameDropdownList"])
                    this.areaNameDropdownList!.push(AreaNameDropDownReasponseDto.fromJS(item));
            }
            if (Array.isArray(_data["vehicleDropdownList"])) {
                this.vehicleDropdownList = [] as any;
                for (let item of _data["vehicleDropdownList"])
                    this.vehicleDropdownList!.push(VehicleDropDownReasponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DropdownResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cabDriverDropdownList)) {
            data["cabDriverDropdownList"] = [];
            for (let item of this.cabDriverDropdownList)
                data["cabDriverDropdownList"].push(item.toJSON());
        }
        if (Array.isArray(this.areaNameDropdownList)) {
            data["areaNameDropdownList"] = [];
            for (let item of this.areaNameDropdownList)
                data["areaNameDropdownList"].push(item.toJSON());
        }
        if (Array.isArray(this.vehicleDropdownList)) {
            data["vehicleDropdownList"] = [];
            for (let item of this.vehicleDropdownList)
                data["vehicleDropdownList"].push(item.toJSON());
        }
        return data;
    }

    clone(): DropdownResponseDto {
        const json = this.toJSON();
        let result = new DropdownResponseDto();
        result.init(json);
        return result;
    }
}

export interface IDropdownResponseDto {
    cabDriverDropdownList: CabDriverDropDownReasponseDto[];
    areaNameDropdownList: AreaNameDropDownReasponseDto[];
    vehicleDropdownList: VehicleDropDownReasponseDto[];
}

export class CabDriverDropDownReasponseDto implements ICabDriverDropDownReasponseDto {
    cabDriverId!: number;
    cabDriverName!: string;

    constructor(data?: ICabDriverDropDownReasponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cabDriverId = _data["cabDriverId"];
            this.cabDriverName = _data["cabDriverName"];
        }
    }

    static fromJS(data: any): CabDriverDropDownReasponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverDropDownReasponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cabDriverId"] = this.cabDriverId;
        data["cabDriverName"] = this.cabDriverName;
        return data;
    }

    clone(): CabDriverDropDownReasponseDto {
        const json = this.toJSON();
        let result = new CabDriverDropDownReasponseDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverDropDownReasponseDto {
    cabDriverId: number;
    cabDriverName: string;
}

export class AreaNameDropDownReasponseDto implements IAreaNameDropDownReasponseDto {
    areaId!: number;
    areaName!: string;

    constructor(data?: IAreaNameDropDownReasponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaId = _data["areaId"];
            this.areaName = _data["areaName"];
        }
    }

    static fromJS(data: any): AreaNameDropDownReasponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaNameDropDownReasponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaId"] = this.areaId;
        data["areaName"] = this.areaName;
        return data;
    }

    clone(): AreaNameDropDownReasponseDto {
        const json = this.toJSON();
        let result = new AreaNameDropDownReasponseDto();
        result.init(json);
        return result;
    }
}

export interface IAreaNameDropDownReasponseDto {
    areaId: number;
    areaName: string;
}

export class VehicleDropDownReasponseDto implements IVehicleDropDownReasponseDto {
    vehicleId!: number;
    vehicleNumber!: string;
    ragistrationNumber!: string;

    constructor(data?: IVehicleDropDownReasponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"];
            this.vehicleNumber = _data["vehicleNumber"];
            this.ragistrationNumber = _data["ragistrationNumber"];
        }
    }

    static fromJS(data: any): VehicleDropDownReasponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDropDownReasponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId;
        data["vehicleNumber"] = this.vehicleNumber;
        data["ragistrationNumber"] = this.ragistrationNumber;
        return data;
    }

    clone(): VehicleDropDownReasponseDto {
        const json = this.toJSON();
        let result = new VehicleDropDownReasponseDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleDropDownReasponseDto {
    vehicleId: number;
    vehicleNumber: string;
    ragistrationNumber: string;
}

export class TransportStaffResponseDto implements ITransportStaffResponseDto {
    transportStaffList!: TransportStaffDto[];

    constructor(data?: ITransportStaffResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["transportStaffList"])) {
                this.transportStaffList = [] as any;
                for (let item of _data["transportStaffList"])
                    this.transportStaffList!.push(TransportStaffDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportStaffResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportStaffResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transportStaffList)) {
            data["transportStaffList"] = [];
            for (let item of this.transportStaffList)
                data["transportStaffList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportStaffResponseDto {
        const json = this.toJSON();
        let result = new TransportStaffResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITransportStaffResponseDto {
    transportStaffList: TransportStaffDto[];
}

export class TransportStaffDto implements ITransportStaffDto {
    staffId!: string;
    staffName!: string;

    constructor(data?: ITransportStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.staffName = _data["staffName"];
        }
    }

    static fromJS(data: any): TransportStaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportStaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["staffName"] = this.staffName;
        return data;
    }

    clone(): TransportStaffDto {
        const json = this.toJSON();
        let result = new TransportStaffDto();
        result.init(json);
        return result;
    }
}

export interface ITransportStaffDto {
    staffId: string;
    staffName: string;
}

export class SchoolTreeviewItemResponseDto implements ISchoolTreeviewItemResponseDto {
    lstConsumerTreeviewItem!: SchoolTreeviewItem[];

    constructor(data?: ISchoolTreeviewItemResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstConsumerTreeviewItem"])) {
                this.lstConsumerTreeviewItem = [] as any;
                for (let item of _data["lstConsumerTreeviewItem"])
                    this.lstConsumerTreeviewItem!.push(SchoolTreeviewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolTreeviewItemResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolTreeviewItemResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstConsumerTreeviewItem)) {
            data["lstConsumerTreeviewItem"] = [];
            for (let item of this.lstConsumerTreeviewItem)
                data["lstConsumerTreeviewItem"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolTreeviewItemResponseDto {
        const json = this.toJSON();
        let result = new SchoolTreeviewItemResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolTreeviewItemResponseDto {
    lstConsumerTreeviewItem: SchoolTreeviewItem[];
}

export class SchoolTreeviewItem implements ISchoolTreeviewItem {
    text!: string;
    value!: number;
    checked!: boolean;
    collapsed!: boolean;
    isFeeApplicableToStaff!: boolean;
    children!: SchoolTreeviewItem[] | undefined;

    constructor(data?: ISchoolTreeviewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.value = _data["value"];
            this.checked = _data["checked"];
            this.collapsed = _data["collapsed"];
            this.isFeeApplicableToStaff = _data["isFeeApplicableToStaff"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(SchoolTreeviewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolTreeviewItem {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolTreeviewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["value"] = this.value;
        data["checked"] = this.checked;
        data["collapsed"] = this.collapsed;
        data["isFeeApplicableToStaff"] = this.isFeeApplicableToStaff;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolTreeviewItem {
        const json = this.toJSON();
        let result = new SchoolTreeviewItem();
        result.init(json);
        return result;
    }
}

export interface ISchoolTreeviewItem {
    text: string;
    value: number;
    checked: boolean;
    collapsed: boolean;
    isFeeApplicableToStaff: boolean;
    children: SchoolTreeviewItem[] | undefined;
}

export class StoppageConsumerTreeviewRequestDto implements IStoppageConsumerTreeviewRequestDto {
    stoppageId!: number;
    academicYearId!: number;
    roleId!: number;

    constructor(data?: IStoppageConsumerTreeviewRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stoppageId = _data["stoppageId"];
            this.academicYearId = _data["academicYearId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): StoppageConsumerTreeviewRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoppageConsumerTreeviewRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stoppageId"] = this.stoppageId;
        data["academicYearId"] = this.academicYearId;
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): StoppageConsumerTreeviewRequestDto {
        const json = this.toJSON();
        let result = new StoppageConsumerTreeviewRequestDto();
        result.init(json);
        return result;
    }
}

export interface IStoppageConsumerTreeviewRequestDto {
    stoppageId: number;
    academicYearId: number;
    roleId: number;
}

export class CreateTransportConsumerResponse implements ICreateTransportConsumerResponse {
    isSuccess!: boolean;
    lstOverlapPeriod!: ConsumerTransportMappingDto[];

    constructor(data?: ICreateTransportConsumerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["lstOverlapPeriod"])) {
                this.lstOverlapPeriod = [] as any;
                for (let item of _data["lstOverlapPeriod"])
                    this.lstOverlapPeriod!.push(ConsumerTransportMappingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateTransportConsumerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransportConsumerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.lstOverlapPeriod)) {
            data["lstOverlapPeriod"] = [];
            for (let item of this.lstOverlapPeriod)
                data["lstOverlapPeriod"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateTransportConsumerResponse {
        const json = this.toJSON();
        let result = new CreateTransportConsumerResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateTransportConsumerResponse {
    isSuccess: boolean;
    lstOverlapPeriod: ConsumerTransportMappingDto[];
}

export class ConsumerTransportMappingDto implements IConsumerTransportMappingDto {
    transportConsumerStoppageMappingId!: number;
    stoppageId!: number;
    stoppageName!: string;
    roleId!: number;
    consumerId!: number;
    userName!: string;
    roleName!: string;
    ngbFromDate!: SchoolNgbDateModel | undefined;
    fromDate!: moment.Moment | undefined;
    ngbToDate!: SchoolNgbDateModel | undefined;
    toDate!: moment.Moment | undefined;
    academicYearId!: number;
    pickDropId!: number;
    pickDropPrice!: number;
    isFeePaymentAlreadyDone!: boolean;

    constructor(data?: IConsumerTransportMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transportConsumerStoppageMappingId = _data["transportConsumerStoppageMappingId"];
            this.stoppageId = _data["stoppageId"];
            this.stoppageName = _data["stoppageName"];
            this.roleId = _data["roleId"];
            this.consumerId = _data["consumerId"];
            this.userName = _data["userName"];
            this.roleName = _data["roleName"];
            this.ngbFromDate = _data["ngbFromDate"] ? SchoolNgbDateModel.fromJS(_data["ngbFromDate"]) : <any>undefined;
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.ngbToDate = _data["ngbToDate"] ? SchoolNgbDateModel.fromJS(_data["ngbToDate"]) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.academicYearId = _data["academicYearId"];
            this.pickDropId = _data["pickDropId"];
            this.pickDropPrice = _data["pickDropPrice"];
            this.isFeePaymentAlreadyDone = _data["isFeePaymentAlreadyDone"];
        }
    }

    static fromJS(data: any): ConsumerTransportMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerTransportMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transportConsumerStoppageMappingId"] = this.transportConsumerStoppageMappingId;
        data["stoppageId"] = this.stoppageId;
        data["stoppageName"] = this.stoppageName;
        data["roleId"] = this.roleId;
        data["consumerId"] = this.consumerId;
        data["userName"] = this.userName;
        data["roleName"] = this.roleName;
        data["ngbFromDate"] = this.ngbFromDate ? this.ngbFromDate.toJSON() : <any>undefined;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["ngbToDate"] = this.ngbToDate ? this.ngbToDate.toJSON() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["academicYearId"] = this.academicYearId;
        data["pickDropId"] = this.pickDropId;
        data["pickDropPrice"] = this.pickDropPrice;
        data["isFeePaymentAlreadyDone"] = this.isFeePaymentAlreadyDone;
        return data;
    }

    clone(): ConsumerTransportMappingDto {
        const json = this.toJSON();
        let result = new ConsumerTransportMappingDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerTransportMappingDto {
    transportConsumerStoppageMappingId: number;
    stoppageId: number;
    stoppageName: string;
    roleId: number;
    consumerId: number;
    userName: string;
    roleName: string;
    ngbFromDate: SchoolNgbDateModel | undefined;
    fromDate: moment.Moment | undefined;
    ngbToDate: SchoolNgbDateModel | undefined;
    toDate: moment.Moment | undefined;
    academicYearId: number;
    pickDropId: number;
    pickDropPrice: number;
    isFeePaymentAlreadyDone: boolean;
}

export class ConsumerTransportMappingUpsertDto implements IConsumerTransportMappingUpsertDto {
    userId!: number;
    consumers!: ConsumerTransportMappingDto[];

    constructor(data?: IConsumerTransportMappingUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["consumers"])) {
                this.consumers = [] as any;
                for (let item of _data["consumers"])
                    this.consumers!.push(ConsumerTransportMappingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsumerTransportMappingUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerTransportMappingUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.consumers)) {
            data["consumers"] = [];
            for (let item of this.consumers)
                data["consumers"].push(item.toJSON());
        }
        return data;
    }

    clone(): ConsumerTransportMappingUpsertDto {
        const json = this.toJSON();
        let result = new ConsumerTransportMappingUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerTransportMappingUpsertDto {
    userId: number;
    consumers: ConsumerTransportMappingDto[];
}

export class ConsumerByStoppageIdInputDto implements IConsumerByStoppageIdInputDto {
    stoppageId!: number;
    academicYearId!: number;
    consumerName!: string;

    constructor(data?: IConsumerByStoppageIdInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stoppageId = _data["stoppageId"];
            this.academicYearId = _data["academicYearId"];
            this.consumerName = _data["consumerName"];
        }
    }

    static fromJS(data: any): ConsumerByStoppageIdInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerByStoppageIdInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stoppageId"] = this.stoppageId;
        data["academicYearId"] = this.academicYearId;
        data["consumerName"] = this.consumerName;
        return data;
    }

    clone(): ConsumerByStoppageIdInputDto {
        const json = this.toJSON();
        let result = new ConsumerByStoppageIdInputDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerByStoppageIdInputDto {
    stoppageId: number;
    academicYearId: number;
    consumerName: string;
}

export class ConsumerDeleteResposeDto implements IConsumerDeleteResposeDto {
    affectedRows!: number;

    constructor(data?: IConsumerDeleteResposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): ConsumerDeleteResposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerDeleteResposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): ConsumerDeleteResposeDto {
        const json = this.toJSON();
        let result = new ConsumerDeleteResposeDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerDeleteResposeDto {
    affectedRows: number;
}

export class ActiveTripResponseDto implements IActiveTripResponseDto {
    activeTripList!: ActiveTripDto[];

    constructor(data?: IActiveTripResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["activeTripList"])) {
                this.activeTripList = [] as any;
                for (let item of _data["activeTripList"])
                    this.activeTripList!.push(ActiveTripDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActiveTripResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveTripResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activeTripList)) {
            data["activeTripList"] = [];
            for (let item of this.activeTripList)
                data["activeTripList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ActiveTripResponseDto {
        const json = this.toJSON();
        let result = new ActiveTripResponseDto();
        result.init(json);
        return result;
    }
}

export interface IActiveTripResponseDto {
    activeTripList: ActiveTripDto[];
}

export class ActiveTripDto implements IActiveTripDto {
    cabDriverTripCurrentLocationId!: number;
    tripId!: number;
    lat!: string;
    long!: string;
    routeId!: number;
    routeName!: string;
    vehicleId!: number;
    vehicleNumber!: string;
    ragistrationNumber!: string;

    constructor(data?: IActiveTripDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cabDriverTripCurrentLocationId = _data["cabDriverTripCurrentLocationId"];
            this.tripId = _data["tripId"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.routeId = _data["routeId"];
            this.routeName = _data["routeName"];
            this.vehicleId = _data["vehicleId"];
            this.vehicleNumber = _data["vehicleNumber"];
            this.ragistrationNumber = _data["ragistrationNumber"];
        }
    }

    static fromJS(data: any): ActiveTripDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveTripDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cabDriverTripCurrentLocationId"] = this.cabDriverTripCurrentLocationId;
        data["tripId"] = this.tripId;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["routeId"] = this.routeId;
        data["routeName"] = this.routeName;
        data["vehicleId"] = this.vehicleId;
        data["vehicleNumber"] = this.vehicleNumber;
        data["ragistrationNumber"] = this.ragistrationNumber;
        return data;
    }

    clone(): ActiveTripDto {
        const json = this.toJSON();
        let result = new ActiveTripDto();
        result.init(json);
        return result;
    }
}

export interface IActiveTripDto {
    cabDriverTripCurrentLocationId: number;
    tripId: number;
    lat: string;
    long: string;
    routeId: number;
    routeName: string;
    vehicleId: number;
    vehicleNumber: string;
    ragistrationNumber: string;
}

export class StoppageTrackResponseLisDto implements IStoppageTrackResponseLisDto {
    stoppageTrackResponseList!: StoppageLatLngDto[];

    constructor(data?: IStoppageTrackResponseLisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stoppageTrackResponseList"])) {
                this.stoppageTrackResponseList = [] as any;
                for (let item of _data["stoppageTrackResponseList"])
                    this.stoppageTrackResponseList!.push(StoppageLatLngDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoppageTrackResponseLisDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoppageTrackResponseLisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stoppageTrackResponseList)) {
            data["stoppageTrackResponseList"] = [];
            for (let item of this.stoppageTrackResponseList)
                data["stoppageTrackResponseList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StoppageTrackResponseLisDto {
        const json = this.toJSON();
        let result = new StoppageTrackResponseLisDto();
        result.init(json);
        return result;
    }
}

export interface IStoppageTrackResponseLisDto {
    stoppageTrackResponseList: StoppageLatLngDto[];
}

export class StoppageLatLngDto implements IStoppageLatLngDto {
    lat!: string;
    lng!: string;
    stopName!: string;
    orderNo!: number;

    constructor(data?: IStoppageLatLngDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.stopName = _data["stopName"];
            this.orderNo = _data["orderNo"];
        }
    }

    static fromJS(data: any): StoppageLatLngDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoppageLatLngDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["stopName"] = this.stopName;
        data["orderNo"] = this.orderNo;
        return data;
    }

    clone(): StoppageLatLngDto {
        const json = this.toJSON();
        let result = new StoppageLatLngDto();
        result.init(json);
        return result;
    }
}

export interface IStoppageLatLngDto {
    lat: string;
    lng: string;
    stopName: string;
    orderNo: number;
}

export class TransportFeePaymentSelectDto implements ITransportFeePaymentSelectDto {
    fullName!: string;
    generalRegistrationNo!: string;
    isNewStudent!: boolean;
    isRTEStudent!: boolean;
    appAccessMobileNo!: string;
    academicYearId!: number;
    rollNumber!: string;
    gradeName!: string;
    divisionName!: string;
    transportFeePaymentAppliedMonthList!: TransportFeePaymentAppliedMonths[];
    transportFeePaymentAdditionalDiscountList!: TransportFeePaymentAdditionalDiscount[];
    transportFeePaymentParticularsList!: TransportFeePaymentParticulars[];

    constructor(data?: ITransportFeePaymentSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.isNewStudent = _data["isNewStudent"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.academicYearId = _data["academicYearId"];
            this.rollNumber = _data["rollNumber"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            if (Array.isArray(_data["transportFeePaymentAppliedMonthList"])) {
                this.transportFeePaymentAppliedMonthList = [] as any;
                for (let item of _data["transportFeePaymentAppliedMonthList"])
                    this.transportFeePaymentAppliedMonthList!.push(TransportFeePaymentAppliedMonths.fromJS(item));
            }
            if (Array.isArray(_data["transportFeePaymentAdditionalDiscountList"])) {
                this.transportFeePaymentAdditionalDiscountList = [] as any;
                for (let item of _data["transportFeePaymentAdditionalDiscountList"])
                    this.transportFeePaymentAdditionalDiscountList!.push(TransportFeePaymentAdditionalDiscount.fromJS(item));
            }
            if (Array.isArray(_data["transportFeePaymentParticularsList"])) {
                this.transportFeePaymentParticularsList = [] as any;
                for (let item of _data["transportFeePaymentParticularsList"])
                    this.transportFeePaymentParticularsList!.push(TransportFeePaymentParticulars.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportFeePaymentSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["isNewStudent"] = this.isNewStudent;
        data["isRTEStudent"] = this.isRTEStudent;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["academicYearId"] = this.academicYearId;
        data["rollNumber"] = this.rollNumber;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        if (Array.isArray(this.transportFeePaymentAppliedMonthList)) {
            data["transportFeePaymentAppliedMonthList"] = [];
            for (let item of this.transportFeePaymentAppliedMonthList)
                data["transportFeePaymentAppliedMonthList"].push(item.toJSON());
        }
        if (Array.isArray(this.transportFeePaymentAdditionalDiscountList)) {
            data["transportFeePaymentAdditionalDiscountList"] = [];
            for (let item of this.transportFeePaymentAdditionalDiscountList)
                data["transportFeePaymentAdditionalDiscountList"].push(item.toJSON());
        }
        if (Array.isArray(this.transportFeePaymentParticularsList)) {
            data["transportFeePaymentParticularsList"] = [];
            for (let item of this.transportFeePaymentParticularsList)
                data["transportFeePaymentParticularsList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportFeePaymentSelectDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentSelectDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentSelectDto {
    fullName: string;
    generalRegistrationNo: string;
    isNewStudent: boolean;
    isRTEStudent: boolean;
    appAccessMobileNo: string;
    academicYearId: number;
    rollNumber: string;
    gradeName: string;
    divisionName: string;
    transportFeePaymentAppliedMonthList: TransportFeePaymentAppliedMonths[];
    transportFeePaymentAdditionalDiscountList: TransportFeePaymentAdditionalDiscount[];
    transportFeePaymentParticularsList: TransportFeePaymentParticulars[];
}

export class TransportFeePaymentAppliedMonths implements ITransportFeePaymentAppliedMonths {
    academicYearId!: number;
    monthMasterId!: number;
    transportFeeAdditionalDiscountId!: number | undefined;

    constructor(data?: ITransportFeePaymentAppliedMonths) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.monthMasterId = _data["monthMasterId"];
            this.transportFeeAdditionalDiscountId = _data["transportFeeAdditionalDiscountId"];
        }
    }

    static fromJS(data: any): TransportFeePaymentAppliedMonths {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentAppliedMonths();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["monthMasterId"] = this.monthMasterId;
        data["transportFeeAdditionalDiscountId"] = this.transportFeeAdditionalDiscountId;
        return data;
    }

    clone(): TransportFeePaymentAppliedMonths {
        const json = this.toJSON();
        let result = new TransportFeePaymentAppliedMonths();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentAppliedMonths {
    academicYearId: number;
    monthMasterId: number;
    transportFeeAdditionalDiscountId: number | undefined;
}

export class TransportFeePaymentAdditionalDiscount implements ITransportFeePaymentAdditionalDiscount {
    transportFeeAdditionalDiscountId!: number;
    academicYearId!: number;
    additionalDiscountedAmount!: number;
    installmentPaybleFee!: number;
    paymentInstallmentNumber!: number | undefined;
    additionalDiscountedRemark!: string;
    appliedDate!: string | undefined;
    totalFee!: number;

    constructor(data?: ITransportFeePaymentAdditionalDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transportFeeAdditionalDiscountId = _data["transportFeeAdditionalDiscountId"];
            this.academicYearId = _data["academicYearId"];
            this.additionalDiscountedAmount = _data["additionalDiscountedAmount"];
            this.installmentPaybleFee = _data["installmentPaybleFee"];
            this.paymentInstallmentNumber = _data["paymentInstallmentNumber"];
            this.additionalDiscountedRemark = _data["additionalDiscountedRemark"];
            this.appliedDate = _data["appliedDate"];
            this.totalFee = _data["totalFee"];
        }
    }

    static fromJS(data: any): TransportFeePaymentAdditionalDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentAdditionalDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transportFeeAdditionalDiscountId"] = this.transportFeeAdditionalDiscountId;
        data["academicYearId"] = this.academicYearId;
        data["additionalDiscountedAmount"] = this.additionalDiscountedAmount;
        data["installmentPaybleFee"] = this.installmentPaybleFee;
        data["paymentInstallmentNumber"] = this.paymentInstallmentNumber;
        data["additionalDiscountedRemark"] = this.additionalDiscountedRemark;
        data["appliedDate"] = this.appliedDate;
        data["totalFee"] = this.totalFee;
        return data;
    }

    clone(): TransportFeePaymentAdditionalDiscount {
        const json = this.toJSON();
        let result = new TransportFeePaymentAdditionalDiscount();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentAdditionalDiscount {
    transportFeeAdditionalDiscountId: number;
    academicYearId: number;
    additionalDiscountedAmount: number;
    installmentPaybleFee: number;
    paymentInstallmentNumber: number | undefined;
    additionalDiscountedRemark: string;
    appliedDate: string | undefined;
    totalFee: number;
}

export class TransportFeePaymentParticulars implements ITransportFeePaymentParticulars {
    additionalDiscInPercentage!: number;
    totalFee!: number;
    feeAfterDiscount!: number;
    paybleFee!: number;
    dueAmount!: number;
    alreadyPaid!: number;
    additionalDiscAmount!: number;
    showError!: boolean;

    constructor(data?: ITransportFeePaymentParticulars) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additionalDiscInPercentage = _data["additionalDiscInPercentage"];
            this.totalFee = _data["totalFee"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.paybleFee = _data["paybleFee"];
            this.dueAmount = _data["dueAmount"];
            this.alreadyPaid = _data["alreadyPaid"];
            this.additionalDiscAmount = _data["additionalDiscAmount"];
            this.showError = _data["showError"];
        }
    }

    static fromJS(data: any): TransportFeePaymentParticulars {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentParticulars();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalDiscInPercentage"] = this.additionalDiscInPercentage;
        data["totalFee"] = this.totalFee;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["paybleFee"] = this.paybleFee;
        data["dueAmount"] = this.dueAmount;
        data["alreadyPaid"] = this.alreadyPaid;
        data["additionalDiscAmount"] = this.additionalDiscAmount;
        data["showError"] = this.showError;
        return data;
    }

    clone(): TransportFeePaymentParticulars {
        const json = this.toJSON();
        let result = new TransportFeePaymentParticulars();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentParticulars {
    additionalDiscInPercentage: number;
    totalFee: number;
    feeAfterDiscount: number;
    paybleFee: number;
    dueAmount: number;
    alreadyPaid: number;
    additionalDiscAmount: number;
    showError: boolean;
}

export class TransportFeePaymentUpsertDto implements ITransportFeePaymentUpsertDto {
    academicYearId!: number | undefined;
    roleId!: number | undefined;
    consumerId!: number | undefined;
    transportConsumerStoppageMappingId!: number | undefined;
    onlineTransactionId!: string | undefined;
    onlineTransactionDateTime!: moment.Moment | undefined;
    ngbOnlineTransactionDateTime!: SchoolNgbDateModel | undefined;
    onlinePaymentRequest!: string | undefined;
    onlinePaymentResponse!: string | undefined;
    paidToBank!: string | undefined;
    paidAmount!: number | undefined;
    paymentTypeId!: number | undefined;
    chequeNumber!: string;
    chequeDate!: moment.Moment | undefined;
    ngbChequeDate!: SchoolNgbDateModel | undefined;
    chequeBank!: string;
    chequeAmount!: number | undefined;
    isChequeClear!: boolean | undefined;
    remark!: string;
    additionalDiscountedAmount!: number | undefined;
    installmentPaybleFee!: number | undefined;
    additionalDiscountedRemark!: string | undefined;
    userId!: number | undefined;
    transportFeePaymentAppliedMonthMappingTypeUpsertDtoList!: TransportFeePaymentAppliedMonthMappingTypeUpsertDto[];
    transportFeePaymentDetailTypeUpsertDtoList!: TransportFeePaymentDetailTypeUpsertDto[];

    constructor(data?: ITransportFeePaymentUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.roleId = _data["roleId"];
            this.consumerId = _data["consumerId"];
            this.transportConsumerStoppageMappingId = _data["transportConsumerStoppageMappingId"];
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"] ? moment(_data["onlineTransactionDateTime"].toString()) : <any>undefined;
            this.ngbOnlineTransactionDateTime = _data["ngbOnlineTransactionDateTime"] ? SchoolNgbDateModel.fromJS(_data["ngbOnlineTransactionDateTime"]) : <any>undefined;
            this.onlinePaymentRequest = _data["onlinePaymentRequest"];
            this.onlinePaymentResponse = _data["onlinePaymentResponse"];
            this.paidToBank = _data["paidToBank"];
            this.paidAmount = _data["paidAmount"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.ngbChequeDate = _data["ngbChequeDate"] ? SchoolNgbDateModel.fromJS(_data["ngbChequeDate"]) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.chequeAmount = _data["chequeAmount"];
            this.isChequeClear = _data["isChequeClear"];
            this.remark = _data["remark"];
            this.additionalDiscountedAmount = _data["additionalDiscountedAmount"];
            this.installmentPaybleFee = _data["installmentPaybleFee"];
            this.additionalDiscountedRemark = _data["additionalDiscountedRemark"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["transportFeePaymentAppliedMonthMappingTypeUpsertDtoList"])) {
                this.transportFeePaymentAppliedMonthMappingTypeUpsertDtoList = [] as any;
                for (let item of _data["transportFeePaymentAppliedMonthMappingTypeUpsertDtoList"])
                    this.transportFeePaymentAppliedMonthMappingTypeUpsertDtoList!.push(TransportFeePaymentAppliedMonthMappingTypeUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["transportFeePaymentDetailTypeUpsertDtoList"])) {
                this.transportFeePaymentDetailTypeUpsertDtoList = [] as any;
                for (let item of _data["transportFeePaymentDetailTypeUpsertDtoList"])
                    this.transportFeePaymentDetailTypeUpsertDtoList!.push(TransportFeePaymentDetailTypeUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportFeePaymentUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["roleId"] = this.roleId;
        data["consumerId"] = this.consumerId;
        data["transportConsumerStoppageMappingId"] = this.transportConsumerStoppageMappingId;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime ? this.onlineTransactionDateTime.toISOString() : <any>undefined;
        data["ngbOnlineTransactionDateTime"] = this.ngbOnlineTransactionDateTime ? this.ngbOnlineTransactionDateTime.toJSON() : <any>undefined;
        data["onlinePaymentRequest"] = this.onlinePaymentRequest;
        data["onlinePaymentResponse"] = this.onlinePaymentResponse;
        data["paidToBank"] = this.paidToBank;
        data["paidAmount"] = this.paidAmount;
        data["paymentTypeId"] = this.paymentTypeId;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["ngbChequeDate"] = this.ngbChequeDate ? this.ngbChequeDate.toJSON() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["chequeAmount"] = this.chequeAmount;
        data["isChequeClear"] = this.isChequeClear;
        data["remark"] = this.remark;
        data["additionalDiscountedAmount"] = this.additionalDiscountedAmount;
        data["installmentPaybleFee"] = this.installmentPaybleFee;
        data["additionalDiscountedRemark"] = this.additionalDiscountedRemark;
        data["userId"] = this.userId;
        if (Array.isArray(this.transportFeePaymentAppliedMonthMappingTypeUpsertDtoList)) {
            data["transportFeePaymentAppliedMonthMappingTypeUpsertDtoList"] = [];
            for (let item of this.transportFeePaymentAppliedMonthMappingTypeUpsertDtoList)
                data["transportFeePaymentAppliedMonthMappingTypeUpsertDtoList"].push(item.toJSON());
        }
        if (Array.isArray(this.transportFeePaymentDetailTypeUpsertDtoList)) {
            data["transportFeePaymentDetailTypeUpsertDtoList"] = [];
            for (let item of this.transportFeePaymentDetailTypeUpsertDtoList)
                data["transportFeePaymentDetailTypeUpsertDtoList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportFeePaymentUpsertDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentUpsertDto {
    academicYearId: number | undefined;
    roleId: number | undefined;
    consumerId: number | undefined;
    transportConsumerStoppageMappingId: number | undefined;
    onlineTransactionId: string | undefined;
    onlineTransactionDateTime: moment.Moment | undefined;
    ngbOnlineTransactionDateTime: SchoolNgbDateModel | undefined;
    onlinePaymentRequest: string | undefined;
    onlinePaymentResponse: string | undefined;
    paidToBank: string | undefined;
    paidAmount: number | undefined;
    paymentTypeId: number | undefined;
    chequeNumber: string;
    chequeDate: moment.Moment | undefined;
    ngbChequeDate: SchoolNgbDateModel | undefined;
    chequeBank: string;
    chequeAmount: number | undefined;
    isChequeClear: boolean | undefined;
    remark: string;
    additionalDiscountedAmount: number | undefined;
    installmentPaybleFee: number | undefined;
    additionalDiscountedRemark: string | undefined;
    userId: number | undefined;
    transportFeePaymentAppliedMonthMappingTypeUpsertDtoList: TransportFeePaymentAppliedMonthMappingTypeUpsertDto[];
    transportFeePaymentDetailTypeUpsertDtoList: TransportFeePaymentDetailTypeUpsertDto[];
}

export class TransportFeePaymentAppliedMonthMappingTypeUpsertDto implements ITransportFeePaymentAppliedMonthMappingTypeUpsertDto {
    monthMasterId!: number;
    discountedPercent!: number;
    discountedAmount!: number;

    constructor(data?: ITransportFeePaymentAppliedMonthMappingTypeUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.monthMasterId = _data["monthMasterId"];
            this.discountedPercent = _data["discountedPercent"];
            this.discountedAmount = _data["discountedAmount"];
        }
    }

    static fromJS(data: any): TransportFeePaymentAppliedMonthMappingTypeUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentAppliedMonthMappingTypeUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monthMasterId"] = this.monthMasterId;
        data["discountedPercent"] = this.discountedPercent;
        data["discountedAmount"] = this.discountedAmount;
        return data;
    }

    clone(): TransportFeePaymentAppliedMonthMappingTypeUpsertDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentAppliedMonthMappingTypeUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentAppliedMonthMappingTypeUpsertDto {
    monthMasterId: number;
    discountedPercent: number;
    discountedAmount: number;
}

export class TransportFeePaymentDetailTypeUpsertDto implements ITransportFeePaymentDetailTypeUpsertDto {
    otherFeeReason!: string;
    paidAmount!: number;
    feeAfterDiscount!: number;
    additionalDiscInPercentage!: number;
    additionalDiscAmount!: number;

    constructor(data?: ITransportFeePaymentDetailTypeUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.otherFeeReason = _data["otherFeeReason"];
            this.paidAmount = _data["paidAmount"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.additionalDiscInPercentage = _data["additionalDiscInPercentage"];
            this.additionalDiscAmount = _data["additionalDiscAmount"];
        }
    }

    static fromJS(data: any): TransportFeePaymentDetailTypeUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentDetailTypeUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["otherFeeReason"] = this.otherFeeReason;
        data["paidAmount"] = this.paidAmount;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["additionalDiscInPercentage"] = this.additionalDiscInPercentage;
        data["additionalDiscAmount"] = this.additionalDiscAmount;
        return data;
    }

    clone(): TransportFeePaymentDetailTypeUpsertDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentDetailTypeUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentDetailTypeUpsertDto {
    otherFeeReason: string;
    paidAmount: number;
    feeAfterDiscount: number;
    additionalDiscInPercentage: number;
    additionalDiscAmount: number;
}

export class TransportFeeMonthMastersDto implements ITransportFeeMonthMastersDto {
    transportFeeMonthMastersList!: TransportFeeMonthMasterDto[];

    constructor(data?: ITransportFeeMonthMastersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["transportFeeMonthMastersList"])) {
                this.transportFeeMonthMastersList = [] as any;
                for (let item of _data["transportFeeMonthMastersList"])
                    this.transportFeeMonthMastersList!.push(TransportFeeMonthMasterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportFeeMonthMastersDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeeMonthMastersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transportFeeMonthMastersList)) {
            data["transportFeeMonthMastersList"] = [];
            for (let item of this.transportFeeMonthMastersList)
                data["transportFeeMonthMastersList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportFeeMonthMastersDto {
        const json = this.toJSON();
        let result = new TransportFeeMonthMastersDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeeMonthMastersDto {
    transportFeeMonthMastersList: TransportFeeMonthMasterDto[];
}

export class TransportFeeMonthMasterDto implements ITransportFeeMonthMasterDto {
    isCurrentChecked!: boolean;
    isAlreadyChecked!: boolean;
    monthMasterId!: number | undefined;
    monthMasterName!: string | undefined;
    perMonthAmount!: number | undefined;

    constructor(data?: ITransportFeeMonthMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isCurrentChecked = _data["isCurrentChecked"];
            this.isAlreadyChecked = _data["isAlreadyChecked"];
            this.monthMasterId = _data["monthMasterId"];
            this.monthMasterName = _data["monthMasterName"];
            this.perMonthAmount = _data["perMonthAmount"];
        }
    }

    static fromJS(data: any): TransportFeeMonthMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeeMonthMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCurrentChecked"] = this.isCurrentChecked;
        data["isAlreadyChecked"] = this.isAlreadyChecked;
        data["monthMasterId"] = this.monthMasterId;
        data["monthMasterName"] = this.monthMasterName;
        data["perMonthAmount"] = this.perMonthAmount;
        return data;
    }

    clone(): TransportFeeMonthMasterDto {
        const json = this.toJSON();
        let result = new TransportFeeMonthMasterDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeeMonthMasterDto {
    isCurrentChecked: boolean;
    isAlreadyChecked: boolean;
    monthMasterId: number | undefined;
    monthMasterName: string | undefined;
    perMonthAmount: number | undefined;
}

export class TransportFeePaymentStoppageGridDto implements ITransportFeePaymentStoppageGridDto {
    transportFeePaymentStoppageDtoList!: TransportFeePaymentStoppageDto[];

    constructor(data?: ITransportFeePaymentStoppageGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["transportFeePaymentStoppageDtoList"])) {
                this.transportFeePaymentStoppageDtoList = [] as any;
                for (let item of _data["transportFeePaymentStoppageDtoList"])
                    this.transportFeePaymentStoppageDtoList!.push(TransportFeePaymentStoppageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportFeePaymentStoppageGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentStoppageGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transportFeePaymentStoppageDtoList)) {
            data["transportFeePaymentStoppageDtoList"] = [];
            for (let item of this.transportFeePaymentStoppageDtoList)
                data["transportFeePaymentStoppageDtoList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportFeePaymentStoppageGridDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentStoppageGridDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentStoppageGridDto {
    transportFeePaymentStoppageDtoList: TransportFeePaymentStoppageDto[];
}

export class TransportFeePaymentStoppageDto implements ITransportFeePaymentStoppageDto {
    consumerId!: number;
    roleId!: number;
    transportConsumerStoppageMappingId!: number;
    routeName!: string;
    pickDropId!: number;
    pickDropPrice!: number;
    months!: number;
    fromDateString!: string | undefined;
    toDateString!: string | undefined;
    stoppageName!: string;
    academicYearId!: number;
    academicYearKey!: string | undefined;
    fullName!: string;
    totalFee!: number;
    discountedFee!: number;
    paidAmount!: number;
    otherPaidAmount!: number;
    dueAmount!: number;
    chequeClearedAmount!: number;
    chequeUnclearAmount!: number;

    constructor(data?: ITransportFeePaymentStoppageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerId = _data["consumerId"];
            this.roleId = _data["roleId"];
            this.transportConsumerStoppageMappingId = _data["transportConsumerStoppageMappingId"];
            this.routeName = _data["routeName"];
            this.pickDropId = _data["pickDropId"];
            this.pickDropPrice = _data["pickDropPrice"];
            this.months = _data["months"];
            this.fromDateString = _data["fromDateString"];
            this.toDateString = _data["toDateString"];
            this.stoppageName = _data["stoppageName"];
            this.academicYearId = _data["academicYearId"];
            this.academicYearKey = _data["academicYearKey"];
            this.fullName = _data["fullName"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.paidAmount = _data["paidAmount"];
            this.otherPaidAmount = _data["otherPaidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.chequeClearedAmount = _data["chequeClearedAmount"];
            this.chequeUnclearAmount = _data["chequeUnclearAmount"];
        }
    }

    static fromJS(data: any): TransportFeePaymentStoppageDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentStoppageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerId"] = this.consumerId;
        data["roleId"] = this.roleId;
        data["transportConsumerStoppageMappingId"] = this.transportConsumerStoppageMappingId;
        data["routeName"] = this.routeName;
        data["pickDropId"] = this.pickDropId;
        data["pickDropPrice"] = this.pickDropPrice;
        data["months"] = this.months;
        data["fromDateString"] = this.fromDateString;
        data["toDateString"] = this.toDateString;
        data["stoppageName"] = this.stoppageName;
        data["academicYearId"] = this.academicYearId;
        data["academicYearKey"] = this.academicYearKey;
        data["fullName"] = this.fullName;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["paidAmount"] = this.paidAmount;
        data["otherPaidAmount"] = this.otherPaidAmount;
        data["dueAmount"] = this.dueAmount;
        data["chequeClearedAmount"] = this.chequeClearedAmount;
        data["chequeUnclearAmount"] = this.chequeUnclearAmount;
        return data;
    }

    clone(): TransportFeePaymentStoppageDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentStoppageDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentStoppageDto {
    consumerId: number;
    roleId: number;
    transportConsumerStoppageMappingId: number;
    routeName: string;
    pickDropId: number;
    pickDropPrice: number;
    months: number;
    fromDateString: string | undefined;
    toDateString: string | undefined;
    stoppageName: string;
    academicYearId: number;
    academicYearKey: string | undefined;
    fullName: string;
    totalFee: number;
    discountedFee: number;
    paidAmount: number;
    otherPaidAmount: number;
    dueAmount: number;
    chequeClearedAmount: number;
    chequeUnclearAmount: number;
}

export class TransportFeePaymentHistorySelectDto implements ITransportFeePaymentHistorySelectDto {
    schoolName!: string;
    schoolAddress!: string;
    academicYearId!: number;
    fullName!: string;
    gradeName!: string;
    divisionName!: string;
    rollNumber!: string;
    generalRegistrationNo!: string | undefined;
    paymentTypeName!: string;
    paymentDate!: moment.Moment | undefined;
    chequeDate!: moment.Moment | undefined;
    chequeBank!: string;
    transactionId!: string;
    invoiceNumber!: string;
    transportFeeSelectList!: TransportFeeSelectDto[];
    paidMonthList!: string[];

    constructor(data?: ITransportFeePaymentHistorySelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.schoolAddress = _data["schoolAddress"];
            this.academicYearId = _data["academicYearId"];
            this.fullName = _data["fullName"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.transactionId = _data["transactionId"];
            this.invoiceNumber = _data["invoiceNumber"];
            if (Array.isArray(_data["transportFeeSelectList"])) {
                this.transportFeeSelectList = [] as any;
                for (let item of _data["transportFeeSelectList"])
                    this.transportFeeSelectList!.push(TransportFeeSelectDto.fromJS(item));
            }
            if (Array.isArray(_data["paidMonthList"])) {
                this.paidMonthList = [] as any;
                for (let item of _data["paidMonthList"])
                    this.paidMonthList!.push(item);
            }
        }
    }

    static fromJS(data: any): TransportFeePaymentHistorySelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentHistorySelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["schoolAddress"] = this.schoolAddress;
        data["academicYearId"] = this.academicYearId;
        data["fullName"] = this.fullName;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["paymentTypeName"] = this.paymentTypeName;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["transactionId"] = this.transactionId;
        data["invoiceNumber"] = this.invoiceNumber;
        if (Array.isArray(this.transportFeeSelectList)) {
            data["transportFeeSelectList"] = [];
            for (let item of this.transportFeeSelectList)
                data["transportFeeSelectList"].push(item.toJSON());
        }
        if (Array.isArray(this.paidMonthList)) {
            data["paidMonthList"] = [];
            for (let item of this.paidMonthList)
                data["paidMonthList"].push(item);
        }
        return data;
    }

    clone(): TransportFeePaymentHistorySelectDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentHistorySelectDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentHistorySelectDto {
    schoolName: string;
    schoolAddress: string;
    academicYearId: number;
    fullName: string;
    gradeName: string;
    divisionName: string;
    rollNumber: string;
    generalRegistrationNo: string | undefined;
    paymentTypeName: string;
    paymentDate: moment.Moment | undefined;
    chequeDate: moment.Moment | undefined;
    chequeBank: string;
    transactionId: string;
    invoiceNumber: string;
    transportFeeSelectList: TransportFeeSelectDto[];
    paidMonthList: string[];
}

export class TransportFeeSelectDto implements ITransportFeeSelectDto {
    totalFee!: number;
    feeAfterDiscount!: number;
    paidAmount!: number;
    dueAmount!: number;
    alreadyPaid!: number;

    constructor(data?: ITransportFeeSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalFee = _data["totalFee"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.paidAmount = _data["paidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.alreadyPaid = _data["alreadyPaid"];
        }
    }

    static fromJS(data: any): TransportFeeSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeeSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalFee"] = this.totalFee;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["paidAmount"] = this.paidAmount;
        data["dueAmount"] = this.dueAmount;
        data["alreadyPaid"] = this.alreadyPaid;
        return data;
    }

    clone(): TransportFeeSelectDto {
        const json = this.toJSON();
        let result = new TransportFeeSelectDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeeSelectDto {
    totalFee: number;
    feeAfterDiscount: number;
    paidAmount: number;
    dueAmount: number;
    alreadyPaid: number;
}

export class TransportPaymentReportDaywiseDto implements ITransportPaymentReportDaywiseDto {
    cashDaywiseTransportPaymentReport!: CashDaywiseTransportPaymentReport;
    chequeDaywiseTransportPaymentReport!: ChequeDaywiseTransportPaymentReport;
    ddDaywiseTransportPaymentReport!: DDDaywiseTransportPaymentReport;
    upiPaymentDaywiseTransportPaymentReport!: UpiPaymentDaywiseTransportPaymentReport;
    netBankingDaywiseTransportPaymentReport!: NetBankingTransportDaywisePaymentReport;
    cardDaywiseTransportPaymentReport!: CardDaywiseTransportPaymentReport;

    constructor(data?: ITransportPaymentReportDaywiseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashDaywiseTransportPaymentReport = _data["cashDaywiseTransportPaymentReport"] ? CashDaywiseTransportPaymentReport.fromJS(_data["cashDaywiseTransportPaymentReport"]) : <any>undefined;
            this.chequeDaywiseTransportPaymentReport = _data["chequeDaywiseTransportPaymentReport"] ? ChequeDaywiseTransportPaymentReport.fromJS(_data["chequeDaywiseTransportPaymentReport"]) : <any>undefined;
            this.ddDaywiseTransportPaymentReport = _data["ddDaywiseTransportPaymentReport"] ? DDDaywiseTransportPaymentReport.fromJS(_data["ddDaywiseTransportPaymentReport"]) : <any>undefined;
            this.upiPaymentDaywiseTransportPaymentReport = _data["upiPaymentDaywiseTransportPaymentReport"] ? UpiPaymentDaywiseTransportPaymentReport.fromJS(_data["upiPaymentDaywiseTransportPaymentReport"]) : <any>undefined;
            this.netBankingDaywiseTransportPaymentReport = _data["netBankingDaywiseTransportPaymentReport"] ? NetBankingTransportDaywisePaymentReport.fromJS(_data["netBankingDaywiseTransportPaymentReport"]) : <any>undefined;
            this.cardDaywiseTransportPaymentReport = _data["cardDaywiseTransportPaymentReport"] ? CardDaywiseTransportPaymentReport.fromJS(_data["cardDaywiseTransportPaymentReport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransportPaymentReportDaywiseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentReportDaywiseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashDaywiseTransportPaymentReport"] = this.cashDaywiseTransportPaymentReport ? this.cashDaywiseTransportPaymentReport.toJSON() : <any>undefined;
        data["chequeDaywiseTransportPaymentReport"] = this.chequeDaywiseTransportPaymentReport ? this.chequeDaywiseTransportPaymentReport.toJSON() : <any>undefined;
        data["ddDaywiseTransportPaymentReport"] = this.ddDaywiseTransportPaymentReport ? this.ddDaywiseTransportPaymentReport.toJSON() : <any>undefined;
        data["upiPaymentDaywiseTransportPaymentReport"] = this.upiPaymentDaywiseTransportPaymentReport ? this.upiPaymentDaywiseTransportPaymentReport.toJSON() : <any>undefined;
        data["netBankingDaywiseTransportPaymentReport"] = this.netBankingDaywiseTransportPaymentReport ? this.netBankingDaywiseTransportPaymentReport.toJSON() : <any>undefined;
        data["cardDaywiseTransportPaymentReport"] = this.cardDaywiseTransportPaymentReport ? this.cardDaywiseTransportPaymentReport.toJSON() : <any>undefined;
        return data;
    }

    clone(): TransportPaymentReportDaywiseDto {
        const json = this.toJSON();
        let result = new TransportPaymentReportDaywiseDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentReportDaywiseDto {
    cashDaywiseTransportPaymentReport: CashDaywiseTransportPaymentReport;
    chequeDaywiseTransportPaymentReport: ChequeDaywiseTransportPaymentReport;
    ddDaywiseTransportPaymentReport: DDDaywiseTransportPaymentReport;
    upiPaymentDaywiseTransportPaymentReport: UpiPaymentDaywiseTransportPaymentReport;
    netBankingDaywiseTransportPaymentReport: NetBankingTransportDaywisePaymentReport;
    cardDaywiseTransportPaymentReport: CardDaywiseTransportPaymentReport;
}

export class CashDaywiseTransportPaymentReport implements ICashDaywiseTransportPaymentReport {
    cashDaywiseTransportPaymentReportList!: DaywiseTransportPaymentReport[];
    cashDaywiseTransportPaymentReportTotal!: DaywiseTransportPaymentReportTotal;

    constructor(data?: ICashDaywiseTransportPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cashDaywiseTransportPaymentReportList"])) {
                this.cashDaywiseTransportPaymentReportList = [] as any;
                for (let item of _data["cashDaywiseTransportPaymentReportList"])
                    this.cashDaywiseTransportPaymentReportList!.push(DaywiseTransportPaymentReport.fromJS(item));
            }
            this.cashDaywiseTransportPaymentReportTotal = _data["cashDaywiseTransportPaymentReportTotal"] ? DaywiseTransportPaymentReportTotal.fromJS(_data["cashDaywiseTransportPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashDaywiseTransportPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new CashDaywiseTransportPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cashDaywiseTransportPaymentReportList)) {
            data["cashDaywiseTransportPaymentReportList"] = [];
            for (let item of this.cashDaywiseTransportPaymentReportList)
                data["cashDaywiseTransportPaymentReportList"].push(item.toJSON());
        }
        data["cashDaywiseTransportPaymentReportTotal"] = this.cashDaywiseTransportPaymentReportTotal ? this.cashDaywiseTransportPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): CashDaywiseTransportPaymentReport {
        const json = this.toJSON();
        let result = new CashDaywiseTransportPaymentReport();
        result.init(json);
        return result;
    }
}

export interface ICashDaywiseTransportPaymentReport {
    cashDaywiseTransportPaymentReportList: DaywiseTransportPaymentReport[];
    cashDaywiseTransportPaymentReportTotal: DaywiseTransportPaymentReportTotal;
}

export class DaywiseTransportPaymentReport implements IDaywiseTransportPaymentReport {
    fullName!: string;
    userType!: string;
    chequeNumber!: string;
    chequeDate!: moment.Moment;
    chequeBank!: string;
    academicYearName!: string;
    paymentAmount!: number;
    invoiceNumber!: string;
    transactionDate!: moment.Moment;
    paymentMode!: string;
    chequeUnclearedAmount!: number;
    transactionBy!: string;
    transactionId!: string;

    constructor(data?: IDaywiseTransportPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.userType = _data["userType"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.academicYearName = _data["academicYearName"];
            this.paymentAmount = _data["paymentAmount"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.transactionDate = _data["transactionDate"] ? moment(_data["transactionDate"].toString()) : <any>undefined;
            this.paymentMode = _data["paymentMode"];
            this.chequeUnclearedAmount = _data["chequeUnclearedAmount"];
            this.transactionBy = _data["transactionBy"];
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): DaywiseTransportPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new DaywiseTransportPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["userType"] = this.userType;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["academicYearName"] = this.academicYearName;
        data["paymentAmount"] = this.paymentAmount;
        data["invoiceNumber"] = this.invoiceNumber;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["paymentMode"] = this.paymentMode;
        data["chequeUnclearedAmount"] = this.chequeUnclearedAmount;
        data["transactionBy"] = this.transactionBy;
        data["transactionId"] = this.transactionId;
        return data;
    }

    clone(): DaywiseTransportPaymentReport {
        const json = this.toJSON();
        let result = new DaywiseTransportPaymentReport();
        result.init(json);
        return result;
    }
}

export interface IDaywiseTransportPaymentReport {
    fullName: string;
    userType: string;
    chequeNumber: string;
    chequeDate: moment.Moment;
    chequeBank: string;
    academicYearName: string;
    paymentAmount: number;
    invoiceNumber: string;
    transactionDate: moment.Moment;
    paymentMode: string;
    chequeUnclearedAmount: number;
    transactionBy: string;
    transactionId: string;
}

export class DaywiseTransportPaymentReportTotal implements IDaywiseTransportPaymentReportTotal {
    totalPaymentAmount!: number;
    totalChequeUnclearedAmount!: number;

    constructor(data?: IDaywiseTransportPaymentReportTotal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPaymentAmount = _data["totalPaymentAmount"];
            this.totalChequeUnclearedAmount = _data["totalChequeUnclearedAmount"];
        }
    }

    static fromJS(data: any): DaywiseTransportPaymentReportTotal {
        data = typeof data === 'object' ? data : {};
        let result = new DaywiseTransportPaymentReportTotal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPaymentAmount"] = this.totalPaymentAmount;
        data["totalChequeUnclearedAmount"] = this.totalChequeUnclearedAmount;
        return data;
    }

    clone(): DaywiseTransportPaymentReportTotal {
        const json = this.toJSON();
        let result = new DaywiseTransportPaymentReportTotal();
        result.init(json);
        return result;
    }
}

export interface IDaywiseTransportPaymentReportTotal {
    totalPaymentAmount: number;
    totalChequeUnclearedAmount: number;
}

export class ChequeDaywiseTransportPaymentReport implements IChequeDaywiseTransportPaymentReport {
    chequeDaywiseTransportPaymentReportList!: DaywiseTransportPaymentReport[];
    chequeDaywiseTransportPaymentReportTotal!: DaywiseTransportPaymentReportTotal;

    constructor(data?: IChequeDaywiseTransportPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chequeDaywiseTransportPaymentReportList"])) {
                this.chequeDaywiseTransportPaymentReportList = [] as any;
                for (let item of _data["chequeDaywiseTransportPaymentReportList"])
                    this.chequeDaywiseTransportPaymentReportList!.push(DaywiseTransportPaymentReport.fromJS(item));
            }
            this.chequeDaywiseTransportPaymentReportTotal = _data["chequeDaywiseTransportPaymentReportTotal"] ? DaywiseTransportPaymentReportTotal.fromJS(_data["chequeDaywiseTransportPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChequeDaywiseTransportPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new ChequeDaywiseTransportPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chequeDaywiseTransportPaymentReportList)) {
            data["chequeDaywiseTransportPaymentReportList"] = [];
            for (let item of this.chequeDaywiseTransportPaymentReportList)
                data["chequeDaywiseTransportPaymentReportList"].push(item.toJSON());
        }
        data["chequeDaywiseTransportPaymentReportTotal"] = this.chequeDaywiseTransportPaymentReportTotal ? this.chequeDaywiseTransportPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): ChequeDaywiseTransportPaymentReport {
        const json = this.toJSON();
        let result = new ChequeDaywiseTransportPaymentReport();
        result.init(json);
        return result;
    }
}

export interface IChequeDaywiseTransportPaymentReport {
    chequeDaywiseTransportPaymentReportList: DaywiseTransportPaymentReport[];
    chequeDaywiseTransportPaymentReportTotal: DaywiseTransportPaymentReportTotal;
}

export class DDDaywiseTransportPaymentReport implements IDDDaywiseTransportPaymentReport {
    ddDaywiseTransportPaymentReportList!: DaywiseTransportPaymentReport[];
    ddDaywiseTransportPaymentReportTotal!: DaywiseTransportPaymentReportTotal;

    constructor(data?: IDDDaywiseTransportPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ddDaywiseTransportPaymentReportList"])) {
                this.ddDaywiseTransportPaymentReportList = [] as any;
                for (let item of _data["ddDaywiseTransportPaymentReportList"])
                    this.ddDaywiseTransportPaymentReportList!.push(DaywiseTransportPaymentReport.fromJS(item));
            }
            this.ddDaywiseTransportPaymentReportTotal = _data["ddDaywiseTransportPaymentReportTotal"] ? DaywiseTransportPaymentReportTotal.fromJS(_data["ddDaywiseTransportPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DDDaywiseTransportPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new DDDaywiseTransportPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ddDaywiseTransportPaymentReportList)) {
            data["ddDaywiseTransportPaymentReportList"] = [];
            for (let item of this.ddDaywiseTransportPaymentReportList)
                data["ddDaywiseTransportPaymentReportList"].push(item.toJSON());
        }
        data["ddDaywiseTransportPaymentReportTotal"] = this.ddDaywiseTransportPaymentReportTotal ? this.ddDaywiseTransportPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): DDDaywiseTransportPaymentReport {
        const json = this.toJSON();
        let result = new DDDaywiseTransportPaymentReport();
        result.init(json);
        return result;
    }
}

export interface IDDDaywiseTransportPaymentReport {
    ddDaywiseTransportPaymentReportList: DaywiseTransportPaymentReport[];
    ddDaywiseTransportPaymentReportTotal: DaywiseTransportPaymentReportTotal;
}

export class UpiPaymentDaywiseTransportPaymentReport implements IUpiPaymentDaywiseTransportPaymentReport {
    upiPaymentDaywiseTransportPaymentReportList!: DaywiseTransportPaymentReport[];
    upiPaymentDaywiseTransportPaymentReportTotal!: DaywiseTransportPaymentReportTotal;

    constructor(data?: IUpiPaymentDaywiseTransportPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upiPaymentDaywiseTransportPaymentReportList"])) {
                this.upiPaymentDaywiseTransportPaymentReportList = [] as any;
                for (let item of _data["upiPaymentDaywiseTransportPaymentReportList"])
                    this.upiPaymentDaywiseTransportPaymentReportList!.push(DaywiseTransportPaymentReport.fromJS(item));
            }
            this.upiPaymentDaywiseTransportPaymentReportTotal = _data["upiPaymentDaywiseTransportPaymentReportTotal"] ? DaywiseTransportPaymentReportTotal.fromJS(_data["upiPaymentDaywiseTransportPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpiPaymentDaywiseTransportPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new UpiPaymentDaywiseTransportPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upiPaymentDaywiseTransportPaymentReportList)) {
            data["upiPaymentDaywiseTransportPaymentReportList"] = [];
            for (let item of this.upiPaymentDaywiseTransportPaymentReportList)
                data["upiPaymentDaywiseTransportPaymentReportList"].push(item.toJSON());
        }
        data["upiPaymentDaywiseTransportPaymentReportTotal"] = this.upiPaymentDaywiseTransportPaymentReportTotal ? this.upiPaymentDaywiseTransportPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpiPaymentDaywiseTransportPaymentReport {
        const json = this.toJSON();
        let result = new UpiPaymentDaywiseTransportPaymentReport();
        result.init(json);
        return result;
    }
}

export interface IUpiPaymentDaywiseTransportPaymentReport {
    upiPaymentDaywiseTransportPaymentReportList: DaywiseTransportPaymentReport[];
    upiPaymentDaywiseTransportPaymentReportTotal: DaywiseTransportPaymentReportTotal;
}

export class NetBankingTransportDaywisePaymentReport implements INetBankingTransportDaywisePaymentReport {
    netBankingDaywiseTransportPaymentReportList!: DaywiseTransportPaymentReport[];
    netBankingDaywiseTransportPaymentReportTotal!: DaywiseTransportPaymentReportTotal;

    constructor(data?: INetBankingTransportDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["netBankingDaywiseTransportPaymentReportList"])) {
                this.netBankingDaywiseTransportPaymentReportList = [] as any;
                for (let item of _data["netBankingDaywiseTransportPaymentReportList"])
                    this.netBankingDaywiseTransportPaymentReportList!.push(DaywiseTransportPaymentReport.fromJS(item));
            }
            this.netBankingDaywiseTransportPaymentReportTotal = _data["netBankingDaywiseTransportPaymentReportTotal"] ? DaywiseTransportPaymentReportTotal.fromJS(_data["netBankingDaywiseTransportPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NetBankingTransportDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new NetBankingTransportDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.netBankingDaywiseTransportPaymentReportList)) {
            data["netBankingDaywiseTransportPaymentReportList"] = [];
            for (let item of this.netBankingDaywiseTransportPaymentReportList)
                data["netBankingDaywiseTransportPaymentReportList"].push(item.toJSON());
        }
        data["netBankingDaywiseTransportPaymentReportTotal"] = this.netBankingDaywiseTransportPaymentReportTotal ? this.netBankingDaywiseTransportPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): NetBankingTransportDaywisePaymentReport {
        const json = this.toJSON();
        let result = new NetBankingTransportDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface INetBankingTransportDaywisePaymentReport {
    netBankingDaywiseTransportPaymentReportList: DaywiseTransportPaymentReport[];
    netBankingDaywiseTransportPaymentReportTotal: DaywiseTransportPaymentReportTotal;
}

export class CardDaywiseTransportPaymentReport implements ICardDaywiseTransportPaymentReport {
    cardDaywiseTransportPaymentReportList!: DaywiseTransportPaymentReport[];
    cardDaywiseTransportPaymentReportTotal!: DaywiseTransportPaymentReportTotal;

    constructor(data?: ICardDaywiseTransportPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cardDaywiseTransportPaymentReportList"])) {
                this.cardDaywiseTransportPaymentReportList = [] as any;
                for (let item of _data["cardDaywiseTransportPaymentReportList"])
                    this.cardDaywiseTransportPaymentReportList!.push(DaywiseTransportPaymentReport.fromJS(item));
            }
            this.cardDaywiseTransportPaymentReportTotal = _data["cardDaywiseTransportPaymentReportTotal"] ? DaywiseTransportPaymentReportTotal.fromJS(_data["cardDaywiseTransportPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CardDaywiseTransportPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new CardDaywiseTransportPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cardDaywiseTransportPaymentReportList)) {
            data["cardDaywiseTransportPaymentReportList"] = [];
            for (let item of this.cardDaywiseTransportPaymentReportList)
                data["cardDaywiseTransportPaymentReportList"].push(item.toJSON());
        }
        data["cardDaywiseTransportPaymentReportTotal"] = this.cardDaywiseTransportPaymentReportTotal ? this.cardDaywiseTransportPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): CardDaywiseTransportPaymentReport {
        const json = this.toJSON();
        let result = new CardDaywiseTransportPaymentReport();
        result.init(json);
        return result;
    }
}

export interface ICardDaywiseTransportPaymentReport {
    cardDaywiseTransportPaymentReportList: DaywiseTransportPaymentReport[];
    cardDaywiseTransportPaymentReportTotal: DaywiseTransportPaymentReportTotal;
}

export class DaywiseTransportPaymentReportRequest implements IDaywiseTransportPaymentReportRequest {
    startDate!: SchoolNgbDateModel;
    endDate!: SchoolNgbDateModel;

    constructor(data?: IDaywiseTransportPaymentReportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? SchoolNgbDateModel.fromJS(_data["startDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? SchoolNgbDateModel.fromJS(_data["endDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DaywiseTransportPaymentReportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DaywiseTransportPaymentReportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>undefined;
        return data;
    }

    clone(): DaywiseTransportPaymentReportRequest {
        const json = this.toJSON();
        let result = new DaywiseTransportPaymentReportRequest();
        result.init(json);
        return result;
    }
}

export interface IDaywiseTransportPaymentReportRequest {
    startDate: SchoolNgbDateModel;
    endDate: SchoolNgbDateModel;
}

export class TeachingLoadAnalysisResponseDto implements ITeachingLoadAnalysisResponseDto {
    teacherPercentageList!: TeachingLoadAnalysisDto[] | undefined;

    constructor(data?: ITeachingLoadAnalysisResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["teacherPercentageList"])) {
                this.teacherPercentageList = [] as any;
                for (let item of _data["teacherPercentageList"])
                    this.teacherPercentageList!.push(TeachingLoadAnalysisDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeachingLoadAnalysisResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeachingLoadAnalysisResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.teacherPercentageList)) {
            data["teacherPercentageList"] = [];
            for (let item of this.teacherPercentageList)
                data["teacherPercentageList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeachingLoadAnalysisResponseDto {
        const json = this.toJSON();
        let result = new TeachingLoadAnalysisResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITeachingLoadAnalysisResponseDto {
    teacherPercentageList: TeachingLoadAnalysisDto[] | undefined;
}

export class TeachingLoadAnalysisDto implements ITeachingLoadAnalysisDto {
    academicYearId!: number | undefined;
    teacherId!: number | undefined;
    fullName!: string;
    classTimeTableId!: number | undefined;
    classTimeTableCount!: number | undefined;
    lecturePerWeek!: number | undefined;
    teacherPercentage!: string;

    constructor(data?: ITeachingLoadAnalysisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.teacherId = _data["teacherId"];
            this.fullName = _data["fullName"];
            this.classTimeTableId = _data["classTimeTableId"];
            this.classTimeTableCount = _data["classTimeTableCount"];
            this.lecturePerWeek = _data["lecturePerWeek"];
            this.teacherPercentage = _data["teacherPercentage"];
        }
    }

    static fromJS(data: any): TeachingLoadAnalysisDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeachingLoadAnalysisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["teacherId"] = this.teacherId;
        data["fullName"] = this.fullName;
        data["classTimeTableId"] = this.classTimeTableId;
        data["classTimeTableCount"] = this.classTimeTableCount;
        data["lecturePerWeek"] = this.lecturePerWeek;
        data["teacherPercentage"] = this.teacherPercentage;
        return data;
    }

    clone(): TeachingLoadAnalysisDto {
        const json = this.toJSON();
        let result = new TeachingLoadAnalysisDto();
        result.init(json);
        return result;
    }
}

export interface ITeachingLoadAnalysisDto {
    academicYearId: number | undefined;
    teacherId: number | undefined;
    fullName: string;
    classTimeTableId: number | undefined;
    classTimeTableCount: number | undefined;
    lecturePerWeek: number | undefined;
    teacherPercentage: string;
}

export class TeacherSubjectMappingUpsertDto implements ITeacherSubjectMappingUpsertDto {
    teacherSubjectExistResposeList!: TeacherSubjectExistResposeDto[];

    constructor(data?: ITeacherSubjectMappingUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["teacherSubjectExistResposeList"])) {
                this.teacherSubjectExistResposeList = [] as any;
                for (let item of _data["teacherSubjectExistResposeList"])
                    this.teacherSubjectExistResposeList!.push(TeacherSubjectExistResposeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherSubjectMappingUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherSubjectMappingUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.teacherSubjectExistResposeList)) {
            data["teacherSubjectExistResposeList"] = [];
            for (let item of this.teacherSubjectExistResposeList)
                data["teacherSubjectExistResposeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeacherSubjectMappingUpsertDto {
        const json = this.toJSON();
        let result = new TeacherSubjectMappingUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherSubjectMappingUpsertDto {
    teacherSubjectExistResposeList: TeacherSubjectExistResposeDto[];
}

export class TeacherSubjectExistResposeDto implements ITeacherSubjectExistResposeDto {
    subjectName!: string;
    existsInClassTimeTable!: number | undefined;
    success!: number;

    constructor(data?: ITeacherSubjectExistResposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectName = _data["subjectName"];
            this.existsInClassTimeTable = _data["existsInClassTimeTable"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TeacherSubjectExistResposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherSubjectExistResposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectName"] = this.subjectName;
        data["existsInClassTimeTable"] = this.existsInClassTimeTable;
        data["success"] = this.success;
        return data;
    }

    clone(): TeacherSubjectExistResposeDto {
        const json = this.toJSON();
        let result = new TeacherSubjectExistResposeDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherSubjectExistResposeDto {
    subjectName: string;
    existsInClassTimeTable: number | undefined;
    success: number;
}

export class TeacherSubjectMappingDto implements ITeacherSubjectMappingDto {
    teacherSubjectMappingId!: number;
    academicYearId!: number;
    teacherId!: number;
    fullName!: string | undefined;
    lecturePerWeek!: number | undefined;
    subjectMasterIds!: string;
    userId!: number;
    teacherSubjectList!: number[];

    constructor(data?: ITeacherSubjectMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherSubjectMappingId = _data["teacherSubjectMappingId"];
            this.academicYearId = _data["academicYearId"];
            this.teacherId = _data["teacherId"];
            this.fullName = _data["fullName"];
            this.lecturePerWeek = _data["lecturePerWeek"];
            this.subjectMasterIds = _data["subjectMasterIds"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["teacherSubjectList"])) {
                this.teacherSubjectList = [] as any;
                for (let item of _data["teacherSubjectList"])
                    this.teacherSubjectList!.push(item);
            }
        }
    }

    static fromJS(data: any): TeacherSubjectMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherSubjectMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherSubjectMappingId"] = this.teacherSubjectMappingId;
        data["academicYearId"] = this.academicYearId;
        data["teacherId"] = this.teacherId;
        data["fullName"] = this.fullName;
        data["lecturePerWeek"] = this.lecturePerWeek;
        data["subjectMasterIds"] = this.subjectMasterIds;
        data["userId"] = this.userId;
        if (Array.isArray(this.teacherSubjectList)) {
            data["teacherSubjectList"] = [];
            for (let item of this.teacherSubjectList)
                data["teacherSubjectList"].push(item);
        }
        return data;
    }

    clone(): TeacherSubjectMappingDto {
        const json = this.toJSON();
        let result = new TeacherSubjectMappingDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherSubjectMappingDto {
    teacherSubjectMappingId: number;
    academicYearId: number;
    teacherId: number;
    fullName: string | undefined;
    lecturePerWeek: number | undefined;
    subjectMasterIds: string;
    userId: number;
    teacherSubjectList: number[];
}

export class TeacherOneDayLectureResponseDto implements ITeacherOneDayLectureResponseDto {
    teacherOneDayLectureList!: TeacherOneDayLectureDto[] | undefined;

    constructor(data?: ITeacherOneDayLectureResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["teacherOneDayLectureList"])) {
                this.teacherOneDayLectureList = [] as any;
                for (let item of _data["teacherOneDayLectureList"])
                    this.teacherOneDayLectureList!.push(TeacherOneDayLectureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherOneDayLectureResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherOneDayLectureResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.teacherOneDayLectureList)) {
            data["teacherOneDayLectureList"] = [];
            for (let item of this.teacherOneDayLectureList)
                data["teacherOneDayLectureList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeacherOneDayLectureResponseDto {
        const json = this.toJSON();
        let result = new TeacherOneDayLectureResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherOneDayLectureResponseDto {
    teacherOneDayLectureList: TeacherOneDayLectureDto[] | undefined;
}

export class TeacherOneDayLectureDto implements ITeacherOneDayLectureDto {
    academicYearId!: number | undefined;
    teacherId!: number | undefined;
    teacherName!: string;
    startTime!: string | undefined;
    endTime!: string | undefined;
    gradeId!: number | undefined;
    gradeName!: string;
    divisionId!: number | undefined;
    divisionName!: string;
    dayNo!: number | undefined;
    subjectId!: number | undefined;
    subjectName!: string;

    constructor(data?: ITeacherOneDayLectureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.teacherId = _data["teacherId"];
            this.teacherName = _data["teacherName"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.dayNo = _data["dayNo"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): TeacherOneDayLectureDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherOneDayLectureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["teacherId"] = this.teacherId;
        data["teacherName"] = this.teacherName;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["dayNo"] = this.dayNo;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): TeacherOneDayLectureDto {
        const json = this.toJSON();
        let result = new TeacherOneDayLectureDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherOneDayLectureDto {
    academicYearId: number | undefined;
    teacherId: number | undefined;
    teacherName: string;
    startTime: string | undefined;
    endTime: string | undefined;
    gradeId: number | undefined;
    gradeName: string;
    divisionId: number | undefined;
    divisionName: string;
    dayNo: number | undefined;
    subjectId: number | undefined;
    subjectName: string;
}

export class TeacherDto implements ITeacherDto {
    teacherId!: number | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    teacherFullName!: string | undefined;
    address!: string | undefined;
    gender!: string | undefined;
    contactNumber!: string | undefined;
    mobileNumber!: string | undefined;
    emailId!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    talukaId!: number | undefined;
    districtId!: number | undefined;
    stateId!: number | undefined;
    talukaName!: string | undefined;
    districtName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    adharNumber!: string | undefined;
    countryId!: number | undefined;
    zipCode!: string | undefined;
    education!: string | undefined;
    bloodGroup!: string | undefined;
    profileImageURL!: string | undefined;
    userId!: number | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthDate!: moment.Moment | undefined;
    profileBase64Image!: string | undefined;
    profileImageContentType!: string | undefined;
    isAppAccess!: boolean | undefined;
    appAccessMobileNo!: string | undefined;
    appAccessOneTimePassword!: string | undefined;

    constructor(data?: ITeacherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.teacherFullName = _data["teacherFullName"];
            this.address = _data["address"];
            this.gender = _data["gender"];
            this.contactNumber = _data["contactNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.emailId = _data["emailId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.talukaId = _data["talukaId"];
            this.districtId = _data["districtId"];
            this.stateId = _data["stateId"];
            this.talukaName = _data["talukaName"];
            this.districtName = _data["districtName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.adharNumber = _data["adharNumber"];
            this.countryId = _data["countryId"];
            this.zipCode = _data["zipCode"];
            this.education = _data["education"];
            this.bloodGroup = _data["bloodGroup"];
            this.profileImageURL = _data["profileImageURL"];
            this.userId = _data["userId"];
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.profileBase64Image = _data["profileBase64Image"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.isAppAccess = _data["isAppAccess"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.appAccessOneTimePassword = _data["appAccessOneTimePassword"];
        }
    }

    static fromJS(data: any): TeacherDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["teacherFullName"] = this.teacherFullName;
        data["address"] = this.address;
        data["gender"] = this.gender;
        data["contactNumber"] = this.contactNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["emailId"] = this.emailId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["talukaId"] = this.talukaId;
        data["districtId"] = this.districtId;
        data["stateId"] = this.stateId;
        data["talukaName"] = this.talukaName;
        data["districtName"] = this.districtName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["adharNumber"] = this.adharNumber;
        data["countryId"] = this.countryId;
        data["zipCode"] = this.zipCode;
        data["education"] = this.education;
        data["bloodGroup"] = this.bloodGroup;
        data["profileImageURL"] = this.profileImageURL;
        data["userId"] = this.userId;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["profileBase64Image"] = this.profileBase64Image;
        data["profileImageContentType"] = this.profileImageContentType;
        data["isAppAccess"] = this.isAppAccess;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["appAccessOneTimePassword"] = this.appAccessOneTimePassword;
        return data;
    }

    clone(): TeacherDto {
        const json = this.toJSON();
        let result = new TeacherDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherDto {
    teacherId: number | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    teacherFullName: string | undefined;
    address: string | undefined;
    gender: string | undefined;
    contactNumber: string | undefined;
    mobileNumber: string | undefined;
    emailId: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    talukaId: number | undefined;
    districtId: number | undefined;
    stateId: number | undefined;
    talukaName: string | undefined;
    districtName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    adharNumber: string | undefined;
    countryId: number | undefined;
    zipCode: string | undefined;
    education: string | undefined;
    bloodGroup: string | undefined;
    profileImageURL: string | undefined;
    userId: number | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthDate: moment.Moment | undefined;
    profileBase64Image: string | undefined;
    profileImageContentType: string | undefined;
    isAppAccess: boolean | undefined;
    appAccessMobileNo: string | undefined;
    appAccessOneTimePassword: string | undefined;
}

export class TeacherDeleteRespose implements ITeacherDeleteRespose {
    affectedRows!: number;
    teacherGradeDivisionMappingCount!: number;
    teacherSubjectMappingCount!: number;

    constructor(data?: ITeacherDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
            this.teacherGradeDivisionMappingCount = _data["teacherGradeDivisionMappingCount"];
            this.teacherSubjectMappingCount = _data["teacherSubjectMappingCount"];
        }
    }

    static fromJS(data: any): TeacherDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        data["teacherGradeDivisionMappingCount"] = this.teacherGradeDivisionMappingCount;
        data["teacherSubjectMappingCount"] = this.teacherSubjectMappingCount;
        return data;
    }

    clone(): TeacherDeleteRespose {
        const json = this.toJSON();
        let result = new TeacherDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface ITeacherDeleteRespose {
    affectedRows: number;
    teacherGradeDivisionMappingCount: number;
    teacherSubjectMappingCount: number;
}

export class TeacherGradeDivisionMappingDto implements ITeacherGradeDivisionMappingDto {
    teacherGradeDivisionMappingId!: number;
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    className!: string;
    teacherIds!: string;
    userId!: number;
    teacherList!: number[];

    constructor(data?: ITeacherGradeDivisionMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherGradeDivisionMappingId = _data["teacherGradeDivisionMappingId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.className = _data["className"];
            this.teacherIds = _data["teacherIds"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["teacherList"])) {
                this.teacherList = [] as any;
                for (let item of _data["teacherList"])
                    this.teacherList!.push(item);
            }
        }
    }

    static fromJS(data: any): TeacherGradeDivisionMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherGradeDivisionMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherGradeDivisionMappingId"] = this.teacherGradeDivisionMappingId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["className"] = this.className;
        data["teacherIds"] = this.teacherIds;
        data["userId"] = this.userId;
        if (Array.isArray(this.teacherList)) {
            data["teacherList"] = [];
            for (let item of this.teacherList)
                data["teacherList"].push(item);
        }
        return data;
    }

    clone(): TeacherGradeDivisionMappingDto {
        const json = this.toJSON();
        let result = new TeacherGradeDivisionMappingDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherGradeDivisionMappingDto {
    teacherGradeDivisionMappingId: number;
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    className: string;
    teacherIds: string;
    userId: number;
    teacherList: number[];
}

export class TeacherCountPerSubjectAnalyzerResponseDto implements ITeacherCountPerSubjectAnalyzerResponseDto {
    getTeacherCountPerSubjects!: TeacherCountPerSubjectAnalyzerDto[];

    constructor(data?: ITeacherCountPerSubjectAnalyzerResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getTeacherCountPerSubjects"])) {
                this.getTeacherCountPerSubjects = [] as any;
                for (let item of _data["getTeacherCountPerSubjects"])
                    this.getTeacherCountPerSubjects!.push(TeacherCountPerSubjectAnalyzerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherCountPerSubjectAnalyzerResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherCountPerSubjectAnalyzerResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getTeacherCountPerSubjects)) {
            data["getTeacherCountPerSubjects"] = [];
            for (let item of this.getTeacherCountPerSubjects)
                data["getTeacherCountPerSubjects"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeacherCountPerSubjectAnalyzerResponseDto {
        const json = this.toJSON();
        let result = new TeacherCountPerSubjectAnalyzerResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherCountPerSubjectAnalyzerResponseDto {
    getTeacherCountPerSubjects: TeacherCountPerSubjectAnalyzerDto[];
}

export class TeacherCountPerSubjectAnalyzerDto implements ITeacherCountPerSubjectAnalyzerDto {
    academicYearId!: number;
    subjectName!: string;
    teacherCount!: number;

    constructor(data?: ITeacherCountPerSubjectAnalyzerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.subjectName = _data["subjectName"];
            this.teacherCount = _data["teacherCount"];
        }
    }

    static fromJS(data: any): TeacherCountPerSubjectAnalyzerDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherCountPerSubjectAnalyzerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["subjectName"] = this.subjectName;
        data["teacherCount"] = this.teacherCount;
        return data;
    }

    clone(): TeacherCountPerSubjectAnalyzerDto {
        const json = this.toJSON();
        let result = new TeacherCountPerSubjectAnalyzerDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherCountPerSubjectAnalyzerDto {
    academicYearId: number;
    subjectName: string;
    teacherCount: number;
}

export class StudentAttendanceGridResponseDto implements IStudentAttendanceGridResponseDto {
    studentAttendancesList!: StudentAttendanceGridDto[] | undefined;
    isSchoolHoliday!: number;

    constructor(data?: IStudentAttendanceGridResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentAttendancesList"])) {
                this.studentAttendancesList = [] as any;
                for (let item of _data["studentAttendancesList"])
                    this.studentAttendancesList!.push(StudentAttendanceGridDto.fromJS(item));
            }
            this.isSchoolHoliday = _data["isSchoolHoliday"];
        }
    }

    static fromJS(data: any): StudentAttendanceGridResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceGridResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentAttendancesList)) {
            data["studentAttendancesList"] = [];
            for (let item of this.studentAttendancesList)
                data["studentAttendancesList"].push(item.toJSON());
        }
        data["isSchoolHoliday"] = this.isSchoolHoliday;
        return data;
    }

    clone(): StudentAttendanceGridResponseDto {
        const json = this.toJSON();
        let result = new StudentAttendanceGridResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceGridResponseDto {
    studentAttendancesList: StudentAttendanceGridDto[] | undefined;
    isSchoolHoliday: number;
}

export class StudentAttendanceGridDto implements IStudentAttendanceGridDto {
    studentId!: number;
    rollNumber!: string;
    fullName!: string;
    statusId!: number | undefined;
    reason!: string;

    constructor(data?: IStudentAttendanceGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.rollNumber = _data["rollNumber"];
            this.fullName = _data["fullName"];
            this.statusId = _data["statusId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): StudentAttendanceGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["rollNumber"] = this.rollNumber;
        data["fullName"] = this.fullName;
        data["statusId"] = this.statusId;
        data["reason"] = this.reason;
        return data;
    }

    clone(): StudentAttendanceGridDto {
        const json = this.toJSON();
        let result = new StudentAttendanceGridDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceGridDto {
    studentId: number;
    rollNumber: string;
    fullName: string;
    statusId: number | undefined;
    reason: string;
}

export class StudentAttendanceRequestDto implements IStudentAttendanceRequestDto {
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    teacherId!: number;
    attendanceDate!: moment.Moment;
    ngbAttendanceDate!: SchoolNgbDateModel | undefined;

    constructor(data?: IStudentAttendanceRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.teacherId = _data["teacherId"];
            this.attendanceDate = _data["attendanceDate"] ? moment(_data["attendanceDate"].toString()) : <any>undefined;
            this.ngbAttendanceDate = _data["ngbAttendanceDate"] ? SchoolNgbDateModel.fromJS(_data["ngbAttendanceDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StudentAttendanceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["teacherId"] = this.teacherId;
        data["attendanceDate"] = this.attendanceDate ? this.attendanceDate.toISOString() : <any>undefined;
        data["ngbAttendanceDate"] = this.ngbAttendanceDate ? this.ngbAttendanceDate.toJSON() : <any>undefined;
        return data;
    }

    clone(): StudentAttendanceRequestDto {
        const json = this.toJSON();
        let result = new StudentAttendanceRequestDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceRequestDto {
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    teacherId: number;
    attendanceDate: moment.Moment;
    ngbAttendanceDate: SchoolNgbDateModel | undefined;
}

export class StudentAttendanceUpsertDto implements IStudentAttendanceUpsertDto {
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    attendanceDate!: moment.Moment;
    ngbAttendanceDate!: SchoolNgbDateModel | undefined;
    userId!: number;
    studentAttendanceUpsertLists!: StudentAttendanceUpsertListDto[];

    constructor(data?: IStudentAttendanceUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.attendanceDate = _data["attendanceDate"] ? moment(_data["attendanceDate"].toString()) : <any>undefined;
            this.ngbAttendanceDate = _data["ngbAttendanceDate"] ? SchoolNgbDateModel.fromJS(_data["ngbAttendanceDate"]) : <any>undefined;
            this.userId = _data["userId"];
            if (Array.isArray(_data["studentAttendanceUpsertLists"])) {
                this.studentAttendanceUpsertLists = [] as any;
                for (let item of _data["studentAttendanceUpsertLists"])
                    this.studentAttendanceUpsertLists!.push(StudentAttendanceUpsertListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentAttendanceUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["attendanceDate"] = this.attendanceDate ? this.attendanceDate.toISOString() : <any>undefined;
        data["ngbAttendanceDate"] = this.ngbAttendanceDate ? this.ngbAttendanceDate.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        if (Array.isArray(this.studentAttendanceUpsertLists)) {
            data["studentAttendanceUpsertLists"] = [];
            for (let item of this.studentAttendanceUpsertLists)
                data["studentAttendanceUpsertLists"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentAttendanceUpsertDto {
        const json = this.toJSON();
        let result = new StudentAttendanceUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceUpsertDto {
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    attendanceDate: moment.Moment;
    ngbAttendanceDate: SchoolNgbDateModel | undefined;
    userId: number;
    studentAttendanceUpsertLists: StudentAttendanceUpsertListDto[];
}

export class StudentAttendanceUpsertListDto implements IStudentAttendanceUpsertListDto {
    studentId!: number;
    statusId!: number | undefined;
    reason!: string | undefined;

    constructor(data?: IStudentAttendanceUpsertListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.statusId = _data["statusId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): StudentAttendanceUpsertListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceUpsertListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["statusId"] = this.statusId;
        data["reason"] = this.reason;
        return data;
    }

    clone(): StudentAttendanceUpsertListDto {
        const json = this.toJSON();
        let result = new StudentAttendanceUpsertListDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceUpsertListDto {
    studentId: number;
    statusId: number | undefined;
    reason: string | undefined;
}

export class ClassTeacherGradeDivisionListDto implements IClassTeacherGradeDivisionListDto {
    classTeacherGradeDivisionList!: SchoolGradeDivisionMatrixDto[];

    constructor(data?: IClassTeacherGradeDivisionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["classTeacherGradeDivisionList"])) {
                this.classTeacherGradeDivisionList = [] as any;
                for (let item of _data["classTeacherGradeDivisionList"])
                    this.classTeacherGradeDivisionList!.push(SchoolGradeDivisionMatrixDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassTeacherGradeDivisionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTeacherGradeDivisionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.classTeacherGradeDivisionList)) {
            data["classTeacherGradeDivisionList"] = [];
            for (let item of this.classTeacherGradeDivisionList)
                data["classTeacherGradeDivisionList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClassTeacherGradeDivisionListDto {
        const json = this.toJSON();
        let result = new ClassTeacherGradeDivisionListDto();
        result.init(json);
        return result;
    }
}

export interface IClassTeacherGradeDivisionListDto {
    classTeacherGradeDivisionList: SchoolGradeDivisionMatrixDto[];
}

export class SchoolGradeDivisionMatrixDto implements ISchoolGradeDivisionMatrixDto {
    schoolGradeDivisionMatrixId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    className!: string;

    constructor(data?: ISchoolGradeDivisionMatrixDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolGradeDivisionMatrixId = _data["schoolGradeDivisionMatrixId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.className = _data["className"];
        }
    }

    static fromJS(data: any): SchoolGradeDivisionMatrixDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolGradeDivisionMatrixDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolGradeDivisionMatrixId"] = this.schoolGradeDivisionMatrixId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["className"] = this.className;
        return data;
    }

    clone(): SchoolGradeDivisionMatrixDto {
        const json = this.toJSON();
        let result = new SchoolGradeDivisionMatrixDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolGradeDivisionMatrixDto {
    schoolGradeDivisionMatrixId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    className: string;
}

export class TeacherClassSubjectResponseDto implements ITeacherClassSubjectResponseDto {
    lstSubject!: TeacherClassSubjectDto[];

    constructor(data?: ITeacherClassSubjectResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstSubject"])) {
                this.lstSubject = [] as any;
                for (let item of _data["lstSubject"])
                    this.lstSubject!.push(TeacherClassSubjectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherClassSubjectResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherClassSubjectResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstSubject)) {
            data["lstSubject"] = [];
            for (let item of this.lstSubject)
                data["lstSubject"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeacherClassSubjectResponseDto {
        const json = this.toJSON();
        let result = new TeacherClassSubjectResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherClassSubjectResponseDto {
    lstSubject: TeacherClassSubjectDto[];
}

export class TeacherClassSubjectDto implements ITeacherClassSubjectDto {
    subjectMasterId!: number;
    subjectName!: string;

    constructor(data?: ITeacherClassSubjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectMasterId = _data["subjectMasterId"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): TeacherClassSubjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherClassSubjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectMasterId"] = this.subjectMasterId;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): TeacherClassSubjectDto {
        const json = this.toJSON();
        let result = new TeacherClassSubjectDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherClassSubjectDto {
    subjectMasterId: number;
    subjectName: string;
}

export class TeacherClassSubjectRequestDto implements ITeacherClassSubjectRequestDto {
    academicYearId!: number;
    teacherId!: number;
    classId!: number;

    constructor(data?: ITeacherClassSubjectRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.teacherId = _data["teacherId"];
            this.classId = _data["classId"];
        }
    }

    static fromJS(data: any): TeacherClassSubjectRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherClassSubjectRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["teacherId"] = this.teacherId;
        data["classId"] = this.classId;
        return data;
    }

    clone(): TeacherClassSubjectRequestDto {
        const json = this.toJSON();
        let result = new TeacherClassSubjectRequestDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherClassSubjectRequestDto {
    academicYearId: number;
    teacherId: number;
    classId: number;
}

export class SchoolDetailMobileDto implements ISchoolDetailMobileDto {
    schoolId!: number;
    logoUrl!: string;
    schoolName!: string;
    academicYearId!: number;
    academicYearStartMonth!: moment.Moment | undefined;

    constructor(data?: ISchoolDetailMobileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolId = _data["schoolId"];
            this.logoUrl = _data["logoUrl"];
            this.schoolName = _data["schoolName"];
            this.academicYearId = _data["academicYearId"];
            this.academicYearStartMonth = _data["academicYearStartMonth"] ? moment(_data["academicYearStartMonth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SchoolDetailMobileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolDetailMobileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolId"] = this.schoolId;
        data["logoUrl"] = this.logoUrl;
        data["schoolName"] = this.schoolName;
        data["academicYearId"] = this.academicYearId;
        data["academicYearStartMonth"] = this.academicYearStartMonth ? this.academicYearStartMonth.toISOString() : <any>undefined;
        return data;
    }

    clone(): SchoolDetailMobileDto {
        const json = this.toJSON();
        let result = new SchoolDetailMobileDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolDetailMobileDto {
    schoolId: number;
    logoUrl: string;
    schoolName: string;
    academicYearId: number;
    academicYearStartMonth: moment.Moment | undefined;
}

export class HomeworkListDto implements IHomeworkListDto {
    homeworkList!: HomeworkDto[];

    constructor(data?: IHomeworkListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["homeworkList"])) {
                this.homeworkList = [] as any;
                for (let item of _data["homeworkList"])
                    this.homeworkList!.push(HomeworkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HomeworkListDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeworkListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.homeworkList)) {
            data["homeworkList"] = [];
            for (let item of this.homeworkList)
                data["homeworkList"].push(item.toJSON());
        }
        return data;
    }

    clone(): HomeworkListDto {
        const json = this.toJSON();
        let result = new HomeworkListDto();
        result.init(json);
        return result;
    }
}

export interface IHomeworkListDto {
    homeworkList: HomeworkDto[];
}

export class HomeworkDto implements IHomeworkDto {
    homeworkId!: number;
    homeworkDescription!: string;
    classId!: number | undefined;
    gradeName!: string;
    divisionName!: string | undefined;
    endDate!: moment.Moment;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    status!: string;
    isPublished!: boolean;
    startDate!: moment.Moment;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    homeworkTitle!: string;
    subjectName!: string;
    createdBy!: string;
    modifiedBy!: string;
    createdDate!: string;
    modifiedDate!: string;

    constructor(data?: IHomeworkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.homeworkId = _data["homeworkId"];
            this.homeworkDescription = _data["homeworkDescription"];
            this.classId = _data["classId"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.status = _data["status"];
            this.isPublished = _data["isPublished"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.homeworkTitle = _data["homeworkTitle"];
            this.subjectName = _data["subjectName"];
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
        }
    }

    static fromJS(data: any): HomeworkDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeworkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["homeworkId"] = this.homeworkId;
        data["homeworkDescription"] = this.homeworkDescription;
        data["classId"] = this.classId;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["isPublished"] = this.isPublished;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["homeworkTitle"] = this.homeworkTitle;
        data["subjectName"] = this.subjectName;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        return data;
    }

    clone(): HomeworkDto {
        const json = this.toJSON();
        let result = new HomeworkDto();
        result.init(json);
        return result;
    }
}

export interface IHomeworkDto {
    homeworkId: number;
    homeworkDescription: string;
    classId: number | undefined;
    gradeName: string;
    divisionName: string | undefined;
    endDate: moment.Moment;
    ngbEndDate: SchoolNgbDateModel | undefined;
    status: string;
    isPublished: boolean;
    startDate: moment.Moment;
    ngbStartDate: SchoolNgbDateModel | undefined;
    homeworkTitle: string;
    subjectName: string;
    createdBy: string;
    modifiedBy: string;
    createdDate: string;
    modifiedDate: string;
}

export class PublishUnpublishHomeworkDto implements IPublishUnpublishHomeworkDto {
    homeworkId!: number;
    isPublished!: boolean;

    constructor(data?: IPublishUnpublishHomeworkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.homeworkId = _data["homeworkId"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): PublishUnpublishHomeworkDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishUnpublishHomeworkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["homeworkId"] = this.homeworkId;
        data["isPublished"] = this.isPublished;
        return data;
    }

    clone(): PublishUnpublishHomeworkDto {
        const json = this.toJSON();
        let result = new PublishUnpublishHomeworkDto();
        result.init(json);
        return result;
    }
}

export interface IPublishUnpublishHomeworkDto {
    homeworkId: number;
    isPublished: boolean;
}

export class HomeworkUpsertDto implements IHomeworkUpsertDto {
    homeworkId!: number;
    academicYearId!: number | undefined;
    gradeId!: number;
    divisionId!: number;
    gradeName!: string;
    divisionName!: string | undefined;
    classId!: number | undefined;
    subjectId!: number;
    subjectName!: string;
    homeworkTitle!: string;
    homeworkDescription!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    isPublished!: boolean;
    userId!: number;
    fileType!: MediaContentType;
    homeworkTextFileArray!: HomeworkFileDto[];
    homeworkMediaFileArray!: HomeworkFileDto[];
    mediaVideoText!: HomeworkMediaContentDto[];

    constructor(data?: IHomeworkUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.homeworkId = _data["homeworkId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.classId = _data["classId"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.homeworkTitle = _data["homeworkTitle"];
            this.homeworkDescription = _data["homeworkDescription"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.userId = _data["userId"];
            this.fileType = _data["fileType"];
            if (Array.isArray(_data["homeworkTextFileArray"])) {
                this.homeworkTextFileArray = [] as any;
                for (let item of _data["homeworkTextFileArray"])
                    this.homeworkTextFileArray!.push(HomeworkFileDto.fromJS(item));
            }
            if (Array.isArray(_data["homeworkMediaFileArray"])) {
                this.homeworkMediaFileArray = [] as any;
                for (let item of _data["homeworkMediaFileArray"])
                    this.homeworkMediaFileArray!.push(HomeworkFileDto.fromJS(item));
            }
            if (Array.isArray(_data["mediaVideoText"])) {
                this.mediaVideoText = [] as any;
                for (let item of _data["mediaVideoText"])
                    this.mediaVideoText!.push(HomeworkMediaContentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HomeworkUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeworkUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["homeworkId"] = this.homeworkId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["classId"] = this.classId;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["homeworkTitle"] = this.homeworkTitle;
        data["homeworkDescription"] = this.homeworkDescription;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["userId"] = this.userId;
        data["fileType"] = this.fileType;
        if (Array.isArray(this.homeworkTextFileArray)) {
            data["homeworkTextFileArray"] = [];
            for (let item of this.homeworkTextFileArray)
                data["homeworkTextFileArray"].push(item.toJSON());
        }
        if (Array.isArray(this.homeworkMediaFileArray)) {
            data["homeworkMediaFileArray"] = [];
            for (let item of this.homeworkMediaFileArray)
                data["homeworkMediaFileArray"].push(item.toJSON());
        }
        if (Array.isArray(this.mediaVideoText)) {
            data["mediaVideoText"] = [];
            for (let item of this.mediaVideoText)
                data["mediaVideoText"].push(item.toJSON());
        }
        return data;
    }

    clone(): HomeworkUpsertDto {
        const json = this.toJSON();
        let result = new HomeworkUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IHomeworkUpsertDto {
    homeworkId: number;
    academicYearId: number | undefined;
    gradeId: number;
    divisionId: number;
    gradeName: string;
    divisionName: string | undefined;
    classId: number | undefined;
    subjectId: number;
    subjectName: string;
    homeworkTitle: string;
    homeworkDescription: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    isPublished: boolean;
    userId: number;
    fileType: MediaContentType;
    homeworkTextFileArray: HomeworkFileDto[];
    homeworkMediaFileArray: HomeworkFileDto[];
    mediaVideoText: HomeworkMediaContentDto[];
}

export enum MediaContentType {
    IMAGE = 1,
    VIDEO = 2,
}

export class HomeworkFileDto implements IHomeworkFileDto {
    base64Image!: string;
    imageContentType!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IHomeworkFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64Image = _data["base64Image"];
            this.imageContentType = _data["imageContentType"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): HomeworkFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeworkFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64Image"] = this.base64Image;
        data["imageContentType"] = this.imageContentType;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): HomeworkFileDto {
        const json = this.toJSON();
        let result = new HomeworkFileDto();
        result.init(json);
        return result;
    }
}

export interface IHomeworkFileDto {
    base64Image: string;
    imageContentType: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class HomeworkMediaContentDto implements IHomeworkMediaContentDto {
    contentUrl!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IHomeworkMediaContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentUrl = _data["contentUrl"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): HomeworkMediaContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeworkMediaContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentUrl"] = this.contentUrl;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): HomeworkMediaContentDto {
        const json = this.toJSON();
        let result = new HomeworkMediaContentDto();
        result.init(json);
        return result;
    }
}

export interface IHomeworkMediaContentDto {
    contentUrl: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class NoticeUpsertDto implements INoticeUpsertDto {
    noticeId!: number;
    academicYearId!: number | undefined;
    isImportant!: boolean;
    noticeToType!: number;
    classId!: (number | undefined)[];
    studentId!: (number | undefined)[];
    teacherId!: (number | undefined)[];
    cabDriverId!: (number | undefined)[];
    clerkId!: (number | undefined)[];
    noticeTitle!: string;
    noticeDescription!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    isPublished!: boolean;
    userId!: number;
    fileType!: MediaContentType2;
    noticeTextFileArray!: NoticeFileDto[];
    videoText!: ProjectMediaContentDto[];

    constructor(data?: INoticeUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeId = _data["noticeId"];
            this.academicYearId = _data["academicYearId"];
            this.isImportant = _data["isImportant"];
            this.noticeToType = _data["noticeToType"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
            if (Array.isArray(_data["studentId"])) {
                this.studentId = [] as any;
                for (let item of _data["studentId"])
                    this.studentId!.push(item);
            }
            if (Array.isArray(_data["teacherId"])) {
                this.teacherId = [] as any;
                for (let item of _data["teacherId"])
                    this.teacherId!.push(item);
            }
            if (Array.isArray(_data["cabDriverId"])) {
                this.cabDriverId = [] as any;
                for (let item of _data["cabDriverId"])
                    this.cabDriverId!.push(item);
            }
            if (Array.isArray(_data["clerkId"])) {
                this.clerkId = [] as any;
                for (let item of _data["clerkId"])
                    this.clerkId!.push(item);
            }
            this.noticeTitle = _data["noticeTitle"];
            this.noticeDescription = _data["noticeDescription"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.userId = _data["userId"];
            this.fileType = _data["fileType"];
            if (Array.isArray(_data["noticeTextFileArray"])) {
                this.noticeTextFileArray = [] as any;
                for (let item of _data["noticeTextFileArray"])
                    this.noticeTextFileArray!.push(NoticeFileDto.fromJS(item));
            }
            if (Array.isArray(_data["videoText"])) {
                this.videoText = [] as any;
                for (let item of _data["videoText"])
                    this.videoText!.push(ProjectMediaContentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NoticeUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeId"] = this.noticeId;
        data["academicYearId"] = this.academicYearId;
        data["isImportant"] = this.isImportant;
        data["noticeToType"] = this.noticeToType;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        if (Array.isArray(this.studentId)) {
            data["studentId"] = [];
            for (let item of this.studentId)
                data["studentId"].push(item);
        }
        if (Array.isArray(this.teacherId)) {
            data["teacherId"] = [];
            for (let item of this.teacherId)
                data["teacherId"].push(item);
        }
        if (Array.isArray(this.cabDriverId)) {
            data["cabDriverId"] = [];
            for (let item of this.cabDriverId)
                data["cabDriverId"].push(item);
        }
        if (Array.isArray(this.clerkId)) {
            data["clerkId"] = [];
            for (let item of this.clerkId)
                data["clerkId"].push(item);
        }
        data["noticeTitle"] = this.noticeTitle;
        data["noticeDescription"] = this.noticeDescription;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["userId"] = this.userId;
        data["fileType"] = this.fileType;
        if (Array.isArray(this.noticeTextFileArray)) {
            data["noticeTextFileArray"] = [];
            for (let item of this.noticeTextFileArray)
                data["noticeTextFileArray"].push(item.toJSON());
        }
        if (Array.isArray(this.videoText)) {
            data["videoText"] = [];
            for (let item of this.videoText)
                data["videoText"].push(item.toJSON());
        }
        return data;
    }

    clone(): NoticeUpsertDto {
        const json = this.toJSON();
        let result = new NoticeUpsertDto();
        result.init(json);
        return result;
    }
}

export interface INoticeUpsertDto {
    noticeId: number;
    academicYearId: number | undefined;
    isImportant: boolean;
    noticeToType: number;
    classId: (number | undefined)[];
    studentId: (number | undefined)[];
    teacherId: (number | undefined)[];
    cabDriverId: (number | undefined)[];
    clerkId: (number | undefined)[];
    noticeTitle: string;
    noticeDescription: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    isPublished: boolean;
    userId: number;
    fileType: MediaContentType2;
    noticeTextFileArray: NoticeFileDto[];
    videoText: ProjectMediaContentDto[];
}

export enum MediaContentType2 {
    IMAGE = 1,
    VIDEO = 2,
}

export class NoticeFileDto implements INoticeFileDto {
    base64Image!: string;
    imageContentType!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: INoticeFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64Image = _data["base64Image"];
            this.imageContentType = _data["imageContentType"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): NoticeFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64Image"] = this.base64Image;
        data["imageContentType"] = this.imageContentType;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): NoticeFileDto {
        const json = this.toJSON();
        let result = new NoticeFileDto();
        result.init(json);
        return result;
    }
}

export interface INoticeFileDto {
    base64Image: string;
    imageContentType: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class ProjectMediaContentDto implements IProjectMediaContentDto {
    contentUrl!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IProjectMediaContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentUrl = _data["contentUrl"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): ProjectMediaContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectMediaContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentUrl"] = this.contentUrl;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): ProjectMediaContentDto {
        const json = this.toJSON();
        let result = new ProjectMediaContentDto();
        result.init(json);
        return result;
    }
}

export interface IProjectMediaContentDto {
    contentUrl: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class PublishUnpublishNoticeDto implements IPublishUnpublishNoticeDto {
    noticeId!: number;
    isPublished!: boolean;

    constructor(data?: IPublishUnpublishNoticeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeId = _data["noticeId"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): PublishUnpublishNoticeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishUnpublishNoticeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeId"] = this.noticeId;
        data["isPublished"] = this.isPublished;
        return data;
    }

    clone(): PublishUnpublishNoticeDto {
        const json = this.toJSON();
        let result = new PublishUnpublishNoticeDto();
        result.init(json);
        return result;
    }
}

export interface IPublishUnpublishNoticeDto {
    noticeId: number;
    isPublished: boolean;
}

export class NoticeListDto implements INoticeListDto {
    noticeList!: NoticeDto[];

    constructor(data?: INoticeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["noticeList"])) {
                this.noticeList = [] as any;
                for (let item of _data["noticeList"])
                    this.noticeList!.push(NoticeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NoticeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.noticeList)) {
            data["noticeList"] = [];
            for (let item of this.noticeList)
                data["noticeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): NoticeListDto {
        const json = this.toJSON();
        let result = new NoticeListDto();
        result.init(json);
        return result;
    }
}

export interface INoticeListDto {
    noticeList: NoticeDto[];
}

export class NoticeDto implements INoticeDto {
    noticeId!: number;
    noticeDescription!: string;
    noticeToType!: number | undefined;
    noticeTo!: string;
    isImportant!: boolean;
    endDate!: moment.Moment;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    status!: string;
    isPublished!: boolean;
    startDate!: moment.Moment;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    noticeTitle!: string;
    createdBy!: string;
    modifiedBy!: string;
    createdDate!: string;
    modifiedDate!: string;

    constructor(data?: INoticeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeId = _data["noticeId"];
            this.noticeDescription = _data["noticeDescription"];
            this.noticeToType = _data["noticeToType"];
            this.noticeTo = _data["noticeTo"];
            this.isImportant = _data["isImportant"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.status = _data["status"];
            this.isPublished = _data["isPublished"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.noticeTitle = _data["noticeTitle"];
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
        }
    }

    static fromJS(data: any): NoticeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeId"] = this.noticeId;
        data["noticeDescription"] = this.noticeDescription;
        data["noticeToType"] = this.noticeToType;
        data["noticeTo"] = this.noticeTo;
        data["isImportant"] = this.isImportant;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["isPublished"] = this.isPublished;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["noticeTitle"] = this.noticeTitle;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        return data;
    }

    clone(): NoticeDto {
        const json = this.toJSON();
        let result = new NoticeDto();
        result.init(json);
        return result;
    }
}

export interface INoticeDto {
    noticeId: number;
    noticeDescription: string;
    noticeToType: number | undefined;
    noticeTo: string;
    isImportant: boolean;
    endDate: moment.Moment;
    ngbEndDate: SchoolNgbDateModel | undefined;
    status: string;
    isPublished: boolean;
    startDate: moment.Moment;
    ngbStartDate: SchoolNgbDateModel | undefined;
    noticeTitle: string;
    createdBy: string;
    modifiedBy: string;
    createdDate: string;
    modifiedDate: string;
}

export class GalleryUpsertDto implements IGalleryUpsertDto {
    galleryId!: number;
    academicYearId!: number | undefined;
    galleryToType!: number | undefined;
    classId!: (number | undefined)[];
    studentId!: (number | undefined)[];
    teacherId!: (number | undefined)[];
    cabDriverId!: (number | undefined)[];
    clerkId!: (number | undefined)[];
    galleryTitle!: string;
    description!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    isPublished!: boolean;
    userId!: number | undefined;
    fileType!: MediaContentType3;
    galleryTextFileArray!: GalleryFileDto[];
    galleryVideoText!: GalleryMediaContentDto[];

    constructor(data?: IGalleryUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.galleryId = _data["galleryId"];
            this.academicYearId = _data["academicYearId"];
            this.galleryToType = _data["galleryToType"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
            if (Array.isArray(_data["studentId"])) {
                this.studentId = [] as any;
                for (let item of _data["studentId"])
                    this.studentId!.push(item);
            }
            if (Array.isArray(_data["teacherId"])) {
                this.teacherId = [] as any;
                for (let item of _data["teacherId"])
                    this.teacherId!.push(item);
            }
            if (Array.isArray(_data["cabDriverId"])) {
                this.cabDriverId = [] as any;
                for (let item of _data["cabDriverId"])
                    this.cabDriverId!.push(item);
            }
            if (Array.isArray(_data["clerkId"])) {
                this.clerkId = [] as any;
                for (let item of _data["clerkId"])
                    this.clerkId!.push(item);
            }
            this.galleryTitle = _data["galleryTitle"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.userId = _data["userId"];
            this.fileType = _data["fileType"];
            if (Array.isArray(_data["galleryTextFileArray"])) {
                this.galleryTextFileArray = [] as any;
                for (let item of _data["galleryTextFileArray"])
                    this.galleryTextFileArray!.push(GalleryFileDto.fromJS(item));
            }
            if (Array.isArray(_data["galleryVideoText"])) {
                this.galleryVideoText = [] as any;
                for (let item of _data["galleryVideoText"])
                    this.galleryVideoText!.push(GalleryMediaContentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GalleryUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new GalleryUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["galleryId"] = this.galleryId;
        data["academicYearId"] = this.academicYearId;
        data["galleryToType"] = this.galleryToType;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        if (Array.isArray(this.studentId)) {
            data["studentId"] = [];
            for (let item of this.studentId)
                data["studentId"].push(item);
        }
        if (Array.isArray(this.teacherId)) {
            data["teacherId"] = [];
            for (let item of this.teacherId)
                data["teacherId"].push(item);
        }
        if (Array.isArray(this.cabDriverId)) {
            data["cabDriverId"] = [];
            for (let item of this.cabDriverId)
                data["cabDriverId"].push(item);
        }
        if (Array.isArray(this.clerkId)) {
            data["clerkId"] = [];
            for (let item of this.clerkId)
                data["clerkId"].push(item);
        }
        data["galleryTitle"] = this.galleryTitle;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["userId"] = this.userId;
        data["fileType"] = this.fileType;
        if (Array.isArray(this.galleryTextFileArray)) {
            data["galleryTextFileArray"] = [];
            for (let item of this.galleryTextFileArray)
                data["galleryTextFileArray"].push(item.toJSON());
        }
        if (Array.isArray(this.galleryVideoText)) {
            data["galleryVideoText"] = [];
            for (let item of this.galleryVideoText)
                data["galleryVideoText"].push(item.toJSON());
        }
        return data;
    }

    clone(): GalleryUpsertDto {
        const json = this.toJSON();
        let result = new GalleryUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IGalleryUpsertDto {
    galleryId: number;
    academicYearId: number | undefined;
    galleryToType: number | undefined;
    classId: (number | undefined)[];
    studentId: (number | undefined)[];
    teacherId: (number | undefined)[];
    cabDriverId: (number | undefined)[];
    clerkId: (number | undefined)[];
    galleryTitle: string;
    description: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    isPublished: boolean;
    userId: number | undefined;
    fileType: MediaContentType3;
    galleryTextFileArray: GalleryFileDto[];
    galleryVideoText: GalleryMediaContentDto[];
}

export enum MediaContentType3 {
    IMAGE = 1,
    VIDEO = 2,
}

export class GalleryFileDto implements IGalleryFileDto {
    base64Image!: string;
    imageContentType!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IGalleryFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64Image = _data["base64Image"];
            this.imageContentType = _data["imageContentType"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): GalleryFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new GalleryFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64Image"] = this.base64Image;
        data["imageContentType"] = this.imageContentType;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): GalleryFileDto {
        const json = this.toJSON();
        let result = new GalleryFileDto();
        result.init(json);
        return result;
    }
}

export interface IGalleryFileDto {
    base64Image: string;
    imageContentType: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class GalleryMediaContentDto implements IGalleryMediaContentDto {
    contentUrl!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IGalleryMediaContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentUrl = _data["contentUrl"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): GalleryMediaContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new GalleryMediaContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentUrl"] = this.contentUrl;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): GalleryMediaContentDto {
        const json = this.toJSON();
        let result = new GalleryMediaContentDto();
        result.init(json);
        return result;
    }
}

export interface IGalleryMediaContentDto {
    contentUrl: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class PublishUnpublishGalleryDto implements IPublishUnpublishGalleryDto {
    galleryId!: number;
    isPublished!: boolean;

    constructor(data?: IPublishUnpublishGalleryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.galleryId = _data["galleryId"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): PublishUnpublishGalleryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishUnpublishGalleryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["galleryId"] = this.galleryId;
        data["isPublished"] = this.isPublished;
        return data;
    }

    clone(): PublishUnpublishGalleryDto {
        const json = this.toJSON();
        let result = new PublishUnpublishGalleryDto();
        result.init(json);
        return result;
    }
}

export interface IPublishUnpublishGalleryDto {
    galleryId: number;
    isPublished: boolean;
}

export class GalleryListDto implements IGalleryListDto {
    galleryList!: GalleryDto[];

    constructor(data?: IGalleryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["galleryList"])) {
                this.galleryList = [] as any;
                for (let item of _data["galleryList"])
                    this.galleryList!.push(GalleryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GalleryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GalleryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.galleryList)) {
            data["galleryList"] = [];
            for (let item of this.galleryList)
                data["galleryList"].push(item.toJSON());
        }
        return data;
    }

    clone(): GalleryListDto {
        const json = this.toJSON();
        let result = new GalleryListDto();
        result.init(json);
        return result;
    }
}

export interface IGalleryListDto {
    galleryList: GalleryDto[];
}

export class GalleryDto implements IGalleryDto {
    galleryId!: number;
    description!: string;
    galleryToType!: number | undefined;
    galleryTo!: string;
    startDate!: moment.Moment;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    status!: string;
    isPublished!: boolean;
    galleryTitle!: string;
    createdBy!: string;
    modifiedBy!: string;
    createdDate!: string;
    modifiedDate!: string;

    constructor(data?: IGalleryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.galleryId = _data["galleryId"];
            this.description = _data["description"];
            this.galleryToType = _data["galleryToType"];
            this.galleryTo = _data["galleryTo"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.status = _data["status"];
            this.isPublished = _data["isPublished"];
            this.galleryTitle = _data["galleryTitle"];
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
        }
    }

    static fromJS(data: any): GalleryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GalleryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["galleryId"] = this.galleryId;
        data["description"] = this.description;
        data["galleryToType"] = this.galleryToType;
        data["galleryTo"] = this.galleryTo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["isPublished"] = this.isPublished;
        data["galleryTitle"] = this.galleryTitle;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        return data;
    }

    clone(): GalleryDto {
        const json = this.toJSON();
        let result = new GalleryDto();
        result.init(json);
        return result;
    }
}

export interface IGalleryDto {
    galleryId: number;
    description: string;
    galleryToType: number | undefined;
    galleryTo: string;
    startDate: moment.Moment;
    ngbStartDate: SchoolNgbDateModel | undefined;
    status: string;
    isPublished: boolean;
    galleryTitle: string;
    createdBy: string;
    modifiedBy: string;
    createdDate: string;
    modifiedDate: string;
}

export class StudentTeacherAppResponseDto implements IStudentTeacherAppResponseDto {
    studentTeacherAppList!: StudentTeacherAppDto[] | undefined;

    constructor(data?: IStudentTeacherAppResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentTeacherAppList"])) {
                this.studentTeacherAppList = [] as any;
                for (let item of _data["studentTeacherAppList"])
                    this.studentTeacherAppList!.push(StudentTeacherAppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentTeacherAppResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentTeacherAppResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentTeacherAppList)) {
            data["studentTeacherAppList"] = [];
            for (let item of this.studentTeacherAppList)
                data["studentTeacherAppList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentTeacherAppResponseDto {
        const json = this.toJSON();
        let result = new StudentTeacherAppResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStudentTeacherAppResponseDto {
    studentTeacherAppList: StudentTeacherAppDto[] | undefined;
}

export class StudentTeacherAppDto implements IStudentTeacherAppDto {
    studentName!: string | undefined;
    rollNumber!: string | undefined;
    gender!: string | undefined;
    emergencyContactNumber!: string | undefined;
    profileImageURL!: string | undefined;

    constructor(data?: IStudentTeacherAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentName = _data["studentName"];
            this.rollNumber = _data["rollNumber"];
            this.gender = _data["gender"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.profileImageURL = _data["profileImageURL"];
        }
    }

    static fromJS(data: any): StudentTeacherAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentTeacherAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["rollNumber"] = this.rollNumber;
        data["gender"] = this.gender;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["profileImageURL"] = this.profileImageURL;
        return data;
    }

    clone(): StudentTeacherAppDto {
        const json = this.toJSON();
        let result = new StudentTeacherAppDto();
        result.init(json);
        return result;
    }
}

export interface IStudentTeacherAppDto {
    studentName: string | undefined;
    rollNumber: string | undefined;
    gender: string | undefined;
    emergencyContactNumber: string | undefined;
    profileImageURL: string | undefined;
}

export class ClassAttendanceMissingReportResponseDto implements IClassAttendanceMissingReportResponseDto {
    classAttendanceMissingList!: ClassAttendanceMissingReportDto[];

    constructor(data?: IClassAttendanceMissingReportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["classAttendanceMissingList"])) {
                this.classAttendanceMissingList = [] as any;
                for (let item of _data["classAttendanceMissingList"])
                    this.classAttendanceMissingList!.push(ClassAttendanceMissingReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassAttendanceMissingReportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassAttendanceMissingReportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.classAttendanceMissingList)) {
            data["classAttendanceMissingList"] = [];
            for (let item of this.classAttendanceMissingList)
                data["classAttendanceMissingList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClassAttendanceMissingReportResponseDto {
        const json = this.toJSON();
        let result = new ClassAttendanceMissingReportResponseDto();
        result.init(json);
        return result;
    }
}

export interface IClassAttendanceMissingReportResponseDto {
    classAttendanceMissingList: ClassAttendanceMissingReportDto[];
}

export class ClassAttendanceMissingReportDto implements IClassAttendanceMissingReportDto {
    academicYearId!: number;
    gradeId!: number | undefined;
    gradeName!: string;
    divisionId!: number | undefined;
    divisionName!: string | undefined;
    classId!: number;
    status!: string;
    attendanceMissingDate!: moment.Moment | undefined;
    ngbAttendanceMissingDate!: SchoolNgbDateModel | undefined;
    classTeacherId!: number;
    classTeacherName!: string;

    constructor(data?: IClassAttendanceMissingReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.classId = _data["classId"];
            this.status = _data["status"];
            this.attendanceMissingDate = _data["attendanceMissingDate"] ? moment(_data["attendanceMissingDate"].toString()) : <any>undefined;
            this.ngbAttendanceMissingDate = _data["ngbAttendanceMissingDate"] ? SchoolNgbDateModel.fromJS(_data["ngbAttendanceMissingDate"]) : <any>undefined;
            this.classTeacherId = _data["classTeacherId"];
            this.classTeacherName = _data["classTeacherName"];
        }
    }

    static fromJS(data: any): ClassAttendanceMissingReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassAttendanceMissingReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["classId"] = this.classId;
        data["status"] = this.status;
        data["attendanceMissingDate"] = this.attendanceMissingDate ? this.attendanceMissingDate.toISOString() : <any>undefined;
        data["ngbAttendanceMissingDate"] = this.ngbAttendanceMissingDate ? this.ngbAttendanceMissingDate.toJSON() : <any>undefined;
        data["classTeacherId"] = this.classTeacherId;
        data["classTeacherName"] = this.classTeacherName;
        return data;
    }

    clone(): ClassAttendanceMissingReportDto {
        const json = this.toJSON();
        let result = new ClassAttendanceMissingReportDto();
        result.init(json);
        return result;
    }
}

export interface IClassAttendanceMissingReportDto {
    academicYearId: number;
    gradeId: number | undefined;
    gradeName: string;
    divisionId: number | undefined;
    divisionName: string | undefined;
    classId: number;
    status: string;
    attendanceMissingDate: moment.Moment | undefined;
    ngbAttendanceMissingDate: SchoolNgbDateModel | undefined;
    classTeacherId: number;
    classTeacherName: string;
}

export class SchoolMonthEventResponseDto implements ISchoolMonthEventResponseDto {
    schoolMonthEventList!: SchoolMonthEventDto[] | undefined;

    constructor(data?: ISchoolMonthEventResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["schoolMonthEventList"])) {
                this.schoolMonthEventList = [] as any;
                for (let item of _data["schoolMonthEventList"])
                    this.schoolMonthEventList!.push(SchoolMonthEventDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolMonthEventResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolMonthEventResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schoolMonthEventList)) {
            data["schoolMonthEventList"] = [];
            for (let item of this.schoolMonthEventList)
                data["schoolMonthEventList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolMonthEventResponseDto {
        const json = this.toJSON();
        let result = new SchoolMonthEventResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolMonthEventResponseDto {
    schoolMonthEventList: SchoolMonthEventDto[] | undefined;
}

export class SchoolMonthEventDto implements ISchoolMonthEventDto {
    schoolEventId!: number;
    academicYearId!: number | undefined;
    classId!: string;
    gradeId!: number | undefined;
    gradeName!: string;
    divisionId!: number | undefined;
    divisionName!: string | undefined;
    eventTitle!: string;
    eventDescription!: string;
    eventFess!: string;
    eventVenue!: string;
    eventCoordinator!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    startTime!: moment.Moment | undefined;
    ngbStartTime!: SchoolNgbTimeModel | undefined;
    endTime!: moment.Moment | undefined;
    ngbEndTime!: SchoolNgbTimeModel | undefined;
    isCompulsory!: boolean;
    isPublished!: boolean;
    lstEventDetail!: OneMonthEventFileDetailsTeacherAppDto[];
    lstEventDate!: OneMonthEventDateTeacherAppDto[];

    constructor(data?: ISchoolMonthEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.academicYearId = _data["academicYearId"];
            this.classId = _data["classId"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.eventTitle = _data["eventTitle"];
            this.eventDescription = _data["eventDescription"];
            this.eventFess = _data["eventFess"];
            this.eventVenue = _data["eventVenue"];
            this.eventCoordinator = _data["eventCoordinator"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.ngbStartTime = _data["ngbStartTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbStartTime"]) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.ngbEndTime = _data["ngbEndTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbEndTime"]) : <any>undefined;
            this.isCompulsory = _data["isCompulsory"];
            this.isPublished = _data["isPublished"];
            if (Array.isArray(_data["lstEventDetail"])) {
                this.lstEventDetail = [] as any;
                for (let item of _data["lstEventDetail"])
                    this.lstEventDetail!.push(OneMonthEventFileDetailsTeacherAppDto.fromJS(item));
            }
            if (Array.isArray(_data["lstEventDate"])) {
                this.lstEventDate = [] as any;
                for (let item of _data["lstEventDate"])
                    this.lstEventDate!.push(OneMonthEventDateTeacherAppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolMonthEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolMonthEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["academicYearId"] = this.academicYearId;
        data["classId"] = this.classId;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["eventTitle"] = this.eventTitle;
        data["eventDescription"] = this.eventDescription;
        data["eventFess"] = this.eventFess;
        data["eventVenue"] = this.eventVenue;
        data["eventCoordinator"] = this.eventCoordinator;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["ngbStartTime"] = this.ngbStartTime ? this.ngbStartTime.toJSON() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["ngbEndTime"] = this.ngbEndTime ? this.ngbEndTime.toJSON() : <any>undefined;
        data["isCompulsory"] = this.isCompulsory;
        data["isPublished"] = this.isPublished;
        if (Array.isArray(this.lstEventDetail)) {
            data["lstEventDetail"] = [];
            for (let item of this.lstEventDetail)
                data["lstEventDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.lstEventDate)) {
            data["lstEventDate"] = [];
            for (let item of this.lstEventDate)
                data["lstEventDate"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolMonthEventDto {
        const json = this.toJSON();
        let result = new SchoolMonthEventDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolMonthEventDto {
    schoolEventId: number;
    academicYearId: number | undefined;
    classId: string;
    gradeId: number | undefined;
    gradeName: string;
    divisionId: number | undefined;
    divisionName: string | undefined;
    eventTitle: string;
    eventDescription: string;
    eventFess: string;
    eventVenue: string;
    eventCoordinator: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    startTime: moment.Moment | undefined;
    ngbStartTime: SchoolNgbTimeModel | undefined;
    endTime: moment.Moment | undefined;
    ngbEndTime: SchoolNgbTimeModel | undefined;
    isCompulsory: boolean;
    isPublished: boolean;
    lstEventDetail: OneMonthEventFileDetailsTeacherAppDto[];
    lstEventDate: OneMonthEventDateTeacherAppDto[];
}

export class OneMonthEventFileDetailsTeacherAppDto implements IOneMonthEventFileDetailsTeacherAppDto {
    schoolEventId!: number;
    schoolEventDetailsId!: number;
    fileName!: string;
    fullPath!: string;

    constructor(data?: IOneMonthEventFileDetailsTeacherAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.schoolEventDetailsId = _data["schoolEventDetailsId"];
            this.fileName = _data["fileName"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): OneMonthEventFileDetailsTeacherAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new OneMonthEventFileDetailsTeacherAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["schoolEventDetailsId"] = this.schoolEventDetailsId;
        data["fileName"] = this.fileName;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): OneMonthEventFileDetailsTeacherAppDto {
        const json = this.toJSON();
        let result = new OneMonthEventFileDetailsTeacherAppDto();
        result.init(json);
        return result;
    }
}

export interface IOneMonthEventFileDetailsTeacherAppDto {
    schoolEventId: number;
    schoolEventDetailsId: number;
    fileName: string;
    fullPath: string;
}

export class OneMonthEventDateTeacherAppDto implements IOneMonthEventDateTeacherAppDto {
    schoolEventId!: number;
    eventStartDate!: moment.Moment | undefined;
    eventEndDate!: moment.Moment | undefined;

    constructor(data?: IOneMonthEventDateTeacherAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.eventStartDate = _data["eventStartDate"] ? moment(_data["eventStartDate"].toString()) : <any>undefined;
            this.eventEndDate = _data["eventEndDate"] ? moment(_data["eventEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OneMonthEventDateTeacherAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new OneMonthEventDateTeacherAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["eventStartDate"] = this.eventStartDate ? this.eventStartDate.toISOString() : <any>undefined;
        data["eventEndDate"] = this.eventEndDate ? this.eventEndDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): OneMonthEventDateTeacherAppDto {
        const json = this.toJSON();
        let result = new OneMonthEventDateTeacherAppDto();
        result.init(json);
        return result;
    }
}

export interface IOneMonthEventDateTeacherAppDto {
    schoolEventId: number;
    eventStartDate: moment.Moment | undefined;
    eventEndDate: moment.Moment | undefined;
}

export class TeacherAttendanceHolidayResponseDto implements ITeacherAttendanceHolidayResponseDto {
    lstHoliday!: TeacherAttendanceHolidayDto[];
    lstWeeklyOff!: TeacherAttendanceWeeklyOffDto[];
    lstVacation!: TeacherAttendanceVacationDto[];

    constructor(data?: ITeacherAttendanceHolidayResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstHoliday"])) {
                this.lstHoliday = [] as any;
                for (let item of _data["lstHoliday"])
                    this.lstHoliday!.push(TeacherAttendanceHolidayDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeeklyOff"])) {
                this.lstWeeklyOff = [] as any;
                for (let item of _data["lstWeeklyOff"])
                    this.lstWeeklyOff!.push(TeacherAttendanceWeeklyOffDto.fromJS(item));
            }
            if (Array.isArray(_data["lstVacation"])) {
                this.lstVacation = [] as any;
                for (let item of _data["lstVacation"])
                    this.lstVacation!.push(TeacherAttendanceVacationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherAttendanceHolidayResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherAttendanceHolidayResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstHoliday)) {
            data["lstHoliday"] = [];
            for (let item of this.lstHoliday)
                data["lstHoliday"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeeklyOff)) {
            data["lstWeeklyOff"] = [];
            for (let item of this.lstWeeklyOff)
                data["lstWeeklyOff"].push(item.toJSON());
        }
        if (Array.isArray(this.lstVacation)) {
            data["lstVacation"] = [];
            for (let item of this.lstVacation)
                data["lstVacation"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeacherAttendanceHolidayResponseDto {
        const json = this.toJSON();
        let result = new TeacherAttendanceHolidayResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherAttendanceHolidayResponseDto {
    lstHoliday: TeacherAttendanceHolidayDto[];
    lstWeeklyOff: TeacherAttendanceWeeklyOffDto[];
    lstVacation: TeacherAttendanceVacationDto[];
}

export class TeacherAttendanceHolidayDto implements ITeacherAttendanceHolidayDto {
    schoolHolidayId!: number;
    calendarDate!: moment.Moment;
    holidayReason!: string;

    constructor(data?: ITeacherAttendanceHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolHolidayId = _data["schoolHolidayId"];
            this.calendarDate = _data["calendarDate"] ? moment(_data["calendarDate"].toString()) : <any>undefined;
            this.holidayReason = _data["holidayReason"];
        }
    }

    static fromJS(data: any): TeacherAttendanceHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherAttendanceHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolHolidayId"] = this.schoolHolidayId;
        data["calendarDate"] = this.calendarDate ? this.calendarDate.toISOString() : <any>undefined;
        data["holidayReason"] = this.holidayReason;
        return data;
    }

    clone(): TeacherAttendanceHolidayDto {
        const json = this.toJSON();
        let result = new TeacherAttendanceHolidayDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherAttendanceHolidayDto {
    schoolHolidayId: number;
    calendarDate: moment.Moment;
    holidayReason: string;
}

export class TeacherAttendanceWeeklyOffDto implements ITeacherAttendanceWeeklyOffDto {
    weeklyOffId!: number;
    dayNo!: string;

    constructor(data?: ITeacherAttendanceWeeklyOffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weeklyOffId = _data["weeklyOffId"];
            this.dayNo = _data["dayNo"];
        }
    }

    static fromJS(data: any): TeacherAttendanceWeeklyOffDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherAttendanceWeeklyOffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weeklyOffId"] = this.weeklyOffId;
        data["dayNo"] = this.dayNo;
        return data;
    }

    clone(): TeacherAttendanceWeeklyOffDto {
        const json = this.toJSON();
        let result = new TeacherAttendanceWeeklyOffDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherAttendanceWeeklyOffDto {
    weeklyOffId: number;
    dayNo: string;
}

export class TeacherAttendanceVacationDto implements ITeacherAttendanceVacationDto {
    schoolVacationId!: number | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    vacationName!: string;

    constructor(data?: ITeacherAttendanceVacationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolVacationId = _data["schoolVacationId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.vacationName = _data["vacationName"];
        }
    }

    static fromJS(data: any): TeacherAttendanceVacationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherAttendanceVacationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolVacationId"] = this.schoolVacationId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["vacationName"] = this.vacationName;
        return data;
    }

    clone(): TeacherAttendanceVacationDto {
        const json = this.toJSON();
        let result = new TeacherAttendanceVacationDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherAttendanceVacationDto {
    schoolVacationId: number | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    vacationName: string;
}

export class SurveyDto implements ISurveyDto {
    academicYearId!: number | undefined;
    surveyId!: number;
    surveyTitle!: string;
    surveyToType!: number | undefined;
    classId!: (number | undefined)[];
    studentId!: (number | undefined)[];
    teacherId!: (number | undefined)[];
    classTeacherId!: number | undefined;
    cabDriverId!: (number | undefined)[];
    clerkId!: (number | undefined)[];
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    status!: string;
    isPublished!: boolean;
    isImportant!: boolean;
    surveyDescription!: string;
    createdBy!: string;
    modifiedBy!: string;
    createdDate!: string;
    modifiedDate!: string;
    userId!: number;
    surveyTextFileArray!: SurveyFileDto[];
    surveyText!: SurveyQuestionDto[];

    constructor(data?: ISurveyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.surveyId = _data["surveyId"];
            this.surveyTitle = _data["surveyTitle"];
            this.surveyToType = _data["surveyToType"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
            if (Array.isArray(_data["studentId"])) {
                this.studentId = [] as any;
                for (let item of _data["studentId"])
                    this.studentId!.push(item);
            }
            if (Array.isArray(_data["teacherId"])) {
                this.teacherId = [] as any;
                for (let item of _data["teacherId"])
                    this.teacherId!.push(item);
            }
            this.classTeacherId = _data["classTeacherId"];
            if (Array.isArray(_data["cabDriverId"])) {
                this.cabDriverId = [] as any;
                for (let item of _data["cabDriverId"])
                    this.cabDriverId!.push(item);
            }
            if (Array.isArray(_data["clerkId"])) {
                this.clerkId = [] as any;
                for (let item of _data["clerkId"])
                    this.clerkId!.push(item);
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.status = _data["status"];
            this.isPublished = _data["isPublished"];
            this.isImportant = _data["isImportant"];
            this.surveyDescription = _data["surveyDescription"];
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["surveyTextFileArray"])) {
                this.surveyTextFileArray = [] as any;
                for (let item of _data["surveyTextFileArray"])
                    this.surveyTextFileArray!.push(SurveyFileDto.fromJS(item));
            }
            if (Array.isArray(_data["surveyText"])) {
                this.surveyText = [] as any;
                for (let item of _data["surveyText"])
                    this.surveyText!.push(SurveyQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SurveyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["surveyId"] = this.surveyId;
        data["surveyTitle"] = this.surveyTitle;
        data["surveyToType"] = this.surveyToType;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        if (Array.isArray(this.studentId)) {
            data["studentId"] = [];
            for (let item of this.studentId)
                data["studentId"].push(item);
        }
        if (Array.isArray(this.teacherId)) {
            data["teacherId"] = [];
            for (let item of this.teacherId)
                data["teacherId"].push(item);
        }
        data["classTeacherId"] = this.classTeacherId;
        if (Array.isArray(this.cabDriverId)) {
            data["cabDriverId"] = [];
            for (let item of this.cabDriverId)
                data["cabDriverId"].push(item);
        }
        if (Array.isArray(this.clerkId)) {
            data["clerkId"] = [];
            for (let item of this.clerkId)
                data["clerkId"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["isPublished"] = this.isPublished;
        data["isImportant"] = this.isImportant;
        data["surveyDescription"] = this.surveyDescription;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        data["userId"] = this.userId;
        if (Array.isArray(this.surveyTextFileArray)) {
            data["surveyTextFileArray"] = [];
            for (let item of this.surveyTextFileArray)
                data["surveyTextFileArray"].push(item.toJSON());
        }
        if (Array.isArray(this.surveyText)) {
            data["surveyText"] = [];
            for (let item of this.surveyText)
                data["surveyText"].push(item.toJSON());
        }
        return data;
    }

    clone(): SurveyDto {
        const json = this.toJSON();
        let result = new SurveyDto();
        result.init(json);
        return result;
    }
}

export interface ISurveyDto {
    academicYearId: number | undefined;
    surveyId: number;
    surveyTitle: string;
    surveyToType: number | undefined;
    classId: (number | undefined)[];
    studentId: (number | undefined)[];
    teacherId: (number | undefined)[];
    classTeacherId: number | undefined;
    cabDriverId: (number | undefined)[];
    clerkId: (number | undefined)[];
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    status: string;
    isPublished: boolean;
    isImportant: boolean;
    surveyDescription: string;
    createdBy: string;
    modifiedBy: string;
    createdDate: string;
    modifiedDate: string;
    userId: number;
    surveyTextFileArray: SurveyFileDto[];
    surveyText: SurveyQuestionDto[];
}

export class SurveyFileDto implements ISurveyFileDto {
    base64Image!: string;
    imageContentType!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: ISurveyFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64Image = _data["base64Image"];
            this.imageContentType = _data["imageContentType"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): SurveyFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64Image"] = this.base64Image;
        data["imageContentType"] = this.imageContentType;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): SurveyFileDto {
        const json = this.toJSON();
        let result = new SurveyFileDto();
        result.init(json);
        return result;
    }
}

export interface ISurveyFileDto {
    base64Image: string;
    imageContentType: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class SurveyQuestionDto implements ISurveyQuestionDto {
    surveyQuestions!: string;

    constructor(data?: ISurveyQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyQuestions = _data["surveyQuestions"];
        }
    }

    static fromJS(data: any): SurveyQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyQuestions"] = this.surveyQuestions;
        return data;
    }

    clone(): SurveyQuestionDto {
        const json = this.toJSON();
        let result = new SurveyQuestionDto();
        result.init(json);
        return result;
    }
}

export interface ISurveyQuestionDto {
    surveyQuestions: string;
}

export class PublishUnpublishSurveyDto implements IPublishUnpublishSurveyDto {
    surveyId!: number;
    isPublished!: boolean;

    constructor(data?: IPublishUnpublishSurveyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyId = _data["surveyId"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): PublishUnpublishSurveyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishUnpublishSurveyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyId"] = this.surveyId;
        data["isPublished"] = this.isPublished;
        return data;
    }

    clone(): PublishUnpublishSurveyDto {
        const json = this.toJSON();
        let result = new PublishUnpublishSurveyDto();
        result.init(json);
        return result;
    }
}

export interface IPublishUnpublishSurveyDto {
    surveyId: number;
    isPublished: boolean;
}

export class CommonDropdownSelectListItemResponseDto implements ICommonDropdownSelectListItemResponseDto {
    lstDropdownValues!: CommonDropdownSelectListItemDto[];

    constructor(data?: ICommonDropdownSelectListItemResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstDropdownValues"])) {
                this.lstDropdownValues = [] as any;
                for (let item of _data["lstDropdownValues"])
                    this.lstDropdownValues!.push(CommonDropdownSelectListItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommonDropdownSelectListItemResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonDropdownSelectListItemResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstDropdownValues)) {
            data["lstDropdownValues"] = [];
            for (let item of this.lstDropdownValues)
                data["lstDropdownValues"].push(item.toJSON());
        }
        return data;
    }

    clone(): CommonDropdownSelectListItemResponseDto {
        const json = this.toJSON();
        let result = new CommonDropdownSelectListItemResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICommonDropdownSelectListItemResponseDto {
    lstDropdownValues: CommonDropdownSelectListItemDto[];
}

export class CommonDropdownSelectListItemDto implements ICommonDropdownSelectListItemDto {
    id!: number;
    value!: string;

    constructor(data?: ICommonDropdownSelectListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CommonDropdownSelectListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonDropdownSelectListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }

    clone(): CommonDropdownSelectListItemDto {
        const json = this.toJSON();
        let result = new CommonDropdownSelectListItemDto();
        result.init(json);
        return result;
    }
}

export interface ICommonDropdownSelectListItemDto {
    id: number;
    value: string;
}

export class SubjectMasterDto implements ISubjectMasterDto {
    subjectMasterId!: number;
    subjectName!: string | undefined;

    constructor(data?: ISubjectMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectMasterId = _data["subjectMasterId"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): SubjectMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectMasterId"] = this.subjectMasterId;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): SubjectMasterDto {
        const json = this.toJSON();
        let result = new SubjectMasterDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMasterDto {
    subjectMasterId: number;
    subjectName: string | undefined;
}

export class SubjectMasterDeleteResponceDto implements ISubjectMasterDeleteResponceDto {
    affectedRows!: number;
    subjectMappingCount!: number;
    teacherSubjectMappingCount!: number;
    objectCount!: number;

    constructor(data?: ISubjectMasterDeleteResponceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
            this.subjectMappingCount = _data["subjectMappingCount"];
            this.teacherSubjectMappingCount = _data["teacherSubjectMappingCount"];
            this.objectCount = _data["objectCount"];
        }
    }

    static fromJS(data: any): SubjectMasterDeleteResponceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMasterDeleteResponceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        data["subjectMappingCount"] = this.subjectMappingCount;
        data["teacherSubjectMappingCount"] = this.teacherSubjectMappingCount;
        data["objectCount"] = this.objectCount;
        return data;
    }

    clone(): SubjectMasterDeleteResponceDto {
        const json = this.toJSON();
        let result = new SubjectMasterDeleteResponceDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMasterDeleteResponceDto {
    affectedRows: number;
    subjectMappingCount: number;
    teacherSubjectMappingCount: number;
    objectCount: number;
}

export class TimetableSubjectDropdownResponseDto implements ITimetableSubjectDropdownResponseDto {
    subjects!: TimetableSubjectDropdownDto[];

    constructor(data?: ITimetableSubjectDropdownResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(TimetableSubjectDropdownDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimetableSubjectDropdownResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimetableSubjectDropdownResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        return data;
    }

    clone(): TimetableSubjectDropdownResponseDto {
        const json = this.toJSON();
        let result = new TimetableSubjectDropdownResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITimetableSubjectDropdownResponseDto {
    subjects: TimetableSubjectDropdownDto[];
}

export class TimetableSubjectDropdownDto implements ITimetableSubjectDropdownDto {
    classId!: number;
    subjectId!: number;
    subjectName!: string;

    constructor(data?: ITimetableSubjectDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): TimetableSubjectDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimetableSubjectDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): TimetableSubjectDropdownDto {
        const json = this.toJSON();
        let result = new TimetableSubjectDropdownDto();
        result.init(json);
        return result;
    }
}

export interface ITimetableSubjectDropdownDto {
    classId: number;
    subjectId: number;
    subjectName: string;
}

export class TimetableSubjectDropdownRequestDto implements ITimetableSubjectDropdownRequestDto {
    lstClass!: number[];
    academicYearId!: number;

    constructor(data?: ITimetableSubjectDropdownRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstClass"])) {
                this.lstClass = [] as any;
                for (let item of _data["lstClass"])
                    this.lstClass!.push(item);
            }
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): TimetableSubjectDropdownRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimetableSubjectDropdownRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstClass)) {
            data["lstClass"] = [];
            for (let item of this.lstClass)
                data["lstClass"].push(item);
        }
        data["academicYearId"] = this.academicYearId;
        return data;
    }

    clone(): TimetableSubjectDropdownRequestDto {
        const json = this.toJSON();
        let result = new TimetableSubjectDropdownRequestDto();
        result.init(json);
        return result;
    }
}

export interface ITimetableSubjectDropdownRequestDto {
    lstClass: number[];
    academicYearId: number;
}

export class SubjectMappingUpsertDto implements ISubjectMappingUpsertDto {
    subjectExistResposeList!: SubjectExistResposeDto[];

    constructor(data?: ISubjectMappingUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subjectExistResposeList"])) {
                this.subjectExistResposeList = [] as any;
                for (let item of _data["subjectExistResposeList"])
                    this.subjectExistResposeList!.push(SubjectExistResposeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubjectMappingUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMappingUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subjectExistResposeList)) {
            data["subjectExistResposeList"] = [];
            for (let item of this.subjectExistResposeList)
                data["subjectExistResposeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubjectMappingUpsertDto {
        const json = this.toJSON();
        let result = new SubjectMappingUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMappingUpsertDto {
    subjectExistResposeList: SubjectExistResposeDto[];
}

export class SubjectExistResposeDto implements ISubjectExistResposeDto {
    subjectName!: string;
    existsInHomeWork!: number | undefined;
    existsInClassTimeTable!: number | undefined;
    success!: number;

    constructor(data?: ISubjectExistResposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectName = _data["subjectName"];
            this.existsInHomeWork = _data["existsInHomeWork"];
            this.existsInClassTimeTable = _data["existsInClassTimeTable"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): SubjectExistResposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectExistResposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectName"] = this.subjectName;
        data["existsInHomeWork"] = this.existsInHomeWork;
        data["existsInClassTimeTable"] = this.existsInClassTimeTable;
        data["success"] = this.success;
        return data;
    }

    clone(): SubjectExistResposeDto {
        const json = this.toJSON();
        let result = new SubjectExistResposeDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectExistResposeDto {
    subjectName: string;
    existsInHomeWork: number | undefined;
    existsInClassTimeTable: number | undefined;
    success: number;
}

export class SubjectMappingDto implements ISubjectMappingDto {
    classId!: number;
    subjectMappingId!: number;
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    status!: boolean;
    className!: string;
    subjectMasterIds!: string;
    userId!: number;
    subjectList!: number[];
    subjectDropdownList!: SubjectMasterDropdownDto[];

    constructor(data?: ISubjectMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.subjectMappingId = _data["subjectMappingId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.status = _data["status"];
            this.className = _data["className"];
            this.subjectMasterIds = _data["subjectMasterIds"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["subjectList"])) {
                this.subjectList = [] as any;
                for (let item of _data["subjectList"])
                    this.subjectList!.push(item);
            }
            if (Array.isArray(_data["subjectDropdownList"])) {
                this.subjectDropdownList = [] as any;
                for (let item of _data["subjectDropdownList"])
                    this.subjectDropdownList!.push(SubjectMasterDropdownDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubjectMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["subjectMappingId"] = this.subjectMappingId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["status"] = this.status;
        data["className"] = this.className;
        data["subjectMasterIds"] = this.subjectMasterIds;
        data["userId"] = this.userId;
        if (Array.isArray(this.subjectList)) {
            data["subjectList"] = [];
            for (let item of this.subjectList)
                data["subjectList"].push(item);
        }
        if (Array.isArray(this.subjectDropdownList)) {
            data["subjectDropdownList"] = [];
            for (let item of this.subjectDropdownList)
                data["subjectDropdownList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubjectMappingDto {
        const json = this.toJSON();
        let result = new SubjectMappingDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMappingDto {
    classId: number;
    subjectMappingId: number;
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    status: boolean;
    className: string;
    subjectMasterIds: string;
    userId: number;
    subjectList: number[];
    subjectDropdownList: SubjectMasterDropdownDto[];
}

export class SubjectMasterDropdownDto implements ISubjectMasterDropdownDto {
    subjectMasterId!: number;
    subjectName!: string;

    constructor(data?: ISubjectMasterDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectMasterId = _data["subjectMasterId"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): SubjectMasterDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMasterDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectMasterId"] = this.subjectMasterId;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): SubjectMasterDropdownDto {
        const json = this.toJSON();
        let result = new SubjectMasterDropdownDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMasterDropdownDto {
    subjectMasterId: number;
    subjectName: string;
}

export class SubjectIndexNumberDetailsDto implements ISubjectIndexNumberDetailsDto {
    academicYearId!: number;
    gradeId!: number;
    gradeName!: string;
    divisionId!: number;
    divisionName!: string;
    userId!: number | undefined;
    subjectMasterIndexList!: SubjectMasterIndexTypeDto[];

    constructor(data?: ISubjectIndexNumberDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["subjectMasterIndexList"])) {
                this.subjectMasterIndexList = [] as any;
                for (let item of _data["subjectMasterIndexList"])
                    this.subjectMasterIndexList!.push(SubjectMasterIndexTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubjectIndexNumberDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectIndexNumberDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["userId"] = this.userId;
        if (Array.isArray(this.subjectMasterIndexList)) {
            data["subjectMasterIndexList"] = [];
            for (let item of this.subjectMasterIndexList)
                data["subjectMasterIndexList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubjectIndexNumberDetailsDto {
        const json = this.toJSON();
        let result = new SubjectIndexNumberDetailsDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectIndexNumberDetailsDto {
    academicYearId: number;
    gradeId: number;
    gradeName: string;
    divisionId: number;
    divisionName: string;
    userId: number | undefined;
    subjectMasterIndexList: SubjectMasterIndexTypeDto[];
}

export class SubjectMasterIndexTypeDto implements ISubjectMasterIndexTypeDto {
    subjectMasterId!: number;
    indexNumber!: number;
    subjectName!: string;

    constructor(data?: ISubjectMasterIndexTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectMasterId = _data["subjectMasterId"];
            this.indexNumber = _data["indexNumber"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): SubjectMasterIndexTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMasterIndexTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectMasterId"] = this.subjectMasterId;
        data["indexNumber"] = this.indexNumber;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): SubjectMasterIndexTypeDto {
        const json = this.toJSON();
        let result = new SubjectMasterIndexTypeDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMasterIndexTypeDto {
    subjectMasterId: number;
    indexNumber: number;
    subjectName: string;
}

export class UpsertSubjectIndexNumberDetailsDto implements IUpsertSubjectIndexNumberDetailsDto {
    subjectMappingId!: number;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    userId!: number;
    subjectIndexNumbersListUpsert!: SubjectMasterIndexTypeDto[];

    constructor(data?: IUpsertSubjectIndexNumberDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectMappingId = _data["subjectMappingId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["subjectIndexNumbersListUpsert"])) {
                this.subjectIndexNumbersListUpsert = [] as any;
                for (let item of _data["subjectIndexNumbersListUpsert"])
                    this.subjectIndexNumbersListUpsert!.push(SubjectMasterIndexTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpsertSubjectIndexNumberDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertSubjectIndexNumberDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectMappingId"] = this.subjectMappingId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["userId"] = this.userId;
        if (Array.isArray(this.subjectIndexNumbersListUpsert)) {
            data["subjectIndexNumbersListUpsert"] = [];
            for (let item of this.subjectIndexNumbersListUpsert)
                data["subjectIndexNumbersListUpsert"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpsertSubjectIndexNumberDetailsDto {
        const json = this.toJSON();
        let result = new UpsertSubjectIndexNumberDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertSubjectIndexNumberDetailsDto {
    subjectMappingId: number;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    userId: number;
    subjectIndexNumbersListUpsert: SubjectMasterIndexTypeDto[];
}

export class SubjectMappingCloneDto implements ISubjectMappingCloneDto {
    fromClassId!: number;
    fromClassName!: string;
    toClassId!: number[];
    academicYearId!: number;

    constructor(data?: ISubjectMappingCloneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromClassId = _data["fromClassId"];
            this.fromClassName = _data["fromClassName"];
            if (Array.isArray(_data["toClassId"])) {
                this.toClassId = [] as any;
                for (let item of _data["toClassId"])
                    this.toClassId!.push(item);
            }
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): SubjectMappingCloneDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMappingCloneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromClassId"] = this.fromClassId;
        data["fromClassName"] = this.fromClassName;
        if (Array.isArray(this.toClassId)) {
            data["toClassId"] = [];
            for (let item of this.toClassId)
                data["toClassId"].push(item);
        }
        data["academicYearId"] = this.academicYearId;
        return data;
    }

    clone(): SubjectMappingCloneDto {
        const json = this.toJSON();
        let result = new SubjectMappingCloneDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMappingCloneDto {
    fromClassId: number;
    fromClassName: string;
    toClassId: number[];
    academicYearId: number;
}

export class GradeDivisionWithDisabledCommonMasterDto implements IGradeDivisionWithDisabledCommonMasterDto {
    schoolGradeDivisionMatrixCascadeList!: SchoolGradeDivisionMatrixWithDisabledDto[] | undefined;
    grades!: Grade[] | undefined;
    divisions!: CommonDivisionWithDisabled[] | undefined;

    constructor(data?: IGradeDivisionWithDisabledCommonMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["schoolGradeDivisionMatrixCascadeList"])) {
                this.schoolGradeDivisionMatrixCascadeList = [] as any;
                for (let item of _data["schoolGradeDivisionMatrixCascadeList"])
                    this.schoolGradeDivisionMatrixCascadeList!.push(SchoolGradeDivisionMatrixWithDisabledDto.fromJS(item));
            }
            if (Array.isArray(_data["grades"])) {
                this.grades = [] as any;
                for (let item of _data["grades"])
                    this.grades!.push(Grade.fromJS(item));
            }
            if (Array.isArray(_data["divisions"])) {
                this.divisions = [] as any;
                for (let item of _data["divisions"])
                    this.divisions!.push(CommonDivisionWithDisabled.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GradeDivisionWithDisabledCommonMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDivisionWithDisabledCommonMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schoolGradeDivisionMatrixCascadeList)) {
            data["schoolGradeDivisionMatrixCascadeList"] = [];
            for (let item of this.schoolGradeDivisionMatrixCascadeList)
                data["schoolGradeDivisionMatrixCascadeList"].push(item.toJSON());
        }
        if (Array.isArray(this.grades)) {
            data["grades"] = [];
            for (let item of this.grades)
                data["grades"].push(item.toJSON());
        }
        if (Array.isArray(this.divisions)) {
            data["divisions"] = [];
            for (let item of this.divisions)
                data["divisions"].push(item.toJSON());
        }
        return data;
    }

    clone(): GradeDivisionWithDisabledCommonMasterDto {
        const json = this.toJSON();
        let result = new GradeDivisionWithDisabledCommonMasterDto();
        result.init(json);
        return result;
    }
}

export interface IGradeDivisionWithDisabledCommonMasterDto {
    schoolGradeDivisionMatrixCascadeList: SchoolGradeDivisionMatrixWithDisabledDto[] | undefined;
    grades: Grade[] | undefined;
    divisions: CommonDivisionWithDisabled[] | undefined;
}

export class SchoolGradeDivisionMatrixWithDisabledDto implements ISchoolGradeDivisionMatrixWithDisabledDto {
    schoolGradeDivisionMatrixId!: number | undefined;
    className!: string;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    isAlreadyExist!: boolean | undefined;

    constructor(data?: ISchoolGradeDivisionMatrixWithDisabledDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolGradeDivisionMatrixId = _data["schoolGradeDivisionMatrixId"];
            this.className = _data["className"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.isAlreadyExist = _data["isAlreadyExist"];
        }
    }

    static fromJS(data: any): SchoolGradeDivisionMatrixWithDisabledDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolGradeDivisionMatrixWithDisabledDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolGradeDivisionMatrixId"] = this.schoolGradeDivisionMatrixId;
        data["className"] = this.className;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["isAlreadyExist"] = this.isAlreadyExist;
        return data;
    }

    clone(): SchoolGradeDivisionMatrixWithDisabledDto {
        const json = this.toJSON();
        let result = new SchoolGradeDivisionMatrixWithDisabledDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolGradeDivisionMatrixWithDisabledDto {
    schoolGradeDivisionMatrixId: number | undefined;
    className: string;
    gradeId: number | undefined;
    divisionId: number | undefined;
    isAlreadyExist: boolean | undefined;
}

export class Grade implements IGrade {
    gradeId!: number | undefined;
    gradeName!: string | undefined;

    constructor(data?: IGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
        }
    }

    static fromJS(data: any): Grade {
        data = typeof data === 'object' ? data : {};
        let result = new Grade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        return data;
    }

    clone(): Grade {
        const json = this.toJSON();
        let result = new Grade();
        result.init(json);
        return result;
    }
}

export interface IGrade {
    gradeId: number | undefined;
    gradeName: string | undefined;
}

export class CommonDivisionWithDisabled implements ICommonDivisionWithDisabled {
    divisionId!: number | undefined;
    divisionName!: string | undefined;
    disabled!: boolean;

    constructor(data?: ICommonDivisionWithDisabled) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.disabled = _data["disabled"];
        }
    }

    static fromJS(data: any): CommonDivisionWithDisabled {
        data = typeof data === 'object' ? data : {};
        let result = new CommonDivisionWithDisabled();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["disabled"] = this.disabled;
        return data;
    }

    clone(): CommonDivisionWithDisabled {
        const json = this.toJSON();
        let result = new CommonDivisionWithDisabled();
        result.init(json);
        return result;
    }
}

export interface ICommonDivisionWithDisabled {
    divisionId: number | undefined;
    divisionName: string | undefined;
    disabled: boolean;
}

export class CasteWiseStudentCountResponseDto implements ICasteWiseStudentCountResponseDto {
    castCountStudentList!: StudentReportDTO[] | undefined;

    constructor(data?: ICasteWiseStudentCountResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["castCountStudentList"])) {
                this.castCountStudentList = [] as any;
                for (let item of _data["castCountStudentList"])
                    this.castCountStudentList!.push(StudentReportDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CasteWiseStudentCountResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CasteWiseStudentCountResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.castCountStudentList)) {
            data["castCountStudentList"] = [];
            for (let item of this.castCountStudentList)
                data["castCountStudentList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CasteWiseStudentCountResponseDto {
        const json = this.toJSON();
        let result = new CasteWiseStudentCountResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICasteWiseStudentCountResponseDto {
    castCountStudentList: StudentReportDTO[] | undefined;
}

export class StudentReportDTO implements IStudentReportDTO {
    academicYearId!: number | undefined;
    class!: string | undefined;
    casteName!: string | undefined;
    formattedCasteName!: string | undefined;
    casteCount!: number | undefined;
    totalCount!: number | undefined;

    constructor(data?: IStudentReportDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.class = _data["class"];
            this.casteName = _data["casteName"];
            this.formattedCasteName = _data["formattedCasteName"];
            this.casteCount = _data["casteCount"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StudentReportDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentReportDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["class"] = this.class;
        data["casteName"] = this.casteName;
        data["formattedCasteName"] = this.formattedCasteName;
        data["casteCount"] = this.casteCount;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StudentReportDTO {
        const json = this.toJSON();
        let result = new StudentReportDTO();
        result.init(json);
        return result;
    }
}

export interface IStudentReportDTO {
    academicYearId: number | undefined;
    class: string | undefined;
    casteName: string | undefined;
    formattedCasteName: string | undefined;
    casteCount: number | undefined;
    totalCount: number | undefined;
}

export class RequestReportDto implements IRequestReportDto {
    academicYearId!: number | undefined;
    classIds!: number[] | undefined;

    constructor(data?: IRequestReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            if (Array.isArray(_data["classIds"])) {
                this.classIds = [] as any;
                for (let item of _data["classIds"])
                    this.classIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RequestReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        if (Array.isArray(this.classIds)) {
            data["classIds"] = [];
            for (let item of this.classIds)
                data["classIds"].push(item);
        }
        return data;
    }

    clone(): RequestReportDto {
        const json = this.toJSON();
        let result = new RequestReportDto();
        result.init(json);
        return result;
    }
}

export interface IRequestReportDto {
    academicYearId: number | undefined;
    classIds: number[] | undefined;
}

export class CategoryWiseStudentCountReportResponseDTO implements ICategoryWiseStudentCountReportResponseDTO {
    categoryCountList!: CategoryWiseStudentCountReportDTO[] | undefined;

    constructor(data?: ICategoryWiseStudentCountReportResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categoryCountList"])) {
                this.categoryCountList = [] as any;
                for (let item of _data["categoryCountList"])
                    this.categoryCountList!.push(CategoryWiseStudentCountReportDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryWiseStudentCountReportResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryWiseStudentCountReportResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categoryCountList)) {
            data["categoryCountList"] = [];
            for (let item of this.categoryCountList)
                data["categoryCountList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CategoryWiseStudentCountReportResponseDTO {
        const json = this.toJSON();
        let result = new CategoryWiseStudentCountReportResponseDTO();
        result.init(json);
        return result;
    }
}

export interface ICategoryWiseStudentCountReportResponseDTO {
    categoryCountList: CategoryWiseStudentCountReportDTO[] | undefined;
}

export class CategoryWiseStudentCountReportDTO implements ICategoryWiseStudentCountReportDTO {
    academicYearId!: number | undefined;
    class!: string | undefined;
    categoryName!: string | undefined;
    categoryCount!: number | undefined;
    totalCount!: number | undefined;

    constructor(data?: ICategoryWiseStudentCountReportDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.class = _data["class"];
            this.categoryName = _data["categoryName"];
            this.categoryCount = _data["categoryCount"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CategoryWiseStudentCountReportDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryWiseStudentCountReportDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["class"] = this.class;
        data["categoryName"] = this.categoryName;
        data["categoryCount"] = this.categoryCount;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CategoryWiseStudentCountReportDTO {
        const json = this.toJSON();
        let result = new CategoryWiseStudentCountReportDTO();
        result.init(json);
        return result;
    }
}

export interface ICategoryWiseStudentCountReportDTO {
    academicYearId: number | undefined;
    class: string | undefined;
    categoryName: string | undefined;
    categoryCount: number | undefined;
    totalCount: number | undefined;
}

export class ReligionWiseStudentCountReporResponsetDTO implements IReligionWiseStudentCountReporResponsetDTO {
    religionCountList!: ReligionWiseStudentCountReportDTO[] | undefined;

    constructor(data?: IReligionWiseStudentCountReporResponsetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["religionCountList"])) {
                this.religionCountList = [] as any;
                for (let item of _data["religionCountList"])
                    this.religionCountList!.push(ReligionWiseStudentCountReportDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReligionWiseStudentCountReporResponsetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReligionWiseStudentCountReporResponsetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.religionCountList)) {
            data["religionCountList"] = [];
            for (let item of this.religionCountList)
                data["religionCountList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReligionWiseStudentCountReporResponsetDTO {
        const json = this.toJSON();
        let result = new ReligionWiseStudentCountReporResponsetDTO();
        result.init(json);
        return result;
    }
}

export interface IReligionWiseStudentCountReporResponsetDTO {
    religionCountList: ReligionWiseStudentCountReportDTO[] | undefined;
}

export class ReligionWiseStudentCountReportDTO implements IReligionWiseStudentCountReportDTO {
    academicYearId!: number | undefined;
    class!: string | undefined;
    religionName!: string | undefined;
    religionCount!: number | undefined;
    totalCount!: number | undefined;

    constructor(data?: IReligionWiseStudentCountReportDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.class = _data["class"];
            this.religionName = _data["religionName"];
            this.religionCount = _data["religionCount"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReligionWiseStudentCountReportDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReligionWiseStudentCountReportDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["class"] = this.class;
        data["religionName"] = this.religionName;
        data["religionCount"] = this.religionCount;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReligionWiseStudentCountReportDTO {
        const json = this.toJSON();
        let result = new ReligionWiseStudentCountReportDTO();
        result.init(json);
        return result;
    }
}

export interface IReligionWiseStudentCountReportDTO {
    academicYearId: number | undefined;
    class: string | undefined;
    religionName: string | undefined;
    religionCount: number | undefined;
    totalCount: number | undefined;
}

export class RTEStudentCountReportResponseDto implements IRTEStudentCountReportResponseDto {
    rteCountList!: RTEStudentCountReportDTO[] | undefined;

    constructor(data?: IRTEStudentCountReportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rteCountList"])) {
                this.rteCountList = [] as any;
                for (let item of _data["rteCountList"])
                    this.rteCountList!.push(RTEStudentCountReportDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RTEStudentCountReportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new RTEStudentCountReportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rteCountList)) {
            data["rteCountList"] = [];
            for (let item of this.rteCountList)
                data["rteCountList"].push(item.toJSON());
        }
        return data;
    }

    clone(): RTEStudentCountReportResponseDto {
        const json = this.toJSON();
        let result = new RTEStudentCountReportResponseDto();
        result.init(json);
        return result;
    }
}

export interface IRTEStudentCountReportResponseDto {
    rteCountList: RTEStudentCountReportDTO[] | undefined;
}

export class RTEStudentCountReportDTO implements IRTEStudentCountReportDTO {
    academicYearId!: number | undefined;
    class!: string | undefined;
    boysCount!: number | undefined;
    girlsCount!: number | undefined;
    studentCount!: number | undefined;
    rteCount!: number | undefined;
    rteBoysCount!: number | undefined;
    rteGirlsCount!: number | undefined;

    constructor(data?: IRTEStudentCountReportDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.class = _data["class"];
            this.boysCount = _data["boysCount"];
            this.girlsCount = _data["girlsCount"];
            this.studentCount = _data["studentCount"];
            this.rteCount = _data["rteCount"];
            this.rteBoysCount = _data["rteBoysCount"];
            this.rteGirlsCount = _data["rteGirlsCount"];
        }
    }

    static fromJS(data: any): RTEStudentCountReportDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RTEStudentCountReportDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["class"] = this.class;
        data["boysCount"] = this.boysCount;
        data["girlsCount"] = this.girlsCount;
        data["studentCount"] = this.studentCount;
        data["rteCount"] = this.rteCount;
        data["rteBoysCount"] = this.rteBoysCount;
        data["rteGirlsCount"] = this.rteGirlsCount;
        return data;
    }

    clone(): RTEStudentCountReportDTO {
        const json = this.toJSON();
        let result = new RTEStudentCountReportDTO();
        result.init(json);
        return result;
    }
}

export interface IRTEStudentCountReportDTO {
    academicYearId: number | undefined;
    class: string | undefined;
    boysCount: number | undefined;
    girlsCount: number | undefined;
    studentCount: number | undefined;
    rteCount: number | undefined;
    rteBoysCount: number | undefined;
    rteGirlsCount: number | undefined;
}

export class StudentGenderCountReportResponseDto implements IStudentGenderCountReportResponseDto {
    studentountList!: StudentGenderCountReportDto[] | undefined;

    constructor(data?: IStudentGenderCountReportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentountList"])) {
                this.studentountList = [] as any;
                for (let item of _data["studentountList"])
                    this.studentountList!.push(StudentGenderCountReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentGenderCountReportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentGenderCountReportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentountList)) {
            data["studentountList"] = [];
            for (let item of this.studentountList)
                data["studentountList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentGenderCountReportResponseDto {
        const json = this.toJSON();
        let result = new StudentGenderCountReportResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStudentGenderCountReportResponseDto {
    studentountList: StudentGenderCountReportDto[] | undefined;
}

export class StudentGenderCountReportDto implements IStudentGenderCountReportDto {
    academicYearId!: number | undefined;
    class!: string | undefined;
    girlsCount!: number | undefined;
    boysCount!: number | undefined;
    totalCount!: number | undefined;

    constructor(data?: IStudentGenderCountReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.class = _data["class"];
            this.girlsCount = _data["girlsCount"];
            this.boysCount = _data["boysCount"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StudentGenderCountReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentGenderCountReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["class"] = this.class;
        data["girlsCount"] = this.girlsCount;
        data["boysCount"] = this.boysCount;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StudentGenderCountReportDto {
        const json = this.toJSON();
        let result = new StudentGenderCountReportDto();
        result.init(json);
        return result;
    }
}

export interface IStudentGenderCountReportDto {
    academicYearId: number | undefined;
    class: string | undefined;
    girlsCount: number | undefined;
    boysCount: number | undefined;
    totalCount: number | undefined;
}

export class StudentGenderListResponseDto implements IStudentGenderListResponseDto {
    studentGenderList!: StudentGenderListDto[] | undefined;

    constructor(data?: IStudentGenderListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentGenderList"])) {
                this.studentGenderList = [] as any;
                for (let item of _data["studentGenderList"])
                    this.studentGenderList!.push(StudentGenderListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentGenderListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentGenderListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentGenderList)) {
            data["studentGenderList"] = [];
            for (let item of this.studentGenderList)
                data["studentGenderList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentGenderListResponseDto {
        const json = this.toJSON();
        let result = new StudentGenderListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStudentGenderListResponseDto {
    studentGenderList: StudentGenderListDto[] | undefined;
}

export class StudentGenderListDto implements IStudentGenderListDto {
    class!: string | undefined;
    studentName!: string | undefined;
    girls!: number | undefined;
    boys!: number | undefined;
    gender!: string | undefined;

    constructor(data?: IStudentGenderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.class = _data["class"];
            this.studentName = _data["studentName"];
            this.girls = _data["girls"];
            this.boys = _data["boys"];
            this.gender = _data["gender"];
        }
    }

    static fromJS(data: any): StudentGenderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentGenderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["class"] = this.class;
        data["studentName"] = this.studentName;
        data["girls"] = this.girls;
        data["boys"] = this.boys;
        data["gender"] = this.gender;
        return data;
    }

    clone(): StudentGenderListDto {
        const json = this.toJSON();
        let result = new StudentGenderListDto();
        result.init(json);
        return result;
    }
}

export interface IStudentGenderListDto {
    class: string | undefined;
    studentName: string | undefined;
    girls: number | undefined;
    boys: number | undefined;
    gender: string | undefined;
}

export class StudentRTEGenderListResponseDto implements IStudentRTEGenderListResponseDto {
    rteStudentGenderList!: StudentRTEGenderListDto[] | undefined;

    constructor(data?: IStudentRTEGenderListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rteStudentGenderList"])) {
                this.rteStudentGenderList = [] as any;
                for (let item of _data["rteStudentGenderList"])
                    this.rteStudentGenderList!.push(StudentRTEGenderListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentRTEGenderListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentRTEGenderListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rteStudentGenderList)) {
            data["rteStudentGenderList"] = [];
            for (let item of this.rteStudentGenderList)
                data["rteStudentGenderList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentRTEGenderListResponseDto {
        const json = this.toJSON();
        let result = new StudentRTEGenderListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStudentRTEGenderListResponseDto {
    rteStudentGenderList: StudentRTEGenderListDto[] | undefined;
}

export class StudentRTEGenderListDto implements IStudentRTEGenderListDto {
    class!: string | undefined;
    studentName!: string | undefined;
    girls!: number | undefined;
    boys!: number | undefined;
    gender!: string | undefined;

    constructor(data?: IStudentRTEGenderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.class = _data["class"];
            this.studentName = _data["studentName"];
            this.girls = _data["girls"];
            this.boys = _data["boys"];
            this.gender = _data["gender"];
        }
    }

    static fromJS(data: any): StudentRTEGenderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentRTEGenderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["class"] = this.class;
        data["studentName"] = this.studentName;
        data["girls"] = this.girls;
        data["boys"] = this.boys;
        data["gender"] = this.gender;
        return data;
    }

    clone(): StudentRTEGenderListDto {
        const json = this.toJSON();
        let result = new StudentRTEGenderListDto();
        result.init(json);
        return result;
    }
}

export interface IStudentRTEGenderListDto {
    class: string | undefined;
    studentName: string | undefined;
    girls: number | undefined;
    boys: number | undefined;
    gender: string | undefined;
}

export class StudentAllFeeReceiptSelectDto implements IStudentAllFeeReceiptSelectDto {
    fullName!: string | undefined;
    generalRegistrationNo!: string | undefined;
    isNewStudent!: boolean;
    studentId!: number;
    isRteStudent!: boolean | undefined;
    emergencyContactNumber!: string | undefined;
    academicYearId!: number | undefined;
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: number;
    studentFeeReceiptList!: StudentFeeReceiptDto[] | undefined;

    constructor(data?: IStudentAllFeeReceiptSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.isNewStudent = _data["isNewStudent"];
            this.studentId = _data["studentId"];
            this.isRteStudent = _data["isRteStudent"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.academicYearId = _data["academicYearId"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            if (Array.isArray(_data["studentFeeReceiptList"])) {
                this.studentFeeReceiptList = [] as any;
                for (let item of _data["studentFeeReceiptList"])
                    this.studentFeeReceiptList!.push(StudentFeeReceiptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentAllFeeReceiptSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAllFeeReceiptSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["isNewStudent"] = this.isNewStudent;
        data["studentId"] = this.studentId;
        data["isRteStudent"] = this.isRteStudent;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["academicYearId"] = this.academicYearId;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        if (Array.isArray(this.studentFeeReceiptList)) {
            data["studentFeeReceiptList"] = [];
            for (let item of this.studentFeeReceiptList)
                data["studentFeeReceiptList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentAllFeeReceiptSelectDto {
        const json = this.toJSON();
        let result = new StudentAllFeeReceiptSelectDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAllFeeReceiptSelectDto {
    fullName: string | undefined;
    generalRegistrationNo: string | undefined;
    isNewStudent: boolean;
    studentId: number;
    isRteStudent: boolean | undefined;
    emergencyContactNumber: string | undefined;
    academicYearId: number | undefined;
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: number;
    studentFeeReceiptList: StudentFeeReceiptDto[] | undefined;
}

export class StudentFeeReceiptDto implements IStudentFeeReceiptDto {
    receiptType!: string | undefined;
    receiptId!: number;
    invoiceNumber!: string | undefined;
    onlineTransactionDateTime!: moment.Moment;
    paidAmount!: number;
    paymentType!: string | undefined;
    chequeDate!: moment.Moment;
    isChequeClear!: boolean;
    transactionId!: string | undefined;
    transportConsumerStoppageMappingId!: number | undefined;

    constructor(data?: IStudentFeeReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiptType = _data["receiptType"];
            this.receiptId = _data["receiptId"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"] ? moment(_data["onlineTransactionDateTime"].toString()) : <any>undefined;
            this.paidAmount = _data["paidAmount"];
            this.paymentType = _data["paymentType"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.isChequeClear = _data["isChequeClear"];
            this.transactionId = _data["transactionId"];
            this.transportConsumerStoppageMappingId = _data["transportConsumerStoppageMappingId"];
        }
    }

    static fromJS(data: any): StudentFeeReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentFeeReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiptType"] = this.receiptType;
        data["receiptId"] = this.receiptId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime ? this.onlineTransactionDateTime.toISOString() : <any>undefined;
        data["paidAmount"] = this.paidAmount;
        data["paymentType"] = this.paymentType;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["isChequeClear"] = this.isChequeClear;
        data["transactionId"] = this.transactionId;
        data["transportConsumerStoppageMappingId"] = this.transportConsumerStoppageMappingId;
        return data;
    }

    clone(): StudentFeeReceiptDto {
        const json = this.toJSON();
        let result = new StudentFeeReceiptDto();
        result.init(json);
        return result;
    }
}

export interface IStudentFeeReceiptDto {
    receiptType: string | undefined;
    receiptId: number;
    invoiceNumber: string | undefined;
    onlineTransactionDateTime: moment.Moment;
    paidAmount: number;
    paymentType: string | undefined;
    chequeDate: moment.Moment;
    isChequeClear: boolean;
    transactionId: string | undefined;
    transportConsumerStoppageMappingId: number | undefined;
}

export class StudentNameList implements IStudentNameList {
    studentNames!: StudentListDto[];

    constructor(data?: IStudentNameList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentNames"])) {
                this.studentNames = [] as any;
                for (let item of _data["studentNames"])
                    this.studentNames!.push(StudentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentNameList {
        data = typeof data === 'object' ? data : {};
        let result = new StudentNameList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentNames)) {
            data["studentNames"] = [];
            for (let item of this.studentNames)
                data["studentNames"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentNameList {
        const json = this.toJSON();
        let result = new StudentNameList();
        result.init(json);
        return result;
    }
}

export interface IStudentNameList {
    studentNames: StudentListDto[];
}

export class StudentListDto implements IStudentListDto {
    studentId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    academicYearId!: number | undefined;
    fullName!: string | undefined;

    constructor(data?: IStudentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): StudentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): StudentListDto {
        const json = this.toJSON();
        let result = new StudentListDto();
        result.init(json);
        return result;
    }
}

export interface IStudentListDto {
    studentId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    academicYearId: number | undefined;
    fullName: string | undefined;
}

export class StudentDto implements IStudentDto {
    studentId!: number | undefined;
    classId!: number | undefined;
    generalRegistrationNo!: string | undefined;
    cbscStudentId!: string | undefined;
    admissionNo!: string | undefined;
    schoolId!: number | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    fullName!: string | undefined;
    gender!: string | undefined;
    adharNo!: string | undefined;
    religion!: string | undefined;
    category!: string | undefined;
    cast!: string | undefined;
    subCast!: string | undefined;
    nationality!: string | undefined;
    motherTounge!: string | undefined;
    emergencyContactPersonName!: string | undefined;
    emergencyContactNumber!: string | undefined;
    familyDoctorName!: string | undefined;
    familyDoctorContactNumber!: string | undefined;
    birthPlace!: string | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthDate!: moment.Moment | undefined;
    birthDateInWords!: string | undefined;
    birthCountryId!: number | undefined;
    birthCountryName!: string | undefined;
    birthStateId!: number | undefined;
    birthStateName!: string | undefined;
    birthDistrictId!: number | undefined;
    birthDistrictName!: string | undefined;
    birthTalukaId!: number | undefined;
    birthTalukaName!: string | undefined;
    currentAddressLine1!: string | undefined;
    currentAddressLine2!: string | undefined;
    currentCountryId!: number | undefined;
    currentCountryName!: string | undefined;
    currentStateId!: number | undefined;
    currentStateName!: string | undefined;
    currentDistrictId!: number | undefined;
    currentDistrictName!: string | undefined;
    currentTalukaId!: number | undefined;
    currentTalukaName!: string | undefined;
    currentZipcode!: string | undefined;
    bloodGroup!: string | undefined;
    height!: string | undefined;
    weight!: string | undefined;
    medicalHistory!: string | undefined;
    admissionGrade!: string | undefined;
    ngbDateOfAdmission!: SchoolNgbDateModel | undefined;
    dateOfAdmission!: moment.Moment | undefined;
    lastSchoolAttended!: string | undefined;
    lastSchoolStandard!: string | undefined;
    lastSchoolDivision!: string | undefined;
    progressNoteFromLastSchool!: string | undefined;
    conductNoteFromLastSchool!: string | undefined;
    standardInWhichLastStudyingSection!: string | undefined;
    sinceWhenStudyingInLastSchool!: string | undefined;
    reasonOfLeavingSchoolLastSchool!: string | undefined;
    ngbDateOfLeavingLastSchool!: SchoolNgbDateModel | undefined;
    dateOfLeavingLastSchool!: moment.Moment | undefined;
    remarkFromLastSchool!: string | undefined;
    profileImageURL!: string | undefined;
    academicYearId!: number | undefined;
    gradeId!: number | undefined;
    gradeName!: string | undefined;
    divisionId!: number | undefined;
    divisionName!: string | undefined;
    gradeNameAdmission!: string | undefined;
    fatherFullName!: string | undefined;
    fatherMobileNo!: string | undefined;
    fatherId!: number | undefined;
    motherId!: number | undefined;
    guardianId!: number | undefined;
    rollNumber!: string | undefined;
    isNewStudent!: boolean | undefined;
    isRTEStudent!: boolean | undefined;
    isConsationApplicable!: boolean | undefined;
    consationAmount!: number | undefined;
    isArchive!: boolean | undefined;
    profileBase64Image!: string | undefined;
    profileImageContentType!: string | undefined;
    isAppAccess!: boolean | undefined;
    appAccessMobileNo!: string | undefined;
    appAccessOneTimePassword!: string | undefined;
    previousAcademicYearPendingFeeAmount!: number | undefined;

    constructor(data?: IStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.classId = _data["classId"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.cbscStudentId = _data["cbscStudentId"];
            this.admissionNo = _data["admissionNo"];
            this.schoolId = _data["schoolId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.adharNo = _data["adharNo"];
            this.religion = _data["religion"];
            this.category = _data["category"];
            this.cast = _data["cast"];
            this.subCast = _data["subCast"];
            this.nationality = _data["nationality"];
            this.motherTounge = _data["motherTounge"];
            this.emergencyContactPersonName = _data["emergencyContactPersonName"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.familyDoctorName = _data["familyDoctorName"];
            this.familyDoctorContactNumber = _data["familyDoctorContactNumber"];
            this.birthPlace = _data["birthPlace"];
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.birthDateInWords = _data["birthDateInWords"];
            this.birthCountryId = _data["birthCountryId"];
            this.birthCountryName = _data["birthCountryName"];
            this.birthStateId = _data["birthStateId"];
            this.birthStateName = _data["birthStateName"];
            this.birthDistrictId = _data["birthDistrictId"];
            this.birthDistrictName = _data["birthDistrictName"];
            this.birthTalukaId = _data["birthTalukaId"];
            this.birthTalukaName = _data["birthTalukaName"];
            this.currentAddressLine1 = _data["currentAddressLine1"];
            this.currentAddressLine2 = _data["currentAddressLine2"];
            this.currentCountryId = _data["currentCountryId"];
            this.currentCountryName = _data["currentCountryName"];
            this.currentStateId = _data["currentStateId"];
            this.currentStateName = _data["currentStateName"];
            this.currentDistrictId = _data["currentDistrictId"];
            this.currentDistrictName = _data["currentDistrictName"];
            this.currentTalukaId = _data["currentTalukaId"];
            this.currentTalukaName = _data["currentTalukaName"];
            this.currentZipcode = _data["currentZipcode"];
            this.bloodGroup = _data["bloodGroup"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.medicalHistory = _data["medicalHistory"];
            this.admissionGrade = _data["admissionGrade"];
            this.ngbDateOfAdmission = _data["ngbDateOfAdmission"] ? SchoolNgbDateModel.fromJS(_data["ngbDateOfAdmission"]) : <any>undefined;
            this.dateOfAdmission = _data["dateOfAdmission"] ? moment(_data["dateOfAdmission"].toString()) : <any>undefined;
            this.lastSchoolAttended = _data["lastSchoolAttended"];
            this.lastSchoolStandard = _data["lastSchoolStandard"];
            this.lastSchoolDivision = _data["lastSchoolDivision"];
            this.progressNoteFromLastSchool = _data["progressNoteFromLastSchool"];
            this.conductNoteFromLastSchool = _data["conductNoteFromLastSchool"];
            this.standardInWhichLastStudyingSection = _data["standardInWhichLastStudyingSection"];
            this.sinceWhenStudyingInLastSchool = _data["sinceWhenStudyingInLastSchool"];
            this.reasonOfLeavingSchoolLastSchool = _data["reasonOfLeavingSchoolLastSchool"];
            this.ngbDateOfLeavingLastSchool = _data["ngbDateOfLeavingLastSchool"] ? SchoolNgbDateModel.fromJS(_data["ngbDateOfLeavingLastSchool"]) : <any>undefined;
            this.dateOfLeavingLastSchool = _data["dateOfLeavingLastSchool"] ? moment(_data["dateOfLeavingLastSchool"].toString()) : <any>undefined;
            this.remarkFromLastSchool = _data["remarkFromLastSchool"];
            this.profileImageURL = _data["profileImageURL"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.gradeNameAdmission = _data["gradeNameAdmission"];
            this.fatherFullName = _data["fatherFullName"];
            this.fatherMobileNo = _data["fatherMobileNo"];
            this.fatherId = _data["fatherId"];
            this.motherId = _data["motherId"];
            this.guardianId = _data["guardianId"];
            this.rollNumber = _data["rollNumber"];
            this.isNewStudent = _data["isNewStudent"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isConsationApplicable = _data["isConsationApplicable"];
            this.consationAmount = _data["consationAmount"];
            this.isArchive = _data["isArchive"];
            this.profileBase64Image = _data["profileBase64Image"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.isAppAccess = _data["isAppAccess"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.appAccessOneTimePassword = _data["appAccessOneTimePassword"];
            this.previousAcademicYearPendingFeeAmount = _data["previousAcademicYearPendingFeeAmount"];
        }
    }

    static fromJS(data: any): StudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["classId"] = this.classId;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["cbscStudentId"] = this.cbscStudentId;
        data["admissionNo"] = this.admissionNo;
        data["schoolId"] = this.schoolId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["adharNo"] = this.adharNo;
        data["religion"] = this.religion;
        data["category"] = this.category;
        data["cast"] = this.cast;
        data["subCast"] = this.subCast;
        data["nationality"] = this.nationality;
        data["motherTounge"] = this.motherTounge;
        data["emergencyContactPersonName"] = this.emergencyContactPersonName;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["familyDoctorName"] = this.familyDoctorName;
        data["familyDoctorContactNumber"] = this.familyDoctorContactNumber;
        data["birthPlace"] = this.birthPlace;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["birthDateInWords"] = this.birthDateInWords;
        data["birthCountryId"] = this.birthCountryId;
        data["birthCountryName"] = this.birthCountryName;
        data["birthStateId"] = this.birthStateId;
        data["birthStateName"] = this.birthStateName;
        data["birthDistrictId"] = this.birthDistrictId;
        data["birthDistrictName"] = this.birthDistrictName;
        data["birthTalukaId"] = this.birthTalukaId;
        data["birthTalukaName"] = this.birthTalukaName;
        data["currentAddressLine1"] = this.currentAddressLine1;
        data["currentAddressLine2"] = this.currentAddressLine2;
        data["currentCountryId"] = this.currentCountryId;
        data["currentCountryName"] = this.currentCountryName;
        data["currentStateId"] = this.currentStateId;
        data["currentStateName"] = this.currentStateName;
        data["currentDistrictId"] = this.currentDistrictId;
        data["currentDistrictName"] = this.currentDistrictName;
        data["currentTalukaId"] = this.currentTalukaId;
        data["currentTalukaName"] = this.currentTalukaName;
        data["currentZipcode"] = this.currentZipcode;
        data["bloodGroup"] = this.bloodGroup;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["medicalHistory"] = this.medicalHistory;
        data["admissionGrade"] = this.admissionGrade;
        data["ngbDateOfAdmission"] = this.ngbDateOfAdmission ? this.ngbDateOfAdmission.toJSON() : <any>undefined;
        data["dateOfAdmission"] = this.dateOfAdmission ? this.dateOfAdmission.toISOString() : <any>undefined;
        data["lastSchoolAttended"] = this.lastSchoolAttended;
        data["lastSchoolStandard"] = this.lastSchoolStandard;
        data["lastSchoolDivision"] = this.lastSchoolDivision;
        data["progressNoteFromLastSchool"] = this.progressNoteFromLastSchool;
        data["conductNoteFromLastSchool"] = this.conductNoteFromLastSchool;
        data["standardInWhichLastStudyingSection"] = this.standardInWhichLastStudyingSection;
        data["sinceWhenStudyingInLastSchool"] = this.sinceWhenStudyingInLastSchool;
        data["reasonOfLeavingSchoolLastSchool"] = this.reasonOfLeavingSchoolLastSchool;
        data["ngbDateOfLeavingLastSchool"] = this.ngbDateOfLeavingLastSchool ? this.ngbDateOfLeavingLastSchool.toJSON() : <any>undefined;
        data["dateOfLeavingLastSchool"] = this.dateOfLeavingLastSchool ? this.dateOfLeavingLastSchool.toISOString() : <any>undefined;
        data["remarkFromLastSchool"] = this.remarkFromLastSchool;
        data["profileImageURL"] = this.profileImageURL;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["gradeNameAdmission"] = this.gradeNameAdmission;
        data["fatherFullName"] = this.fatherFullName;
        data["fatherMobileNo"] = this.fatherMobileNo;
        data["fatherId"] = this.fatherId;
        data["motherId"] = this.motherId;
        data["guardianId"] = this.guardianId;
        data["rollNumber"] = this.rollNumber;
        data["isNewStudent"] = this.isNewStudent;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isConsationApplicable"] = this.isConsationApplicable;
        data["consationAmount"] = this.consationAmount;
        data["isArchive"] = this.isArchive;
        data["profileBase64Image"] = this.profileBase64Image;
        data["profileImageContentType"] = this.profileImageContentType;
        data["isAppAccess"] = this.isAppAccess;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["appAccessOneTimePassword"] = this.appAccessOneTimePassword;
        data["previousAcademicYearPendingFeeAmount"] = this.previousAcademicYearPendingFeeAmount;
        return data;
    }

    clone(): StudentDto {
        const json = this.toJSON();
        let result = new StudentDto();
        result.init(json);
        return result;
    }
}

export interface IStudentDto {
    studentId: number | undefined;
    classId: number | undefined;
    generalRegistrationNo: string | undefined;
    cbscStudentId: string | undefined;
    admissionNo: string | undefined;
    schoolId: number | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    gender: string | undefined;
    adharNo: string | undefined;
    religion: string | undefined;
    category: string | undefined;
    cast: string | undefined;
    subCast: string | undefined;
    nationality: string | undefined;
    motherTounge: string | undefined;
    emergencyContactPersonName: string | undefined;
    emergencyContactNumber: string | undefined;
    familyDoctorName: string | undefined;
    familyDoctorContactNumber: string | undefined;
    birthPlace: string | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthDate: moment.Moment | undefined;
    birthDateInWords: string | undefined;
    birthCountryId: number | undefined;
    birthCountryName: string | undefined;
    birthStateId: number | undefined;
    birthStateName: string | undefined;
    birthDistrictId: number | undefined;
    birthDistrictName: string | undefined;
    birthTalukaId: number | undefined;
    birthTalukaName: string | undefined;
    currentAddressLine1: string | undefined;
    currentAddressLine2: string | undefined;
    currentCountryId: number | undefined;
    currentCountryName: string | undefined;
    currentStateId: number | undefined;
    currentStateName: string | undefined;
    currentDistrictId: number | undefined;
    currentDistrictName: string | undefined;
    currentTalukaId: number | undefined;
    currentTalukaName: string | undefined;
    currentZipcode: string | undefined;
    bloodGroup: string | undefined;
    height: string | undefined;
    weight: string | undefined;
    medicalHistory: string | undefined;
    admissionGrade: string | undefined;
    ngbDateOfAdmission: SchoolNgbDateModel | undefined;
    dateOfAdmission: moment.Moment | undefined;
    lastSchoolAttended: string | undefined;
    lastSchoolStandard: string | undefined;
    lastSchoolDivision: string | undefined;
    progressNoteFromLastSchool: string | undefined;
    conductNoteFromLastSchool: string | undefined;
    standardInWhichLastStudyingSection: string | undefined;
    sinceWhenStudyingInLastSchool: string | undefined;
    reasonOfLeavingSchoolLastSchool: string | undefined;
    ngbDateOfLeavingLastSchool: SchoolNgbDateModel | undefined;
    dateOfLeavingLastSchool: moment.Moment | undefined;
    remarkFromLastSchool: string | undefined;
    profileImageURL: string | undefined;
    academicYearId: number | undefined;
    gradeId: number | undefined;
    gradeName: string | undefined;
    divisionId: number | undefined;
    divisionName: string | undefined;
    gradeNameAdmission: string | undefined;
    fatherFullName: string | undefined;
    fatherMobileNo: string | undefined;
    fatherId: number | undefined;
    motherId: number | undefined;
    guardianId: number | undefined;
    rollNumber: string | undefined;
    isNewStudent: boolean | undefined;
    isRTEStudent: boolean | undefined;
    isConsationApplicable: boolean | undefined;
    consationAmount: number | undefined;
    isArchive: boolean | undefined;
    profileBase64Image: string | undefined;
    profileImageContentType: string | undefined;
    isAppAccess: boolean | undefined;
    appAccessMobileNo: string | undefined;
    appAccessOneTimePassword: string | undefined;
    previousAcademicYearPendingFeeAmount: number | undefined;
}

export class StudentIdModelResponse implements IStudentIdModelResponse {
    studentId!: number | undefined;
    fatherId!: number | undefined;
    motherId!: number | undefined;
    guardianId!: number | undefined;
    documentId!: number | undefined;
    exist!: number;
    generalRegistrationNoAvailable!: number;
    updateFlag!: number;
    studentPaymentExist!: number;

    constructor(data?: IStudentIdModelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.fatherId = _data["fatherId"];
            this.motherId = _data["motherId"];
            this.guardianId = _data["guardianId"];
            this.documentId = _data["documentId"];
            this.exist = _data["exist"];
            this.generalRegistrationNoAvailable = _data["generalRegistrationNoAvailable"];
            this.updateFlag = _data["updateFlag"];
            this.studentPaymentExist = _data["studentPaymentExist"];
        }
    }

    static fromJS(data: any): StudentIdModelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StudentIdModelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["fatherId"] = this.fatherId;
        data["motherId"] = this.motherId;
        data["guardianId"] = this.guardianId;
        data["documentId"] = this.documentId;
        data["exist"] = this.exist;
        data["generalRegistrationNoAvailable"] = this.generalRegistrationNoAvailable;
        data["updateFlag"] = this.updateFlag;
        data["studentPaymentExist"] = this.studentPaymentExist;
        return data;
    }

    clone(): StudentIdModelResponse {
        const json = this.toJSON();
        let result = new StudentIdModelResponse();
        result.init(json);
        return result;
    }
}

export interface IStudentIdModelResponse {
    studentId: number | undefined;
    fatherId: number | undefined;
    motherId: number | undefined;
    guardianId: number | undefined;
    documentId: number | undefined;
    exist: number;
    generalRegistrationNoAvailable: number;
    updateFlag: number;
    studentPaymentExist: number;
}

export class StudentDeleteRespose implements IStudentDeleteRespose {
    affectedRows!: number;

    constructor(data?: IStudentDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): StudentDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): StudentDeleteRespose {
        const json = this.toJSON();
        let result = new StudentDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IStudentDeleteRespose {
    affectedRows: number;
}

export class StudentKitPaymentAnalyticsDto implements IStudentKitPaymentAnalyticsDto {
    studentKitPaymentAnalyticsSchool!: StudentKitPaymentAnalyticsSchoolDto;
    studentKitPaymentAnalyticsGrade!: StudentKitPaymentAnalyticsGradeDto[];
    studentKitPaymentAnalyticsDivision!: StudentKitPaymentAnalyticsDivisionDto[];
    studentKitPaymentAnalyticsStudent!: StudentKitPaymentAnalyticsStudentDto[];

    constructor(data?: IStudentKitPaymentAnalyticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentKitPaymentAnalyticsSchool = _data["studentKitPaymentAnalyticsSchool"] ? StudentKitPaymentAnalyticsSchoolDto.fromJS(_data["studentKitPaymentAnalyticsSchool"]) : <any>undefined;
            if (Array.isArray(_data["studentKitPaymentAnalyticsGrade"])) {
                this.studentKitPaymentAnalyticsGrade = [] as any;
                for (let item of _data["studentKitPaymentAnalyticsGrade"])
                    this.studentKitPaymentAnalyticsGrade!.push(StudentKitPaymentAnalyticsGradeDto.fromJS(item));
            }
            if (Array.isArray(_data["studentKitPaymentAnalyticsDivision"])) {
                this.studentKitPaymentAnalyticsDivision = [] as any;
                for (let item of _data["studentKitPaymentAnalyticsDivision"])
                    this.studentKitPaymentAnalyticsDivision!.push(StudentKitPaymentAnalyticsDivisionDto.fromJS(item));
            }
            if (Array.isArray(_data["studentKitPaymentAnalyticsStudent"])) {
                this.studentKitPaymentAnalyticsStudent = [] as any;
                for (let item of _data["studentKitPaymentAnalyticsStudent"])
                    this.studentKitPaymentAnalyticsStudent!.push(StudentKitPaymentAnalyticsStudentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentKitPaymentAnalyticsSchool"] = this.studentKitPaymentAnalyticsSchool ? this.studentKitPaymentAnalyticsSchool.toJSON() : <any>undefined;
        if (Array.isArray(this.studentKitPaymentAnalyticsGrade)) {
            data["studentKitPaymentAnalyticsGrade"] = [];
            for (let item of this.studentKitPaymentAnalyticsGrade)
                data["studentKitPaymentAnalyticsGrade"].push(item.toJSON());
        }
        if (Array.isArray(this.studentKitPaymentAnalyticsDivision)) {
            data["studentKitPaymentAnalyticsDivision"] = [];
            for (let item of this.studentKitPaymentAnalyticsDivision)
                data["studentKitPaymentAnalyticsDivision"].push(item.toJSON());
        }
        if (Array.isArray(this.studentKitPaymentAnalyticsStudent)) {
            data["studentKitPaymentAnalyticsStudent"] = [];
            for (let item of this.studentKitPaymentAnalyticsStudent)
                data["studentKitPaymentAnalyticsStudent"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentKitPaymentAnalyticsDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsDto {
    studentKitPaymentAnalyticsSchool: StudentKitPaymentAnalyticsSchoolDto;
    studentKitPaymentAnalyticsGrade: StudentKitPaymentAnalyticsGradeDto[];
    studentKitPaymentAnalyticsDivision: StudentKitPaymentAnalyticsDivisionDto[];
    studentKitPaymentAnalyticsStudent: StudentKitPaymentAnalyticsStudentDto[];
}

export class StudentKitPaymentAnalyticsSchoolDto implements IStudentKitPaymentAnalyticsSchoolDto {
    studentId!: number;
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    schoolName!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;

    constructor(data?: IStudentKitPaymentAnalyticsSchoolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.schoolName = _data["schoolName"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsSchoolDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsSchoolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["schoolName"] = this.schoolName;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        return data;
    }

    clone(): StudentKitPaymentAnalyticsSchoolDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsSchoolDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsSchoolDto {
    studentId: number;
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    schoolName: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
}

export class StudentKitPaymentAnalyticsGradeDto implements IStudentKitPaymentAnalyticsGradeDto {
    studentId!: number;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    gradeName!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;

    constructor(data?: IStudentKitPaymentAnalyticsGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeName = _data["gradeName"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["gradeName"] = this.gradeName;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        return data;
    }

    clone(): StudentKitPaymentAnalyticsGradeDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsGradeDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsGradeDto {
    studentId: number;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    gradeName: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
}

export class StudentKitPaymentAnalyticsDivisionDto implements IStudentKitPaymentAnalyticsDivisionDto {
    studentId!: number;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    divisionName!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;

    constructor(data?: IStudentKitPaymentAnalyticsDivisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.divisionName = _data["divisionName"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsDivisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsDivisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["divisionName"] = this.divisionName;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        return data;
    }

    clone(): StudentKitPaymentAnalyticsDivisionDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsDivisionDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsDivisionDto {
    studentId: number;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    divisionName: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
}

export class StudentKitPaymentAnalyticsStudentDto implements IStudentKitPaymentAnalyticsStudentDto {
    studentId!: number;
    studentName!: string;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;

    constructor(data?: IStudentKitPaymentAnalyticsStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        return data;
    }

    clone(): StudentKitPaymentAnalyticsStudentDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsStudentDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsStudentDto {
    studentId: number;
    studentName: string;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
}

export class StudentKitFeePaymentDueByAYSelectResponseDto implements IStudentKitFeePaymentDueByAYSelectResponseDto {
    studentKitFeePaymentDueByAYList!: StudentKitFeePaymentDueByAYSelectDto[];

    constructor(data?: IStudentKitFeePaymentDueByAYSelectResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentKitFeePaymentDueByAYList"])) {
                this.studentKitFeePaymentDueByAYList = [] as any;
                for (let item of _data["studentKitFeePaymentDueByAYList"])
                    this.studentKitFeePaymentDueByAYList!.push(StudentKitFeePaymentDueByAYSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentKitFeePaymentDueByAYSelectResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeePaymentDueByAYSelectResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentKitFeePaymentDueByAYList)) {
            data["studentKitFeePaymentDueByAYList"] = [];
            for (let item of this.studentKitFeePaymentDueByAYList)
                data["studentKitFeePaymentDueByAYList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentKitFeePaymentDueByAYSelectResponseDto {
        const json = this.toJSON();
        let result = new StudentKitFeePaymentDueByAYSelectResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeePaymentDueByAYSelectResponseDto {
    studentKitFeePaymentDueByAYList: StudentKitFeePaymentDueByAYSelectDto[];
}

export class StudentKitFeePaymentDueByAYSelectDto implements IStudentKitFeePaymentDueByAYSelectDto {
    studentId!: number;
    gradeName!: string;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    academicYearKey!: string | undefined;
    fullName!: string;
    generalRegistrationNo!: string;
    totalFee!: number;
    discountedFee!: number;
    paidAmount!: number;
    otherPaidAmount!: number;
    dueAmount!: number;
    chequeClearedAmount!: number;
    chequeUnclearAmount!: number;
    isRTEStudent!: boolean;

    constructor(data?: IStudentKitFeePaymentDueByAYSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeName = _data["gradeName"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.academicYearKey = _data["academicYearKey"];
            this.fullName = _data["fullName"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.paidAmount = _data["paidAmount"];
            this.otherPaidAmount = _data["otherPaidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.chequeClearedAmount = _data["chequeClearedAmount"];
            this.chequeUnclearAmount = _data["chequeUnclearAmount"];
            this.isRTEStudent = _data["isRTEStudent"];
        }
    }

    static fromJS(data: any): StudentKitFeePaymentDueByAYSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeePaymentDueByAYSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeName"] = this.gradeName;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["academicYearKey"] = this.academicYearKey;
        data["fullName"] = this.fullName;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["paidAmount"] = this.paidAmount;
        data["otherPaidAmount"] = this.otherPaidAmount;
        data["dueAmount"] = this.dueAmount;
        data["chequeClearedAmount"] = this.chequeClearedAmount;
        data["chequeUnclearAmount"] = this.chequeUnclearAmount;
        data["isRTEStudent"] = this.isRTEStudent;
        return data;
    }

    clone(): StudentKitFeePaymentDueByAYSelectDto {
        const json = this.toJSON();
        let result = new StudentKitFeePaymentDueByAYSelectDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeePaymentDueByAYSelectDto {
    studentId: number;
    gradeName: string;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    academicYearKey: string | undefined;
    fullName: string;
    generalRegistrationNo: string;
    totalFee: number;
    discountedFee: number;
    paidAmount: number;
    otherPaidAmount: number;
    dueAmount: number;
    chequeClearedAmount: number;
    chequeUnclearAmount: number;
    isRTEStudent: boolean;
}

export class StudentKitFeepaymentSelectDto implements IStudentKitFeepaymentSelectDto {
    fullName!: string;
    generalRegistrationNo!: string;
    isNewStudent!: boolean;
    isRTEStudent!: boolean;
    isConsationApplicable!: boolean;
    consationAmount!: number;
    previousAcademicYearPendingFeeAmount!: number;
    appAccessMobileNo!: string;
    academicYearId!: number;
    rollNumber!: string;
    gradeName!: string;
    divisionName!: string;
    classId!: number | undefined;
    paymentInstallmentDone!: number | undefined;
    skipDiscountCount!: number | undefined;
    studentKitFeePaymentAdditionalDiscountList!: StudentKitFeePaymentAdditionalDiscount[];
    studentKitFeePaymentParticularsList!: StudentKitFeePaymentParticulars[];

    constructor(data?: IStudentKitFeepaymentSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.isNewStudent = _data["isNewStudent"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isConsationApplicable = _data["isConsationApplicable"];
            this.consationAmount = _data["consationAmount"];
            this.previousAcademicYearPendingFeeAmount = _data["previousAcademicYearPendingFeeAmount"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.academicYearId = _data["academicYearId"];
            this.rollNumber = _data["rollNumber"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.classId = _data["classId"];
            this.paymentInstallmentDone = _data["paymentInstallmentDone"];
            this.skipDiscountCount = _data["skipDiscountCount"];
            if (Array.isArray(_data["studentKitFeePaymentAdditionalDiscountList"])) {
                this.studentKitFeePaymentAdditionalDiscountList = [] as any;
                for (let item of _data["studentKitFeePaymentAdditionalDiscountList"])
                    this.studentKitFeePaymentAdditionalDiscountList!.push(StudentKitFeePaymentAdditionalDiscount.fromJS(item));
            }
            if (Array.isArray(_data["studentKitFeePaymentParticularsList"])) {
                this.studentKitFeePaymentParticularsList = [] as any;
                for (let item of _data["studentKitFeePaymentParticularsList"])
                    this.studentKitFeePaymentParticularsList!.push(StudentKitFeePaymentParticulars.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentKitFeepaymentSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeepaymentSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["isNewStudent"] = this.isNewStudent;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isConsationApplicable"] = this.isConsationApplicable;
        data["consationAmount"] = this.consationAmount;
        data["previousAcademicYearPendingFeeAmount"] = this.previousAcademicYearPendingFeeAmount;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["academicYearId"] = this.academicYearId;
        data["rollNumber"] = this.rollNumber;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["classId"] = this.classId;
        data["paymentInstallmentDone"] = this.paymentInstallmentDone;
        data["skipDiscountCount"] = this.skipDiscountCount;
        if (Array.isArray(this.studentKitFeePaymentAdditionalDiscountList)) {
            data["studentKitFeePaymentAdditionalDiscountList"] = [];
            for (let item of this.studentKitFeePaymentAdditionalDiscountList)
                data["studentKitFeePaymentAdditionalDiscountList"].push(item.toJSON());
        }
        if (Array.isArray(this.studentKitFeePaymentParticularsList)) {
            data["studentKitFeePaymentParticularsList"] = [];
            for (let item of this.studentKitFeePaymentParticularsList)
                data["studentKitFeePaymentParticularsList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentKitFeepaymentSelectDto {
        const json = this.toJSON();
        let result = new StudentKitFeepaymentSelectDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeepaymentSelectDto {
    fullName: string;
    generalRegistrationNo: string;
    isNewStudent: boolean;
    isRTEStudent: boolean;
    isConsationApplicable: boolean;
    consationAmount: number;
    previousAcademicYearPendingFeeAmount: number;
    appAccessMobileNo: string;
    academicYearId: number;
    rollNumber: string;
    gradeName: string;
    divisionName: string;
    classId: number | undefined;
    paymentInstallmentDone: number | undefined;
    skipDiscountCount: number | undefined;
    studentKitFeePaymentAdditionalDiscountList: StudentKitFeePaymentAdditionalDiscount[];
    studentKitFeePaymentParticularsList: StudentKitFeePaymentParticulars[];
}

export class StudentKitFeePaymentAdditionalDiscount implements IStudentKitFeePaymentAdditionalDiscount {
    feeAdditionalDiscountId!: number;
    academicYearId!: number;
    additionalDiscountedAmount!: number;
    installmentPaybleFee!: number;
    paymentInstallmentNumber!: number | undefined;
    additionalDiscountedRemark!: string;
    appliedDate!: string | undefined;
    totalFee!: number;

    constructor(data?: IStudentKitFeePaymentAdditionalDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeAdditionalDiscountId = _data["feeAdditionalDiscountId"];
            this.academicYearId = _data["academicYearId"];
            this.additionalDiscountedAmount = _data["additionalDiscountedAmount"];
            this.installmentPaybleFee = _data["installmentPaybleFee"];
            this.paymentInstallmentNumber = _data["paymentInstallmentNumber"];
            this.additionalDiscountedRemark = _data["additionalDiscountedRemark"];
            this.appliedDate = _data["appliedDate"];
            this.totalFee = _data["totalFee"];
        }
    }

    static fromJS(data: any): StudentKitFeePaymentAdditionalDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeePaymentAdditionalDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeAdditionalDiscountId"] = this.feeAdditionalDiscountId;
        data["academicYearId"] = this.academicYearId;
        data["additionalDiscountedAmount"] = this.additionalDiscountedAmount;
        data["installmentPaybleFee"] = this.installmentPaybleFee;
        data["paymentInstallmentNumber"] = this.paymentInstallmentNumber;
        data["additionalDiscountedRemark"] = this.additionalDiscountedRemark;
        data["appliedDate"] = this.appliedDate;
        data["totalFee"] = this.totalFee;
        return data;
    }

    clone(): StudentKitFeePaymentAdditionalDiscount {
        const json = this.toJSON();
        let result = new StudentKitFeePaymentAdditionalDiscount();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeePaymentAdditionalDiscount {
    feeAdditionalDiscountId: number;
    academicYearId: number;
    additionalDiscountedAmount: number;
    installmentPaybleFee: number;
    paymentInstallmentNumber: number | undefined;
    additionalDiscountedRemark: string;
    appliedDate: string | undefined;
    totalFee: number;
}

export class StudentKitFeePaymentParticulars implements IStudentKitFeePaymentParticulars {
    additionalDiscInPercentage!: number;
    feeParticularId!: number;
    isDiscountApplicable!: boolean;
    particularName!: string;
    totalFee!: number;
    feeAfterDiscount!: number;
    paybleFee!: number;
    dueAmount!: number;
    alreadyPaid!: number;
    additionalDiscAmount!: number;
    showError!: boolean;

    constructor(data?: IStudentKitFeePaymentParticulars) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additionalDiscInPercentage = _data["additionalDiscInPercentage"];
            this.feeParticularId = _data["feeParticularId"];
            this.isDiscountApplicable = _data["isDiscountApplicable"];
            this.particularName = _data["particularName"];
            this.totalFee = _data["totalFee"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.paybleFee = _data["paybleFee"];
            this.dueAmount = _data["dueAmount"];
            this.alreadyPaid = _data["alreadyPaid"];
            this.additionalDiscAmount = _data["additionalDiscAmount"];
            this.showError = _data["showError"];
        }
    }

    static fromJS(data: any): StudentKitFeePaymentParticulars {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeePaymentParticulars();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalDiscInPercentage"] = this.additionalDiscInPercentage;
        data["feeParticularId"] = this.feeParticularId;
        data["isDiscountApplicable"] = this.isDiscountApplicable;
        data["particularName"] = this.particularName;
        data["totalFee"] = this.totalFee;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["paybleFee"] = this.paybleFee;
        data["dueAmount"] = this.dueAmount;
        data["alreadyPaid"] = this.alreadyPaid;
        data["additionalDiscAmount"] = this.additionalDiscAmount;
        data["showError"] = this.showError;
        return data;
    }

    clone(): StudentKitFeePaymentParticulars {
        const json = this.toJSON();
        let result = new StudentKitFeePaymentParticulars();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeePaymentParticulars {
    additionalDiscInPercentage: number;
    feeParticularId: number;
    isDiscountApplicable: boolean;
    particularName: string;
    totalFee: number;
    feeAfterDiscount: number;
    paybleFee: number;
    dueAmount: number;
    alreadyPaid: number;
    additionalDiscAmount: number;
    showError: boolean;
}

export class StudentKitFeepaymentUpsertDto implements IStudentKitFeepaymentUpsertDto {
    academicYearId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    studentId!: number | undefined;
    onlineTransactionId!: string | undefined;
    onlineTransactionDateTime!: moment.Moment | undefined;
    ngbOnlineTransactionDateTime!: SchoolNgbDateModel | undefined;
    onlinePaymentRequest!: string | undefined;
    onlinePaymentResponse!: string | undefined;
    paidToBank!: string | undefined;
    paidAmount!: number | undefined;
    paymentTypeId!: number | undefined;
    chequeNumber!: string;
    chequeDate!: moment.Moment | undefined;
    ngbChequeDate!: SchoolNgbDateModel | undefined;
    chequeBank!: string;
    chequeAmount!: number | undefined;
    isChequeClear!: boolean | undefined;
    skipDiscount!: boolean | undefined;
    remark!: string;
    additionalDiscountedAmount!: number | undefined;
    installmentPaybleFee!: number | undefined;
    additionalDiscountedRemark!: string | undefined;
    userId!: number | undefined;
    studentKitFeePaymentDetailTypeUpsertDtoList!: StudentKitFeePaymentDetailTypeUpsertDto[] | undefined;

    constructor(data?: IStudentKitFeepaymentUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.studentId = _data["studentId"];
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"] ? moment(_data["onlineTransactionDateTime"].toString()) : <any>undefined;
            this.ngbOnlineTransactionDateTime = _data["ngbOnlineTransactionDateTime"] ? SchoolNgbDateModel.fromJS(_data["ngbOnlineTransactionDateTime"]) : <any>undefined;
            this.onlinePaymentRequest = _data["onlinePaymentRequest"];
            this.onlinePaymentResponse = _data["onlinePaymentResponse"];
            this.paidToBank = _data["paidToBank"];
            this.paidAmount = _data["paidAmount"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.ngbChequeDate = _data["ngbChequeDate"] ? SchoolNgbDateModel.fromJS(_data["ngbChequeDate"]) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.chequeAmount = _data["chequeAmount"];
            this.isChequeClear = _data["isChequeClear"];
            this.skipDiscount = _data["skipDiscount"];
            this.remark = _data["remark"];
            this.additionalDiscountedAmount = _data["additionalDiscountedAmount"];
            this.installmentPaybleFee = _data["installmentPaybleFee"];
            this.additionalDiscountedRemark = _data["additionalDiscountedRemark"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["studentKitFeePaymentDetailTypeUpsertDtoList"])) {
                this.studentKitFeePaymentDetailTypeUpsertDtoList = [] as any;
                for (let item of _data["studentKitFeePaymentDetailTypeUpsertDtoList"])
                    this.studentKitFeePaymentDetailTypeUpsertDtoList!.push(StudentKitFeePaymentDetailTypeUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentKitFeepaymentUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeepaymentUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["studentId"] = this.studentId;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime ? this.onlineTransactionDateTime.toISOString() : <any>undefined;
        data["ngbOnlineTransactionDateTime"] = this.ngbOnlineTransactionDateTime ? this.ngbOnlineTransactionDateTime.toJSON() : <any>undefined;
        data["onlinePaymentRequest"] = this.onlinePaymentRequest;
        data["onlinePaymentResponse"] = this.onlinePaymentResponse;
        data["paidToBank"] = this.paidToBank;
        data["paidAmount"] = this.paidAmount;
        data["paymentTypeId"] = this.paymentTypeId;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["ngbChequeDate"] = this.ngbChequeDate ? this.ngbChequeDate.toJSON() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["chequeAmount"] = this.chequeAmount;
        data["isChequeClear"] = this.isChequeClear;
        data["skipDiscount"] = this.skipDiscount;
        data["remark"] = this.remark;
        data["additionalDiscountedAmount"] = this.additionalDiscountedAmount;
        data["installmentPaybleFee"] = this.installmentPaybleFee;
        data["additionalDiscountedRemark"] = this.additionalDiscountedRemark;
        data["userId"] = this.userId;
        if (Array.isArray(this.studentKitFeePaymentDetailTypeUpsertDtoList)) {
            data["studentKitFeePaymentDetailTypeUpsertDtoList"] = [];
            for (let item of this.studentKitFeePaymentDetailTypeUpsertDtoList)
                data["studentKitFeePaymentDetailTypeUpsertDtoList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentKitFeepaymentUpsertDto {
        const json = this.toJSON();
        let result = new StudentKitFeepaymentUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeepaymentUpsertDto {
    academicYearId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    studentId: number | undefined;
    onlineTransactionId: string | undefined;
    onlineTransactionDateTime: moment.Moment | undefined;
    ngbOnlineTransactionDateTime: SchoolNgbDateModel | undefined;
    onlinePaymentRequest: string | undefined;
    onlinePaymentResponse: string | undefined;
    paidToBank: string | undefined;
    paidAmount: number | undefined;
    paymentTypeId: number | undefined;
    chequeNumber: string;
    chequeDate: moment.Moment | undefined;
    ngbChequeDate: SchoolNgbDateModel | undefined;
    chequeBank: string;
    chequeAmount: number | undefined;
    isChequeClear: boolean | undefined;
    skipDiscount: boolean | undefined;
    remark: string;
    additionalDiscountedAmount: number | undefined;
    installmentPaybleFee: number | undefined;
    additionalDiscountedRemark: string | undefined;
    userId: number | undefined;
    studentKitFeePaymentDetailTypeUpsertDtoList: StudentKitFeePaymentDetailTypeUpsertDto[] | undefined;
}

export class StudentKitFeePaymentDetailTypeUpsertDto implements IStudentKitFeePaymentDetailTypeUpsertDto {
    feeParticularId!: number;
    otherFeeReason!: string;
    paidAmount!: number;
    feeAfterDiscount!: number;
    additionalDiscInPercentage!: number;
    additionalDiscAmount!: number;

    constructor(data?: IStudentKitFeePaymentDetailTypeUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularId = _data["feeParticularId"];
            this.otherFeeReason = _data["otherFeeReason"];
            this.paidAmount = _data["paidAmount"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.additionalDiscInPercentage = _data["additionalDiscInPercentage"];
            this.additionalDiscAmount = _data["additionalDiscAmount"];
        }
    }

    static fromJS(data: any): StudentKitFeePaymentDetailTypeUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeePaymentDetailTypeUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularId"] = this.feeParticularId;
        data["otherFeeReason"] = this.otherFeeReason;
        data["paidAmount"] = this.paidAmount;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["additionalDiscInPercentage"] = this.additionalDiscInPercentage;
        data["additionalDiscAmount"] = this.additionalDiscAmount;
        return data;
    }

    clone(): StudentKitFeePaymentDetailTypeUpsertDto {
        const json = this.toJSON();
        let result = new StudentKitFeePaymentDetailTypeUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeePaymentDetailTypeUpsertDto {
    feeParticularId: number;
    otherFeeReason: string;
    paidAmount: number;
    feeAfterDiscount: number;
    additionalDiscInPercentage: number;
    additionalDiscAmount: number;
}

export class StudentKitFeepaymentHistorySelectDto implements IStudentKitFeepaymentHistorySelectDto {
    schoolName!: string;
    schoolAddress!: string;
    academicYearId!: number;
    studentName!: string;
    gradeName!: string;
    divisionName!: string;
    rollNumber!: string;
    generalRegistrationNo!: string | undefined;
    paymentTypeName!: string;
    paymentDate!: moment.Moment | undefined;
    chequeDate!: moment.Moment | undefined;
    chequeBank!: string;
    transactionId!: string;
    invoiceNumber!: string;
    studentKitFeeParticularsSelectList!: StudentKitFeeParticularsSelectDto[];

    constructor(data?: IStudentKitFeepaymentHistorySelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.schoolAddress = _data["schoolAddress"];
            this.academicYearId = _data["academicYearId"];
            this.studentName = _data["studentName"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.transactionId = _data["transactionId"];
            this.invoiceNumber = _data["invoiceNumber"];
            if (Array.isArray(_data["studentKitFeeParticularsSelectList"])) {
                this.studentKitFeeParticularsSelectList = [] as any;
                for (let item of _data["studentKitFeeParticularsSelectList"])
                    this.studentKitFeeParticularsSelectList!.push(StudentKitFeeParticularsSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentKitFeepaymentHistorySelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeepaymentHistorySelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["schoolAddress"] = this.schoolAddress;
        data["academicYearId"] = this.academicYearId;
        data["studentName"] = this.studentName;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["paymentTypeName"] = this.paymentTypeName;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["transactionId"] = this.transactionId;
        data["invoiceNumber"] = this.invoiceNumber;
        if (Array.isArray(this.studentKitFeeParticularsSelectList)) {
            data["studentKitFeeParticularsSelectList"] = [];
            for (let item of this.studentKitFeeParticularsSelectList)
                data["studentKitFeeParticularsSelectList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentKitFeepaymentHistorySelectDto {
        const json = this.toJSON();
        let result = new StudentKitFeepaymentHistorySelectDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeepaymentHistorySelectDto {
    schoolName: string;
    schoolAddress: string;
    academicYearId: number;
    studentName: string;
    gradeName: string;
    divisionName: string;
    rollNumber: string;
    generalRegistrationNo: string | undefined;
    paymentTypeName: string;
    paymentDate: moment.Moment | undefined;
    chequeDate: moment.Moment | undefined;
    chequeBank: string;
    transactionId: string;
    invoiceNumber: string;
    studentKitFeeParticularsSelectList: StudentKitFeeParticularsSelectDto[];
}

export class StudentKitFeeParticularsSelectDto implements IStudentKitFeeParticularsSelectDto {
    feeParticularId!: number;
    particularName!: string;
    totalFee!: number;
    feeAfterDiscount!: number;
    paidAmount!: number;
    dueAmount!: number;
    alreadyPaid!: number;

    constructor(data?: IStudentKitFeeParticularsSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularId = _data["feeParticularId"];
            this.particularName = _data["particularName"];
            this.totalFee = _data["totalFee"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.paidAmount = _data["paidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.alreadyPaid = _data["alreadyPaid"];
        }
    }

    static fromJS(data: any): StudentKitFeeParticularsSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeeParticularsSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularId"] = this.feeParticularId;
        data["particularName"] = this.particularName;
        data["totalFee"] = this.totalFee;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["paidAmount"] = this.paidAmount;
        data["dueAmount"] = this.dueAmount;
        data["alreadyPaid"] = this.alreadyPaid;
        return data;
    }

    clone(): StudentKitFeeParticularsSelectDto {
        const json = this.toJSON();
        let result = new StudentKitFeeParticularsSelectDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeeParticularsSelectDto {
    feeParticularId: number;
    particularName: string;
    totalFee: number;
    feeAfterDiscount: number;
    paidAmount: number;
    dueAmount: number;
    alreadyPaid: number;
}

export class StudentKitDaywisePaymentReportDto implements IStudentKitDaywisePaymentReportDto {
    cashStudentKitDaywisePaymentReport!: CashStudentKitDaywisePaymentReport;
    chequeStudentKitDaywisePaymentReport!: ChequeStudentKitDaywisePaymentReport;
    ddStudentKitDaywisePaymentReport!: DDStudentKitDaywisePaymentReport;
    upiStudentKitDaywisePaymentReport!: UpiStudentKitDaywisePaymentReport;
    netBankingStudentKitDaywisePaymentReport!: NetBankingStudentKitDaywisePaymentReport;
    cardStudentKitDaywisePaymentReport!: CardStudentKitDaywisePaymentReport;

    constructor(data?: IStudentKitDaywisePaymentReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashStudentKitDaywisePaymentReport = _data["cashStudentKitDaywisePaymentReport"] ? CashStudentKitDaywisePaymentReport.fromJS(_data["cashStudentKitDaywisePaymentReport"]) : <any>undefined;
            this.chequeStudentKitDaywisePaymentReport = _data["chequeStudentKitDaywisePaymentReport"] ? ChequeStudentKitDaywisePaymentReport.fromJS(_data["chequeStudentKitDaywisePaymentReport"]) : <any>undefined;
            this.ddStudentKitDaywisePaymentReport = _data["ddStudentKitDaywisePaymentReport"] ? DDStudentKitDaywisePaymentReport.fromJS(_data["ddStudentKitDaywisePaymentReport"]) : <any>undefined;
            this.upiStudentKitDaywisePaymentReport = _data["upiStudentKitDaywisePaymentReport"] ? UpiStudentKitDaywisePaymentReport.fromJS(_data["upiStudentKitDaywisePaymentReport"]) : <any>undefined;
            this.netBankingStudentKitDaywisePaymentReport = _data["netBankingStudentKitDaywisePaymentReport"] ? NetBankingStudentKitDaywisePaymentReport.fromJS(_data["netBankingStudentKitDaywisePaymentReport"]) : <any>undefined;
            this.cardStudentKitDaywisePaymentReport = _data["cardStudentKitDaywisePaymentReport"] ? CardStudentKitDaywisePaymentReport.fromJS(_data["cardStudentKitDaywisePaymentReport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StudentKitDaywisePaymentReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitDaywisePaymentReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashStudentKitDaywisePaymentReport"] = this.cashStudentKitDaywisePaymentReport ? this.cashStudentKitDaywisePaymentReport.toJSON() : <any>undefined;
        data["chequeStudentKitDaywisePaymentReport"] = this.chequeStudentKitDaywisePaymentReport ? this.chequeStudentKitDaywisePaymentReport.toJSON() : <any>undefined;
        data["ddStudentKitDaywisePaymentReport"] = this.ddStudentKitDaywisePaymentReport ? this.ddStudentKitDaywisePaymentReport.toJSON() : <any>undefined;
        data["upiStudentKitDaywisePaymentReport"] = this.upiStudentKitDaywisePaymentReport ? this.upiStudentKitDaywisePaymentReport.toJSON() : <any>undefined;
        data["netBankingStudentKitDaywisePaymentReport"] = this.netBankingStudentKitDaywisePaymentReport ? this.netBankingStudentKitDaywisePaymentReport.toJSON() : <any>undefined;
        data["cardStudentKitDaywisePaymentReport"] = this.cardStudentKitDaywisePaymentReport ? this.cardStudentKitDaywisePaymentReport.toJSON() : <any>undefined;
        return data;
    }

    clone(): StudentKitDaywisePaymentReportDto {
        const json = this.toJSON();
        let result = new StudentKitDaywisePaymentReportDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitDaywisePaymentReportDto {
    cashStudentKitDaywisePaymentReport: CashStudentKitDaywisePaymentReport;
    chequeStudentKitDaywisePaymentReport: ChequeStudentKitDaywisePaymentReport;
    ddStudentKitDaywisePaymentReport: DDStudentKitDaywisePaymentReport;
    upiStudentKitDaywisePaymentReport: UpiStudentKitDaywisePaymentReport;
    netBankingStudentKitDaywisePaymentReport: NetBankingStudentKitDaywisePaymentReport;
    cardStudentKitDaywisePaymentReport: CardStudentKitDaywisePaymentReport;
}

export class CashStudentKitDaywisePaymentReport implements ICashStudentKitDaywisePaymentReport {
    cashStudentKitDaywisePaymentReportList!: StudentKitDaywisePaymentReport[];
    cashStudentKitDaywisePaymentReportTotal!: StudentKitDaywisePaymentReportTotal;

    constructor(data?: ICashStudentKitDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cashStudentKitDaywisePaymentReportList"])) {
                this.cashStudentKitDaywisePaymentReportList = [] as any;
                for (let item of _data["cashStudentKitDaywisePaymentReportList"])
                    this.cashStudentKitDaywisePaymentReportList!.push(StudentKitDaywisePaymentReport.fromJS(item));
            }
            this.cashStudentKitDaywisePaymentReportTotal = _data["cashStudentKitDaywisePaymentReportTotal"] ? StudentKitDaywisePaymentReportTotal.fromJS(_data["cashStudentKitDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashStudentKitDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new CashStudentKitDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cashStudentKitDaywisePaymentReportList)) {
            data["cashStudentKitDaywisePaymentReportList"] = [];
            for (let item of this.cashStudentKitDaywisePaymentReportList)
                data["cashStudentKitDaywisePaymentReportList"].push(item.toJSON());
        }
        data["cashStudentKitDaywisePaymentReportTotal"] = this.cashStudentKitDaywisePaymentReportTotal ? this.cashStudentKitDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): CashStudentKitDaywisePaymentReport {
        const json = this.toJSON();
        let result = new CashStudentKitDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface ICashStudentKitDaywisePaymentReport {
    cashStudentKitDaywisePaymentReportList: StudentKitDaywisePaymentReport[];
    cashStudentKitDaywisePaymentReportTotal: StudentKitDaywisePaymentReportTotal;
}

export class StudentKitDaywisePaymentReport implements IStudentKitDaywisePaymentReport {
    studentName!: string;
    class!: string;
    generalRegistrationNo!: string;
    chequeNumber!: string;
    chequeDate!: moment.Moment;
    chequeBank!: string;
    academicYearName!: string;
    paymentAmount!: number;
    invoiceNumber!: string;
    transactionDate!: moment.Moment;
    paymentMode!: string;
    chequeUnclearedAmount!: number;
    transactionBy!: string;
    transactionId!: string;

    constructor(data?: IStudentKitDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentName = _data["studentName"];
            this.class = _data["class"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.academicYearName = _data["academicYearName"];
            this.paymentAmount = _data["paymentAmount"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.transactionDate = _data["transactionDate"] ? moment(_data["transactionDate"].toString()) : <any>undefined;
            this.paymentMode = _data["paymentMode"];
            this.chequeUnclearedAmount = _data["chequeUnclearedAmount"];
            this.transactionBy = _data["transactionBy"];
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): StudentKitDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["class"] = this.class;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["academicYearName"] = this.academicYearName;
        data["paymentAmount"] = this.paymentAmount;
        data["invoiceNumber"] = this.invoiceNumber;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["paymentMode"] = this.paymentMode;
        data["chequeUnclearedAmount"] = this.chequeUnclearedAmount;
        data["transactionBy"] = this.transactionBy;
        data["transactionId"] = this.transactionId;
        return data;
    }

    clone(): StudentKitDaywisePaymentReport {
        const json = this.toJSON();
        let result = new StudentKitDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface IStudentKitDaywisePaymentReport {
    studentName: string;
    class: string;
    generalRegistrationNo: string;
    chequeNumber: string;
    chequeDate: moment.Moment;
    chequeBank: string;
    academicYearName: string;
    paymentAmount: number;
    invoiceNumber: string;
    transactionDate: moment.Moment;
    paymentMode: string;
    chequeUnclearedAmount: number;
    transactionBy: string;
    transactionId: string;
}

export class StudentKitDaywisePaymentReportTotal implements IStudentKitDaywisePaymentReportTotal {
    totalPaymentAmount!: number;
    totalChequeUnclearedAmount!: number;

    constructor(data?: IStudentKitDaywisePaymentReportTotal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPaymentAmount = _data["totalPaymentAmount"];
            this.totalChequeUnclearedAmount = _data["totalChequeUnclearedAmount"];
        }
    }

    static fromJS(data: any): StudentKitDaywisePaymentReportTotal {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitDaywisePaymentReportTotal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPaymentAmount"] = this.totalPaymentAmount;
        data["totalChequeUnclearedAmount"] = this.totalChequeUnclearedAmount;
        return data;
    }

    clone(): StudentKitDaywisePaymentReportTotal {
        const json = this.toJSON();
        let result = new StudentKitDaywisePaymentReportTotal();
        result.init(json);
        return result;
    }
}

export interface IStudentKitDaywisePaymentReportTotal {
    totalPaymentAmount: number;
    totalChequeUnclearedAmount: number;
}

export class ChequeStudentKitDaywisePaymentReport implements IChequeStudentKitDaywisePaymentReport {
    chequeStudentKitDaywisePaymentReportList!: StudentKitDaywisePaymentReport[];
    chequeStudentKitDaywisePaymentReportTotal!: StudentKitDaywisePaymentReportTotal;

    constructor(data?: IChequeStudentKitDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chequeStudentKitDaywisePaymentReportList"])) {
                this.chequeStudentKitDaywisePaymentReportList = [] as any;
                for (let item of _data["chequeStudentKitDaywisePaymentReportList"])
                    this.chequeStudentKitDaywisePaymentReportList!.push(StudentKitDaywisePaymentReport.fromJS(item));
            }
            this.chequeStudentKitDaywisePaymentReportTotal = _data["chequeStudentKitDaywisePaymentReportTotal"] ? StudentKitDaywisePaymentReportTotal.fromJS(_data["chequeStudentKitDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChequeStudentKitDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new ChequeStudentKitDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chequeStudentKitDaywisePaymentReportList)) {
            data["chequeStudentKitDaywisePaymentReportList"] = [];
            for (let item of this.chequeStudentKitDaywisePaymentReportList)
                data["chequeStudentKitDaywisePaymentReportList"].push(item.toJSON());
        }
        data["chequeStudentKitDaywisePaymentReportTotal"] = this.chequeStudentKitDaywisePaymentReportTotal ? this.chequeStudentKitDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): ChequeStudentKitDaywisePaymentReport {
        const json = this.toJSON();
        let result = new ChequeStudentKitDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface IChequeStudentKitDaywisePaymentReport {
    chequeStudentKitDaywisePaymentReportList: StudentKitDaywisePaymentReport[];
    chequeStudentKitDaywisePaymentReportTotal: StudentKitDaywisePaymentReportTotal;
}

export class DDStudentKitDaywisePaymentReport implements IDDStudentKitDaywisePaymentReport {
    ddStudentKitDaywisePaymentReportList!: StudentKitDaywisePaymentReport[];
    ddStudentKitDaywisePaymentReportTotal!: StudentKitDaywisePaymentReportTotal;

    constructor(data?: IDDStudentKitDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ddStudentKitDaywisePaymentReportList"])) {
                this.ddStudentKitDaywisePaymentReportList = [] as any;
                for (let item of _data["ddStudentKitDaywisePaymentReportList"])
                    this.ddStudentKitDaywisePaymentReportList!.push(StudentKitDaywisePaymentReport.fromJS(item));
            }
            this.ddStudentKitDaywisePaymentReportTotal = _data["ddStudentKitDaywisePaymentReportTotal"] ? StudentKitDaywisePaymentReportTotal.fromJS(_data["ddStudentKitDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DDStudentKitDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new DDStudentKitDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ddStudentKitDaywisePaymentReportList)) {
            data["ddStudentKitDaywisePaymentReportList"] = [];
            for (let item of this.ddStudentKitDaywisePaymentReportList)
                data["ddStudentKitDaywisePaymentReportList"].push(item.toJSON());
        }
        data["ddStudentKitDaywisePaymentReportTotal"] = this.ddStudentKitDaywisePaymentReportTotal ? this.ddStudentKitDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): DDStudentKitDaywisePaymentReport {
        const json = this.toJSON();
        let result = new DDStudentKitDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface IDDStudentKitDaywisePaymentReport {
    ddStudentKitDaywisePaymentReportList: StudentKitDaywisePaymentReport[];
    ddStudentKitDaywisePaymentReportTotal: StudentKitDaywisePaymentReportTotal;
}

export class UpiStudentKitDaywisePaymentReport implements IUpiStudentKitDaywisePaymentReport {
    upiStudentKitPaymentDaywisePaymentReportList!: StudentKitDaywisePaymentReport[];
    upiStudentKitPaymentDaywisePaymentReportTotal!: StudentKitDaywisePaymentReportTotal;

    constructor(data?: IUpiStudentKitDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upiStudentKitPaymentDaywisePaymentReportList"])) {
                this.upiStudentKitPaymentDaywisePaymentReportList = [] as any;
                for (let item of _data["upiStudentKitPaymentDaywisePaymentReportList"])
                    this.upiStudentKitPaymentDaywisePaymentReportList!.push(StudentKitDaywisePaymentReport.fromJS(item));
            }
            this.upiStudentKitPaymentDaywisePaymentReportTotal = _data["upiStudentKitPaymentDaywisePaymentReportTotal"] ? StudentKitDaywisePaymentReportTotal.fromJS(_data["upiStudentKitPaymentDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpiStudentKitDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new UpiStudentKitDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upiStudentKitPaymentDaywisePaymentReportList)) {
            data["upiStudentKitPaymentDaywisePaymentReportList"] = [];
            for (let item of this.upiStudentKitPaymentDaywisePaymentReportList)
                data["upiStudentKitPaymentDaywisePaymentReportList"].push(item.toJSON());
        }
        data["upiStudentKitPaymentDaywisePaymentReportTotal"] = this.upiStudentKitPaymentDaywisePaymentReportTotal ? this.upiStudentKitPaymentDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpiStudentKitDaywisePaymentReport {
        const json = this.toJSON();
        let result = new UpiStudentKitDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface IUpiStudentKitDaywisePaymentReport {
    upiStudentKitPaymentDaywisePaymentReportList: StudentKitDaywisePaymentReport[];
    upiStudentKitPaymentDaywisePaymentReportTotal: StudentKitDaywisePaymentReportTotal;
}

export class NetBankingStudentKitDaywisePaymentReport implements INetBankingStudentKitDaywisePaymentReport {
    netBankingStudentKitDaywisePaymentReportList!: StudentKitDaywisePaymentReport[];
    netBankingStudentKitDaywisePaymentReportTotal!: StudentKitDaywisePaymentReportTotal;

    constructor(data?: INetBankingStudentKitDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["netBankingStudentKitDaywisePaymentReportList"])) {
                this.netBankingStudentKitDaywisePaymentReportList = [] as any;
                for (let item of _data["netBankingStudentKitDaywisePaymentReportList"])
                    this.netBankingStudentKitDaywisePaymentReportList!.push(StudentKitDaywisePaymentReport.fromJS(item));
            }
            this.netBankingStudentKitDaywisePaymentReportTotal = _data["netBankingStudentKitDaywisePaymentReportTotal"] ? StudentKitDaywisePaymentReportTotal.fromJS(_data["netBankingStudentKitDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NetBankingStudentKitDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new NetBankingStudentKitDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.netBankingStudentKitDaywisePaymentReportList)) {
            data["netBankingStudentKitDaywisePaymentReportList"] = [];
            for (let item of this.netBankingStudentKitDaywisePaymentReportList)
                data["netBankingStudentKitDaywisePaymentReportList"].push(item.toJSON());
        }
        data["netBankingStudentKitDaywisePaymentReportTotal"] = this.netBankingStudentKitDaywisePaymentReportTotal ? this.netBankingStudentKitDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): NetBankingStudentKitDaywisePaymentReport {
        const json = this.toJSON();
        let result = new NetBankingStudentKitDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface INetBankingStudentKitDaywisePaymentReport {
    netBankingStudentKitDaywisePaymentReportList: StudentKitDaywisePaymentReport[];
    netBankingStudentKitDaywisePaymentReportTotal: StudentKitDaywisePaymentReportTotal;
}

export class CardStudentKitDaywisePaymentReport implements ICardStudentKitDaywisePaymentReport {
    cardStudentKitDaywisePaymentReportList!: StudentKitDaywisePaymentReport[];
    cardStudentKitDaywisePaymentReportTotal!: StudentKitDaywisePaymentReportTotal;

    constructor(data?: ICardStudentKitDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cardStudentKitDaywisePaymentReportList"])) {
                this.cardStudentKitDaywisePaymentReportList = [] as any;
                for (let item of _data["cardStudentKitDaywisePaymentReportList"])
                    this.cardStudentKitDaywisePaymentReportList!.push(StudentKitDaywisePaymentReport.fromJS(item));
            }
            this.cardStudentKitDaywisePaymentReportTotal = _data["cardStudentKitDaywisePaymentReportTotal"] ? StudentKitDaywisePaymentReportTotal.fromJS(_data["cardStudentKitDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CardStudentKitDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new CardStudentKitDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cardStudentKitDaywisePaymentReportList)) {
            data["cardStudentKitDaywisePaymentReportList"] = [];
            for (let item of this.cardStudentKitDaywisePaymentReportList)
                data["cardStudentKitDaywisePaymentReportList"].push(item.toJSON());
        }
        data["cardStudentKitDaywisePaymentReportTotal"] = this.cardStudentKitDaywisePaymentReportTotal ? this.cardStudentKitDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): CardStudentKitDaywisePaymentReport {
        const json = this.toJSON();
        let result = new CardStudentKitDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface ICardStudentKitDaywisePaymentReport {
    cardStudentKitDaywisePaymentReportList: StudentKitDaywisePaymentReport[];
    cardStudentKitDaywisePaymentReportTotal: StudentKitDaywisePaymentReportTotal;
}

export class StudentKitDaywisePaymentReportRequest implements IStudentKitDaywisePaymentReportRequest {
    startDate!: SchoolNgbDateModel;
    endDate!: SchoolNgbDateModel;

    constructor(data?: IStudentKitDaywisePaymentReportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? SchoolNgbDateModel.fromJS(_data["startDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? SchoolNgbDateModel.fromJS(_data["endDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StudentKitDaywisePaymentReportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitDaywisePaymentReportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>undefined;
        return data;
    }

    clone(): StudentKitDaywisePaymentReportRequest {
        const json = this.toJSON();
        let result = new StudentKitDaywisePaymentReportRequest();
        result.init(json);
        return result;
    }
}

export interface IStudentKitDaywisePaymentReportRequest {
    startDate: SchoolNgbDateModel;
    endDate: SchoolNgbDateModel;
}

export class StudentEnquiryDto implements IStudentEnquiryDto {
    studentEnquiryId!: number;
    ngbEnquiryDate!: SchoolNgbDateModel | undefined;
    enquiryDate!: moment.Moment | undefined;
    studentFirstName!: string | undefined;
    studentMiddleName!: string | undefined;
    studentLastName!: string | undefined;
    studentFullName!: string | undefined;
    gender!: string | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthDate!: moment.Moment | undefined;
    adharNo!: string | undefined;
    religion!: string | undefined;
    cast!: string | undefined;
    category!: string | undefined;
    nationality!: string | undefined;
    mobileNumber!: string | undefined;
    interestedClassId!: string | undefined;
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    academicYearId!: number | undefined;
    currentSchool!: string | undefined;
    currentClass!: string | undefined;
    nameOfSiblingInCurrentSchool!: string | undefined;
    fatherFirstName!: string | undefined;
    fatherMiddleName!: string | undefined;
    fatherLastName!: string | undefined;
    fatherFullName!: string | undefined;
    motherFirstName!: string | undefined;
    motherMiddleName!: string | undefined;
    motherLastName!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    countryId!: number | undefined;
    countryName!: string | undefined;
    stateId!: number | undefined;
    stateName!: string | undefined;
    talukaId!: number | undefined;
    talukaName!: string | undefined;
    districtId!: number | undefined;
    districtName!: string | undefined;
    enquiryTypeId!: number | undefined;
    referenceBy!: string | undefined;
    enquiryStatusId!: number | undefined;
    emailId!: string | undefined;
    userId!: number | undefined;
    className!: string | undefined;
    paymentStatus!: string | undefined;
    paidAmount!: number | undefined;
    enquiryTypeDropdownList!: EnquiryTypeDropdownDto[];
    enquiryStatusDropdownList!: EnquiryStatusDropdownDto[];

    constructor(data?: IStudentEnquiryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentEnquiryId = _data["studentEnquiryId"];
            this.ngbEnquiryDate = _data["ngbEnquiryDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEnquiryDate"]) : <any>undefined;
            this.enquiryDate = _data["enquiryDate"] ? moment(_data["enquiryDate"].toString()) : <any>undefined;
            this.studentFirstName = _data["studentFirstName"];
            this.studentMiddleName = _data["studentMiddleName"];
            this.studentLastName = _data["studentLastName"];
            this.studentFullName = _data["studentFullName"];
            this.gender = _data["gender"];
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.adharNo = _data["adharNo"];
            this.religion = _data["religion"];
            this.cast = _data["cast"];
            this.category = _data["category"];
            this.nationality = _data["nationality"];
            this.mobileNumber = _data["mobileNumber"];
            this.interestedClassId = _data["interestedClassId"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.academicYearId = _data["academicYearId"];
            this.currentSchool = _data["currentSchool"];
            this.currentClass = _data["currentClass"];
            this.nameOfSiblingInCurrentSchool = _data["nameOfSiblingInCurrentSchool"];
            this.fatherFirstName = _data["fatherFirstName"];
            this.fatherMiddleName = _data["fatherMiddleName"];
            this.fatherLastName = _data["fatherLastName"];
            this.fatherFullName = _data["fatherFullName"];
            this.motherFirstName = _data["motherFirstName"];
            this.motherMiddleName = _data["motherMiddleName"];
            this.motherLastName = _data["motherLastName"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.talukaId = _data["talukaId"];
            this.talukaName = _data["talukaName"];
            this.districtId = _data["districtId"];
            this.districtName = _data["districtName"];
            this.enquiryTypeId = _data["enquiryTypeId"];
            this.referenceBy = _data["referenceBy"];
            this.enquiryStatusId = _data["enquiryStatusId"];
            this.emailId = _data["emailId"];
            this.userId = _data["userId"];
            this.className = _data["className"];
            this.paymentStatus = _data["paymentStatus"];
            this.paidAmount = _data["paidAmount"];
            if (Array.isArray(_data["enquiryTypeDropdownList"])) {
                this.enquiryTypeDropdownList = [] as any;
                for (let item of _data["enquiryTypeDropdownList"])
                    this.enquiryTypeDropdownList!.push(EnquiryTypeDropdownDto.fromJS(item));
            }
            if (Array.isArray(_data["enquiryStatusDropdownList"])) {
                this.enquiryStatusDropdownList = [] as any;
                for (let item of _data["enquiryStatusDropdownList"])
                    this.enquiryStatusDropdownList!.push(EnquiryStatusDropdownDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentEnquiryDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentEnquiryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentEnquiryId"] = this.studentEnquiryId;
        data["ngbEnquiryDate"] = this.ngbEnquiryDate ? this.ngbEnquiryDate.toJSON() : <any>undefined;
        data["enquiryDate"] = this.enquiryDate ? this.enquiryDate.toISOString() : <any>undefined;
        data["studentFirstName"] = this.studentFirstName;
        data["studentMiddleName"] = this.studentMiddleName;
        data["studentLastName"] = this.studentLastName;
        data["studentFullName"] = this.studentFullName;
        data["gender"] = this.gender;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["adharNo"] = this.adharNo;
        data["religion"] = this.religion;
        data["cast"] = this.cast;
        data["category"] = this.category;
        data["nationality"] = this.nationality;
        data["mobileNumber"] = this.mobileNumber;
        data["interestedClassId"] = this.interestedClassId;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["academicYearId"] = this.academicYearId;
        data["currentSchool"] = this.currentSchool;
        data["currentClass"] = this.currentClass;
        data["nameOfSiblingInCurrentSchool"] = this.nameOfSiblingInCurrentSchool;
        data["fatherFirstName"] = this.fatherFirstName;
        data["fatherMiddleName"] = this.fatherMiddleName;
        data["fatherLastName"] = this.fatherLastName;
        data["fatherFullName"] = this.fatherFullName;
        data["motherFirstName"] = this.motherFirstName;
        data["motherMiddleName"] = this.motherMiddleName;
        data["motherLastName"] = this.motherLastName;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["talukaId"] = this.talukaId;
        data["talukaName"] = this.talukaName;
        data["districtId"] = this.districtId;
        data["districtName"] = this.districtName;
        data["enquiryTypeId"] = this.enquiryTypeId;
        data["referenceBy"] = this.referenceBy;
        data["enquiryStatusId"] = this.enquiryStatusId;
        data["emailId"] = this.emailId;
        data["userId"] = this.userId;
        data["className"] = this.className;
        data["paymentStatus"] = this.paymentStatus;
        data["paidAmount"] = this.paidAmount;
        if (Array.isArray(this.enquiryTypeDropdownList)) {
            data["enquiryTypeDropdownList"] = [];
            for (let item of this.enquiryTypeDropdownList)
                data["enquiryTypeDropdownList"].push(item.toJSON());
        }
        if (Array.isArray(this.enquiryStatusDropdownList)) {
            data["enquiryStatusDropdownList"] = [];
            for (let item of this.enquiryStatusDropdownList)
                data["enquiryStatusDropdownList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentEnquiryDto {
        const json = this.toJSON();
        let result = new StudentEnquiryDto();
        result.init(json);
        return result;
    }
}

export interface IStudentEnquiryDto {
    studentEnquiryId: number;
    ngbEnquiryDate: SchoolNgbDateModel | undefined;
    enquiryDate: moment.Moment | undefined;
    studentFirstName: string | undefined;
    studentMiddleName: string | undefined;
    studentLastName: string | undefined;
    studentFullName: string | undefined;
    gender: string | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthDate: moment.Moment | undefined;
    adharNo: string | undefined;
    religion: string | undefined;
    cast: string | undefined;
    category: string | undefined;
    nationality: string | undefined;
    mobileNumber: string | undefined;
    interestedClassId: string | undefined;
    gradeName: string | undefined;
    divisionName: string | undefined;
    academicYearId: number | undefined;
    currentSchool: string | undefined;
    currentClass: string | undefined;
    nameOfSiblingInCurrentSchool: string | undefined;
    fatherFirstName: string | undefined;
    fatherMiddleName: string | undefined;
    fatherLastName: string | undefined;
    fatherFullName: string | undefined;
    motherFirstName: string | undefined;
    motherMiddleName: string | undefined;
    motherLastName: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    countryId: number | undefined;
    countryName: string | undefined;
    stateId: number | undefined;
    stateName: string | undefined;
    talukaId: number | undefined;
    talukaName: string | undefined;
    districtId: number | undefined;
    districtName: string | undefined;
    enquiryTypeId: number | undefined;
    referenceBy: string | undefined;
    enquiryStatusId: number | undefined;
    emailId: string | undefined;
    userId: number | undefined;
    className: string | undefined;
    paymentStatus: string | undefined;
    paidAmount: number | undefined;
    enquiryTypeDropdownList: EnquiryTypeDropdownDto[];
    enquiryStatusDropdownList: EnquiryStatusDropdownDto[];
}

export class EnquiryTypeDropdownDto implements IEnquiryTypeDropdownDto {
    enquiryTypeId!: number;
    enquiryTypeName!: string;

    constructor(data?: IEnquiryTypeDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enquiryTypeId = _data["enquiryTypeId"];
            this.enquiryTypeName = _data["enquiryTypeName"];
        }
    }

    static fromJS(data: any): EnquiryTypeDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnquiryTypeDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enquiryTypeId"] = this.enquiryTypeId;
        data["enquiryTypeName"] = this.enquiryTypeName;
        return data;
    }

    clone(): EnquiryTypeDropdownDto {
        const json = this.toJSON();
        let result = new EnquiryTypeDropdownDto();
        result.init(json);
        return result;
    }
}

export interface IEnquiryTypeDropdownDto {
    enquiryTypeId: number;
    enquiryTypeName: string;
}

export class EnquiryStatusDropdownDto implements IEnquiryStatusDropdownDto {
    enquiryStatusId!: number;
    enquiryStatusName!: string;

    constructor(data?: IEnquiryStatusDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enquiryStatusId = _data["enquiryStatusId"];
            this.enquiryStatusName = _data["enquiryStatusName"];
        }
    }

    static fromJS(data: any): EnquiryStatusDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnquiryStatusDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enquiryStatusId"] = this.enquiryStatusId;
        data["enquiryStatusName"] = this.enquiryStatusName;
        return data;
    }

    clone(): EnquiryStatusDropdownDto {
        const json = this.toJSON();
        let result = new EnquiryStatusDropdownDto();
        result.init(json);
        return result;
    }
}

export interface IEnquiryStatusDropdownDto {
    enquiryStatusId: number;
    enquiryStatusName: string;
}

export class StudentEnquiryIdModelResponse implements IStudentEnquiryIdModelResponse {
    exist!: number;

    constructor(data?: IStudentEnquiryIdModelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exist = _data["exist"];
        }
    }

    static fromJS(data: any): StudentEnquiryIdModelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StudentEnquiryIdModelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exist"] = this.exist;
        return data;
    }

    clone(): StudentEnquiryIdModelResponse {
        const json = this.toJSON();
        let result = new StudentEnquiryIdModelResponse();
        result.init(json);
        return result;
    }
}

export interface IStudentEnquiryIdModelResponse {
    exist: number;
}

export class StudentDocumentDto implements IStudentDocumentDto {
    studentId!: number;
    documentId!: number;
    documentName!: string;
    documentUrl!: string;
    documentFileType!: string;
    documentBase64Image!: string;
    documentImageContentType!: string;
    studentDocuments!: StudentDocumentTypeDto[];

    constructor(data?: IStudentDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.documentId = _data["documentId"];
            this.documentName = _data["documentName"];
            this.documentUrl = _data["documentUrl"];
            this.documentFileType = _data["documentFileType"];
            this.documentBase64Image = _data["documentBase64Image"];
            this.documentImageContentType = _data["documentImageContentType"];
            if (Array.isArray(_data["studentDocuments"])) {
                this.studentDocuments = [] as any;
                for (let item of _data["studentDocuments"])
                    this.studentDocuments!.push(StudentDocumentTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["documentId"] = this.documentId;
        data["documentName"] = this.documentName;
        data["documentUrl"] = this.documentUrl;
        data["documentFileType"] = this.documentFileType;
        data["documentBase64Image"] = this.documentBase64Image;
        data["documentImageContentType"] = this.documentImageContentType;
        if (Array.isArray(this.studentDocuments)) {
            data["studentDocuments"] = [];
            for (let item of this.studentDocuments)
                data["studentDocuments"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentDocumentDto {
        const json = this.toJSON();
        let result = new StudentDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IStudentDocumentDto {
    studentId: number;
    documentId: number;
    documentName: string;
    documentUrl: string;
    documentFileType: string;
    documentBase64Image: string;
    documentImageContentType: string;
    studentDocuments: StudentDocumentTypeDto[];
}

export class StudentDocumentTypeDto implements IStudentDocumentTypeDto {
    documentId!: number;
    documentName!: string;
    documentUrl!: string;
    documentFileType!: string;
    documentBase64Image!: string;
    documentImageContentType!: string;
    uploadedDate!: moment.Moment;

    constructor(data?: IStudentDocumentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.documentName = _data["documentName"];
            this.documentUrl = _data["documentUrl"];
            this.documentFileType = _data["documentFileType"];
            this.documentBase64Image = _data["documentBase64Image"];
            this.documentImageContentType = _data["documentImageContentType"];
            this.uploadedDate = _data["uploadedDate"] ? moment(_data["uploadedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StudentDocumentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDocumentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentName"] = this.documentName;
        data["documentUrl"] = this.documentUrl;
        data["documentFileType"] = this.documentFileType;
        data["documentBase64Image"] = this.documentBase64Image;
        data["documentImageContentType"] = this.documentImageContentType;
        data["uploadedDate"] = this.uploadedDate ? this.uploadedDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): StudentDocumentTypeDto {
        const json = this.toJSON();
        let result = new StudentDocumentTypeDto();
        result.init(json);
        return result;
    }
}

export interface IStudentDocumentTypeDto {
    documentId: number;
    documentName: string;
    documentUrl: string;
    documentFileType: string;
    documentBase64Image: string;
    documentImageContentType: string;
    uploadedDate: moment.Moment;
}

export class TeacherDropdownResponseDto implements ITeacherDropdownResponseDto {
    teacherDropdownList!: TeacherDropDownDto[];

    constructor(data?: ITeacherDropdownResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["teacherDropdownList"])) {
                this.teacherDropdownList = [] as any;
                for (let item of _data["teacherDropdownList"])
                    this.teacherDropdownList!.push(TeacherDropDownDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherDropdownResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDropdownResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.teacherDropdownList)) {
            data["teacherDropdownList"] = [];
            for (let item of this.teacherDropdownList)
                data["teacherDropdownList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeacherDropdownResponseDto {
        const json = this.toJSON();
        let result = new TeacherDropdownResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherDropdownResponseDto {
    teacherDropdownList: TeacherDropDownDto[];
}

export class TeacherDropDownDto implements ITeacherDropDownDto {
    teacherId!: number;
    fullName!: string;

    constructor(data?: ITeacherDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): TeacherDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): TeacherDropDownDto {
        const json = this.toJSON();
        let result = new TeacherDropDownDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherDropDownDto {
    teacherId: number;
    fullName: string;
}

export class StudentAttendanceMobileResponseDto implements IStudentAttendanceMobileResponseDto {
    lstStudentAttendance!: StudentAttendanceMobileDto[];

    constructor(data?: IStudentAttendanceMobileResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstStudentAttendance"])) {
                this.lstStudentAttendance = [] as any;
                for (let item of _data["lstStudentAttendance"])
                    this.lstStudentAttendance!.push(StudentAttendanceMobileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentAttendanceMobileResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceMobileResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstStudentAttendance)) {
            data["lstStudentAttendance"] = [];
            for (let item of this.lstStudentAttendance)
                data["lstStudentAttendance"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentAttendanceMobileResponseDto {
        const json = this.toJSON();
        let result = new StudentAttendanceMobileResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceMobileResponseDto {
    lstStudentAttendance: StudentAttendanceMobileDto[];
}

export class StudentAttendanceMobileDto implements IStudentAttendanceMobileDto {
    studentId!: number;
    studentAttendanceId!: number;
    teacherId!: number;
    attendanceDateTime!: moment.Moment | undefined;
    statusId!: number;

    constructor(data?: IStudentAttendanceMobileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.studentAttendanceId = _data["studentAttendanceId"];
            this.teacherId = _data["teacherId"];
            this.attendanceDateTime = _data["attendanceDateTime"] ? moment(_data["attendanceDateTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): StudentAttendanceMobileDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceMobileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["studentAttendanceId"] = this.studentAttendanceId;
        data["teacherId"] = this.teacherId;
        data["attendanceDateTime"] = this.attendanceDateTime ? this.attendanceDateTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        return data;
    }

    clone(): StudentAttendanceMobileDto {
        const json = this.toJSON();
        let result = new StudentAttendanceMobileDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceMobileDto {
    studentId: number;
    studentAttendanceId: number;
    teacherId: number;
    attendanceDateTime: moment.Moment | undefined;
    statusId: number;
}

export class SchoolVacationDto implements ISchoolVacationDto {
    schoolVacationId!: number;
    academicYearId!: number | undefined;
    vacationName!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    userId!: number;

    constructor(data?: ISchoolVacationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolVacationId = _data["schoolVacationId"];
            this.academicYearId = _data["academicYearId"];
            this.vacationName = _data["vacationName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): SchoolVacationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolVacationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolVacationId"] = this.schoolVacationId;
        data["academicYearId"] = this.academicYearId;
        data["vacationName"] = this.vacationName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        return data;
    }

    clone(): SchoolVacationDto {
        const json = this.toJSON();
        let result = new SchoolVacationDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolVacationDto {
    schoolVacationId: number;
    academicYearId: number | undefined;
    vacationName: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    userId: number;
}

export class SchoolHolidayResponseDto implements ISchoolHolidayResponseDto {
    academicYearId!: number;
    userId!: number;
    holidayTypeDetailsList!: SchoolHolidayDetailDto[] | undefined;

    constructor(data?: ISchoolHolidayResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["holidayTypeDetailsList"])) {
                this.holidayTypeDetailsList = [] as any;
                for (let item of _data["holidayTypeDetailsList"])
                    this.holidayTypeDetailsList!.push(SchoolHolidayDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolHolidayResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolHolidayResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["userId"] = this.userId;
        if (Array.isArray(this.holidayTypeDetailsList)) {
            data["holidayTypeDetailsList"] = [];
            for (let item of this.holidayTypeDetailsList)
                data["holidayTypeDetailsList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolHolidayResponseDto {
        const json = this.toJSON();
        let result = new SchoolHolidayResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolHolidayResponseDto {
    academicYearId: number;
    userId: number;
    holidayTypeDetailsList: SchoolHolidayDetailDto[] | undefined;
}

export class SchoolHolidayDetailDto implements ISchoolHolidayDetailDto {
    schoolHolidayId!: number;
    academicYearId!: number;
    dayNo!: number;
    calendarDate!: moment.Moment | undefined;
    ngbCalendarDate!: SchoolNgbDateModel | undefined;
    holidayReason!: string;

    constructor(data?: ISchoolHolidayDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolHolidayId = _data["schoolHolidayId"];
            this.academicYearId = _data["academicYearId"];
            this.dayNo = _data["dayNo"];
            this.calendarDate = _data["calendarDate"] ? moment(_data["calendarDate"].toString()) : <any>undefined;
            this.ngbCalendarDate = _data["ngbCalendarDate"] ? SchoolNgbDateModel.fromJS(_data["ngbCalendarDate"]) : <any>undefined;
            this.holidayReason = _data["holidayReason"];
        }
    }

    static fromJS(data: any): SchoolHolidayDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolHolidayDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolHolidayId"] = this.schoolHolidayId;
        data["academicYearId"] = this.academicYearId;
        data["dayNo"] = this.dayNo;
        data["calendarDate"] = this.calendarDate ? this.calendarDate.toISOString() : <any>undefined;
        data["ngbCalendarDate"] = this.ngbCalendarDate ? this.ngbCalendarDate.toJSON() : <any>undefined;
        data["holidayReason"] = this.holidayReason;
        return data;
    }

    clone(): SchoolHolidayDetailDto {
        const json = this.toJSON();
        let result = new SchoolHolidayDetailDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolHolidayDetailDto {
    schoolHolidayId: number;
    academicYearId: number;
    dayNo: number;
    calendarDate: moment.Moment | undefined;
    ngbCalendarDate: SchoolNgbDateModel | undefined;
    holidayReason: string;
}

export class ExistResposeDto implements IExistResposeDto {
    academicYearId!: number | undefined;
    calendarDate!: moment.Moment | undefined;
    exist!: number | undefined;

    constructor(data?: IExistResposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.calendarDate = _data["calendarDate"] ? moment(_data["calendarDate"].toString()) : <any>undefined;
            this.exist = _data["exist"];
        }
    }

    static fromJS(data: any): ExistResposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExistResposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["calendarDate"] = this.calendarDate ? this.calendarDate.toISOString() : <any>undefined;
        data["exist"] = this.exist;
        return data;
    }

    clone(): ExistResposeDto {
        const json = this.toJSON();
        let result = new ExistResposeDto();
        result.init(json);
        return result;
    }
}

export interface IExistResposeDto {
    academicYearId: number | undefined;
    calendarDate: moment.Moment | undefined;
    exist: number | undefined;
}

export class CalendarDateRequestDto implements ICalendarDateRequestDto {
    calendarDate!: moment.Moment | undefined;
    ngbCalendarDate!: SchoolNgbDateModel | undefined;

    constructor(data?: ICalendarDateRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calendarDate = _data["calendarDate"] ? moment(_data["calendarDate"].toString()) : <any>undefined;
            this.ngbCalendarDate = _data["ngbCalendarDate"] ? SchoolNgbDateModel.fromJS(_data["ngbCalendarDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CalendarDateRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarDateRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarDate"] = this.calendarDate ? this.calendarDate.toISOString() : <any>undefined;
        data["ngbCalendarDate"] = this.ngbCalendarDate ? this.ngbCalendarDate.toJSON() : <any>undefined;
        return data;
    }

    clone(): CalendarDateRequestDto {
        const json = this.toJSON();
        let result = new CalendarDateRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICalendarDateRequestDto {
    calendarDate: moment.Moment | undefined;
    ngbCalendarDate: SchoolNgbDateModel | undefined;
}

export class SchoolEventDto implements ISchoolEventDto {
    schoolEventId!: number;
    academicYearId!: number | undefined;
    gradeId!: number | undefined;
    gradeName!: string;
    divisionId!: number | undefined;
    divisionName!: string | undefined;
    classId!: (number | undefined)[];
    eventTitle!: string;
    eventDescription!: string;
    eventFess!: number;
    eventVenue!: string;
    eventCoordinator!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    startTime!: moment.Moment | undefined;
    ngbStartTime!: SchoolNgbTimeModel | undefined;
    endTime!: moment.Moment | undefined;
    ngbEndTime!: SchoolNgbTimeModel | undefined;
    isCompulsory!: boolean;
    isPublished!: boolean;
    status!: string;
    remark!: string;
    createdBy!: string;
    modifiedBy!: string;
    createdDate!: string;
    modifiedDate!: string;
    userId!: number;
    fileNameList!: SchoolEventFileDto[];
    mediaFileArray!: SchoolEventFileDto[];

    constructor(data?: ISchoolEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
            this.eventTitle = _data["eventTitle"];
            this.eventDescription = _data["eventDescription"];
            this.eventFess = _data["eventFess"];
            this.eventVenue = _data["eventVenue"];
            this.eventCoordinator = _data["eventCoordinator"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.ngbStartTime = _data["ngbStartTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbStartTime"]) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.ngbEndTime = _data["ngbEndTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbEndTime"]) : <any>undefined;
            this.isCompulsory = _data["isCompulsory"];
            this.isPublished = _data["isPublished"];
            this.status = _data["status"];
            this.remark = _data["remark"];
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["fileNameList"])) {
                this.fileNameList = [] as any;
                for (let item of _data["fileNameList"])
                    this.fileNameList!.push(SchoolEventFileDto.fromJS(item));
            }
            if (Array.isArray(_data["mediaFileArray"])) {
                this.mediaFileArray = [] as any;
                for (let item of _data["mediaFileArray"])
                    this.mediaFileArray!.push(SchoolEventFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        data["eventTitle"] = this.eventTitle;
        data["eventDescription"] = this.eventDescription;
        data["eventFess"] = this.eventFess;
        data["eventVenue"] = this.eventVenue;
        data["eventCoordinator"] = this.eventCoordinator;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["ngbStartTime"] = this.ngbStartTime ? this.ngbStartTime.toJSON() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["ngbEndTime"] = this.ngbEndTime ? this.ngbEndTime.toJSON() : <any>undefined;
        data["isCompulsory"] = this.isCompulsory;
        data["isPublished"] = this.isPublished;
        data["status"] = this.status;
        data["remark"] = this.remark;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        data["userId"] = this.userId;
        if (Array.isArray(this.fileNameList)) {
            data["fileNameList"] = [];
            for (let item of this.fileNameList)
                data["fileNameList"].push(item.toJSON());
        }
        if (Array.isArray(this.mediaFileArray)) {
            data["mediaFileArray"] = [];
            for (let item of this.mediaFileArray)
                data["mediaFileArray"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolEventDto {
        const json = this.toJSON();
        let result = new SchoolEventDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolEventDto {
    schoolEventId: number;
    academicYearId: number | undefined;
    gradeId: number | undefined;
    gradeName: string;
    divisionId: number | undefined;
    divisionName: string | undefined;
    classId: (number | undefined)[];
    eventTitle: string;
    eventDescription: string;
    eventFess: number;
    eventVenue: string;
    eventCoordinator: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    startTime: moment.Moment | undefined;
    ngbStartTime: SchoolNgbTimeModel | undefined;
    endTime: moment.Moment | undefined;
    ngbEndTime: SchoolNgbTimeModel | undefined;
    isCompulsory: boolean;
    isPublished: boolean;
    status: string;
    remark: string;
    createdBy: string;
    modifiedBy: string;
    createdDate: string;
    modifiedDate: string;
    userId: number;
    fileNameList: SchoolEventFileDto[];
    mediaFileArray: SchoolEventFileDto[];
}

export class SchoolEventFileDto implements ISchoolEventFileDto {
    base64Image!: string;
    imageContentType!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: ISchoolEventFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64Image = _data["base64Image"];
            this.imageContentType = _data["imageContentType"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): SchoolEventFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolEventFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64Image"] = this.base64Image;
        data["imageContentType"] = this.imageContentType;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): SchoolEventFileDto {
        const json = this.toJSON();
        let result = new SchoolEventFileDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolEventFileDto {
    base64Image: string;
    imageContentType: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class PublishUnpublishSchoolEventDto implements IPublishUnpublishSchoolEventDto {
    schoolEventId!: number;
    isPublished!: boolean;
    classId!: number | undefined;

    constructor(data?: IPublishUnpublishSchoolEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.isPublished = _data["isPublished"];
            this.classId = _data["classId"];
        }
    }

    static fromJS(data: any): PublishUnpublishSchoolEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishUnpublishSchoolEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["isPublished"] = this.isPublished;
        data["classId"] = this.classId;
        return data;
    }

    clone(): PublishUnpublishSchoolEventDto {
        const json = this.toJSON();
        let result = new PublishUnpublishSchoolEventDto();
        result.init(json);
        return result;
    }
}

export interface IPublishUnpublishSchoolEventDto {
    schoolEventId: number;
    isPublished: boolean;
    classId: number | undefined;
}

export class SchoolCalendarResponseDto implements ISchoolCalendarResponseDto {
    eventHolidayList!: SchoolCalendarDto[] | undefined;

    constructor(data?: ISchoolCalendarResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["eventHolidayList"])) {
                this.eventHolidayList = [] as any;
                for (let item of _data["eventHolidayList"])
                    this.eventHolidayList!.push(SchoolCalendarDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolCalendarResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolCalendarResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.eventHolidayList)) {
            data["eventHolidayList"] = [];
            for (let item of this.eventHolidayList)
                data["eventHolidayList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolCalendarResponseDto {
        const json = this.toJSON();
        let result = new SchoolCalendarResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolCalendarResponseDto {
    eventHolidayList: SchoolCalendarDto[] | undefined;
}

export class SchoolCalendarDto implements ISchoolCalendarDto {
    eventType!: string;
    id!: number;
    academicYearId!: number | undefined;
    eventTitle!: string;
    eventFess!: number;
    eventCoordinator!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    startTime!: moment.Moment | undefined;
    ngbStartTime!: SchoolNgbTimeModel | undefined;
    endTime!: moment.Moment | undefined;
    ngbEndTime!: SchoolNgbTimeModel | undefined;
    isPublished!: boolean;
    isCompulsory!: boolean;
    calendarDate!: moment.Moment | undefined;
    ngbCalendarDate!: SchoolNgbDateModel | undefined;
    holidayReason!: string;
    eventDescription!: string;
    vacationName!: string;
    weeklyOffName!: string;
    vacationStartDate!: moment.Moment | undefined;
    ngbVacationStartDate!: SchoolNgbDateModel | undefined;
    vacationEndDate!: moment.Moment | undefined;
    ngbVacationEndDate!: SchoolNgbDateModel | undefined;
    weeklyOffDate!: moment.Moment | undefined;
    ngbWeeklyOffDate!: SchoolNgbDateModel | undefined;
    lstEventDetail!: SchoolCalendarEventDetailAppDto[];

    constructor(data?: ISchoolCalendarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventType = _data["eventType"];
            this.id = _data["id"];
            this.academicYearId = _data["academicYearId"];
            this.eventTitle = _data["eventTitle"];
            this.eventFess = _data["eventFess"];
            this.eventCoordinator = _data["eventCoordinator"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.ngbStartTime = _data["ngbStartTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbStartTime"]) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.ngbEndTime = _data["ngbEndTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbEndTime"]) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.isCompulsory = _data["isCompulsory"];
            this.calendarDate = _data["calendarDate"] ? moment(_data["calendarDate"].toString()) : <any>undefined;
            this.ngbCalendarDate = _data["ngbCalendarDate"] ? SchoolNgbDateModel.fromJS(_data["ngbCalendarDate"]) : <any>undefined;
            this.holidayReason = _data["holidayReason"];
            this.eventDescription = _data["eventDescription"];
            this.vacationName = _data["vacationName"];
            this.weeklyOffName = _data["weeklyOffName"];
            this.vacationStartDate = _data["vacationStartDate"] ? moment(_data["vacationStartDate"].toString()) : <any>undefined;
            this.ngbVacationStartDate = _data["ngbVacationStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVacationStartDate"]) : <any>undefined;
            this.vacationEndDate = _data["vacationEndDate"] ? moment(_data["vacationEndDate"].toString()) : <any>undefined;
            this.ngbVacationEndDate = _data["ngbVacationEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVacationEndDate"]) : <any>undefined;
            this.weeklyOffDate = _data["weeklyOffDate"] ? moment(_data["weeklyOffDate"].toString()) : <any>undefined;
            this.ngbWeeklyOffDate = _data["ngbWeeklyOffDate"] ? SchoolNgbDateModel.fromJS(_data["ngbWeeklyOffDate"]) : <any>undefined;
            if (Array.isArray(_data["lstEventDetail"])) {
                this.lstEventDetail = [] as any;
                for (let item of _data["lstEventDetail"])
                    this.lstEventDetail!.push(SchoolCalendarEventDetailAppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolCalendarDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolCalendarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventType"] = this.eventType;
        data["id"] = this.id;
        data["academicYearId"] = this.academicYearId;
        data["eventTitle"] = this.eventTitle;
        data["eventFess"] = this.eventFess;
        data["eventCoordinator"] = this.eventCoordinator;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["ngbStartTime"] = this.ngbStartTime ? this.ngbStartTime.toJSON() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["ngbEndTime"] = this.ngbEndTime ? this.ngbEndTime.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["isCompulsory"] = this.isCompulsory;
        data["calendarDate"] = this.calendarDate ? this.calendarDate.toISOString() : <any>undefined;
        data["ngbCalendarDate"] = this.ngbCalendarDate ? this.ngbCalendarDate.toJSON() : <any>undefined;
        data["holidayReason"] = this.holidayReason;
        data["eventDescription"] = this.eventDescription;
        data["vacationName"] = this.vacationName;
        data["weeklyOffName"] = this.weeklyOffName;
        data["vacationStartDate"] = this.vacationStartDate ? this.vacationStartDate.toISOString() : <any>undefined;
        data["ngbVacationStartDate"] = this.ngbVacationStartDate ? this.ngbVacationStartDate.toJSON() : <any>undefined;
        data["vacationEndDate"] = this.vacationEndDate ? this.vacationEndDate.toISOString() : <any>undefined;
        data["ngbVacationEndDate"] = this.ngbVacationEndDate ? this.ngbVacationEndDate.toJSON() : <any>undefined;
        data["weeklyOffDate"] = this.weeklyOffDate ? this.weeklyOffDate.toISOString() : <any>undefined;
        data["ngbWeeklyOffDate"] = this.ngbWeeklyOffDate ? this.ngbWeeklyOffDate.toJSON() : <any>undefined;
        if (Array.isArray(this.lstEventDetail)) {
            data["lstEventDetail"] = [];
            for (let item of this.lstEventDetail)
                data["lstEventDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolCalendarDto {
        const json = this.toJSON();
        let result = new SchoolCalendarDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolCalendarDto {
    eventType: string;
    id: number;
    academicYearId: number | undefined;
    eventTitle: string;
    eventFess: number;
    eventCoordinator: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    startTime: moment.Moment | undefined;
    ngbStartTime: SchoolNgbTimeModel | undefined;
    endTime: moment.Moment | undefined;
    ngbEndTime: SchoolNgbTimeModel | undefined;
    isPublished: boolean;
    isCompulsory: boolean;
    calendarDate: moment.Moment | undefined;
    ngbCalendarDate: SchoolNgbDateModel | undefined;
    holidayReason: string;
    eventDescription: string;
    vacationName: string;
    weeklyOffName: string;
    vacationStartDate: moment.Moment | undefined;
    ngbVacationStartDate: SchoolNgbDateModel | undefined;
    vacationEndDate: moment.Moment | undefined;
    ngbVacationEndDate: SchoolNgbDateModel | undefined;
    weeklyOffDate: moment.Moment | undefined;
    ngbWeeklyOffDate: SchoolNgbDateModel | undefined;
    lstEventDetail: SchoolCalendarEventDetailAppDto[];
}

export class SchoolCalendarEventDetailAppDto implements ISchoolCalendarEventDetailAppDto {
    schoolEventId!: number;
    schoolEventDetailsId!: number;
    fileName!: string;
    fullPath!: string;

    constructor(data?: ISchoolCalendarEventDetailAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.schoolEventDetailsId = _data["schoolEventDetailsId"];
            this.fileName = _data["fileName"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): SchoolCalendarEventDetailAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolCalendarEventDetailAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["schoolEventDetailsId"] = this.schoolEventDetailsId;
        data["fileName"] = this.fileName;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): SchoolCalendarEventDetailAppDto {
        const json = this.toJSON();
        let result = new SchoolCalendarEventDetailAppDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolCalendarEventDetailAppDto {
    schoolEventId: number;
    schoolEventDetailsId: number;
    fileName: string;
    fullPath: string;
}

export class SchoolCalendarAppResponseDto implements ISchoolCalendarAppResponseDto {
    lstEvents!: SchoolCalendarDto[];

    constructor(data?: ISchoolCalendarAppResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstEvents"])) {
                this.lstEvents = [] as any;
                for (let item of _data["lstEvents"])
                    this.lstEvents!.push(SchoolCalendarDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolCalendarAppResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolCalendarAppResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstEvents)) {
            data["lstEvents"] = [];
            for (let item of this.lstEvents)
                data["lstEvents"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolCalendarAppResponseDto {
        const json = this.toJSON();
        let result = new SchoolCalendarAppResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolCalendarAppResponseDto {
    lstEvents: SchoolCalendarDto[];
}

export class RegistrationFeePaymentSelectDto implements IRegistrationFeePaymentSelectDto {
    studentFullName!: string;
    onlineTransactionId!: string;
    paidToBank!: string;
    paymentTypeId!: number;
    paymentInstallmentDone!: number;
    academicYearId!: number;
    registrationFeeParticularList!: RegistrationFeeParticularSelectDto[];

    constructor(data?: IRegistrationFeePaymentSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentFullName = _data["studentFullName"];
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.paidToBank = _data["paidToBank"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.paymentInstallmentDone = _data["paymentInstallmentDone"];
            this.academicYearId = _data["academicYearId"];
            if (Array.isArray(_data["registrationFeeParticularList"])) {
                this.registrationFeeParticularList = [] as any;
                for (let item of _data["registrationFeeParticularList"])
                    this.registrationFeeParticularList!.push(RegistrationFeeParticularSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistrationFeePaymentSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationFeePaymentSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentFullName"] = this.studentFullName;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["paidToBank"] = this.paidToBank;
        data["paymentTypeId"] = this.paymentTypeId;
        data["paymentInstallmentDone"] = this.paymentInstallmentDone;
        data["academicYearId"] = this.academicYearId;
        if (Array.isArray(this.registrationFeeParticularList)) {
            data["registrationFeeParticularList"] = [];
            for (let item of this.registrationFeeParticularList)
                data["registrationFeeParticularList"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegistrationFeePaymentSelectDto {
        const json = this.toJSON();
        let result = new RegistrationFeePaymentSelectDto();
        result.init(json);
        return result;
    }
}

export interface IRegistrationFeePaymentSelectDto {
    studentFullName: string;
    onlineTransactionId: string;
    paidToBank: string;
    paymentTypeId: number;
    paymentInstallmentDone: number;
    academicYearId: number;
    registrationFeeParticularList: RegistrationFeeParticularSelectDto[];
}

export class RegistrationFeeParticularSelectDto implements IRegistrationFeeParticularSelectDto {
    feeParticularId!: number;
    adhocParticularMasterId!: number;
    particularName!: string;
    isDiscountApplicable!: boolean;
    totalFee!: number;
    alreadyPaid!: number;
    academicYearId!: number;

    constructor(data?: IRegistrationFeeParticularSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularId = _data["feeParticularId"];
            this.adhocParticularMasterId = _data["adhocParticularMasterId"];
            this.particularName = _data["particularName"];
            this.isDiscountApplicable = _data["isDiscountApplicable"];
            this.totalFee = _data["totalFee"];
            this.alreadyPaid = _data["alreadyPaid"];
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): RegistrationFeeParticularSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationFeeParticularSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularId"] = this.feeParticularId;
        data["adhocParticularMasterId"] = this.adhocParticularMasterId;
        data["particularName"] = this.particularName;
        data["isDiscountApplicable"] = this.isDiscountApplicable;
        data["totalFee"] = this.totalFee;
        data["alreadyPaid"] = this.alreadyPaid;
        data["academicYearId"] = this.academicYearId;
        return data;
    }

    clone(): RegistrationFeeParticularSelectDto {
        const json = this.toJSON();
        let result = new RegistrationFeeParticularSelectDto();
        result.init(json);
        return result;
    }
}

export interface IRegistrationFeeParticularSelectDto {
    feeParticularId: number;
    adhocParticularMasterId: number;
    particularName: string;
    isDiscountApplicable: boolean;
    totalFee: number;
    alreadyPaid: number;
    academicYearId: number;
}

export class RegistrationFeePaymentDto implements IRegistrationFeePaymentDto {
    studentEnquiryId!: number;
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    onlineTransactionId!: string | undefined;
    onlineTransactionDateTime!: moment.Moment | undefined;
    ngbOnlineTransactionDateTime!: SchoolNgbDateModel | undefined;
    onlinePaymentRequest!: string;
    onlinePaymentResponse!: string;
    paidToBank!: string;
    totalFee!: number | undefined;
    particularId!: number | undefined;
    paymentTypeId!: number | undefined;
    chequeNumber!: string;
    chequeDate!: moment.Moment | undefined;
    ngbChequeDate!: SchoolNgbDateModel | undefined;
    chequeBank!: string;
    chequeAmount!: number | undefined;
    isChequeClear!: boolean | undefined;
    remark!: string;
    userId!: number | undefined;
    registrationFeeDetailsParticularList!: RegistrationFeeDetailsTypeDto[];

    constructor(data?: IRegistrationFeePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentEnquiryId = _data["studentEnquiryId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"] ? moment(_data["onlineTransactionDateTime"].toString()) : <any>undefined;
            this.ngbOnlineTransactionDateTime = _data["ngbOnlineTransactionDateTime"] ? SchoolNgbDateModel.fromJS(_data["ngbOnlineTransactionDateTime"]) : <any>undefined;
            this.onlinePaymentRequest = _data["onlinePaymentRequest"];
            this.onlinePaymentResponse = _data["onlinePaymentResponse"];
            this.paidToBank = _data["paidToBank"];
            this.totalFee = _data["totalFee"];
            this.particularId = _data["particularId"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.ngbChequeDate = _data["ngbChequeDate"] ? SchoolNgbDateModel.fromJS(_data["ngbChequeDate"]) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.chequeAmount = _data["chequeAmount"];
            this.isChequeClear = _data["isChequeClear"];
            this.remark = _data["remark"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["registrationFeeDetailsParticularList"])) {
                this.registrationFeeDetailsParticularList = [] as any;
                for (let item of _data["registrationFeeDetailsParticularList"])
                    this.registrationFeeDetailsParticularList!.push(RegistrationFeeDetailsTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistrationFeePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationFeePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentEnquiryId"] = this.studentEnquiryId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime ? this.onlineTransactionDateTime.toISOString() : <any>undefined;
        data["ngbOnlineTransactionDateTime"] = this.ngbOnlineTransactionDateTime ? this.ngbOnlineTransactionDateTime.toJSON() : <any>undefined;
        data["onlinePaymentRequest"] = this.onlinePaymentRequest;
        data["onlinePaymentResponse"] = this.onlinePaymentResponse;
        data["paidToBank"] = this.paidToBank;
        data["totalFee"] = this.totalFee;
        data["particularId"] = this.particularId;
        data["paymentTypeId"] = this.paymentTypeId;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["ngbChequeDate"] = this.ngbChequeDate ? this.ngbChequeDate.toJSON() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["chequeAmount"] = this.chequeAmount;
        data["isChequeClear"] = this.isChequeClear;
        data["remark"] = this.remark;
        data["userId"] = this.userId;
        if (Array.isArray(this.registrationFeeDetailsParticularList)) {
            data["registrationFeeDetailsParticularList"] = [];
            for (let item of this.registrationFeeDetailsParticularList)
                data["registrationFeeDetailsParticularList"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegistrationFeePaymentDto {
        const json = this.toJSON();
        let result = new RegistrationFeePaymentDto();
        result.init(json);
        return result;
    }
}

export interface IRegistrationFeePaymentDto {
    studentEnquiryId: number;
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    onlineTransactionId: string | undefined;
    onlineTransactionDateTime: moment.Moment | undefined;
    ngbOnlineTransactionDateTime: SchoolNgbDateModel | undefined;
    onlinePaymentRequest: string;
    onlinePaymentResponse: string;
    paidToBank: string;
    totalFee: number | undefined;
    particularId: number | undefined;
    paymentTypeId: number | undefined;
    chequeNumber: string;
    chequeDate: moment.Moment | undefined;
    ngbChequeDate: SchoolNgbDateModel | undefined;
    chequeBank: string;
    chequeAmount: number | undefined;
    isChequeClear: boolean | undefined;
    remark: string;
    userId: number | undefined;
    registrationFeeDetailsParticularList: RegistrationFeeDetailsTypeDto[];
}

export class RegistrationFeeDetailsTypeDto implements IRegistrationFeeDetailsTypeDto {
    feeParticularId!: number;
    invoiceNumber!: string;
    paymentTypeId!: number;
    paidAmount!: number;

    constructor(data?: IRegistrationFeeDetailsTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularId = _data["feeParticularId"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.paidAmount = _data["paidAmount"];
        }
    }

    static fromJS(data: any): RegistrationFeeDetailsTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationFeeDetailsTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularId"] = this.feeParticularId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["paymentTypeId"] = this.paymentTypeId;
        data["paidAmount"] = this.paidAmount;
        return data;
    }

    clone(): RegistrationFeeDetailsTypeDto {
        const json = this.toJSON();
        let result = new RegistrationFeeDetailsTypeDto();
        result.init(json);
        return result;
    }
}

export interface IRegistrationFeeDetailsTypeDto {
    feeParticularId: number;
    invoiceNumber: string;
    paymentTypeId: number;
    paidAmount: number;
}

export class RegistrationFeePaymentHistorySelectDto implements IRegistrationFeePaymentHistorySelectDto {
    schoolName!: string;
    schoolAddress!: string;
    academicYearId!: number;
    studentName!: string;
    gradeName!: string;
    divisionName!: string;
    paymentTypeName!: string;
    paymentDate!: moment.Moment | undefined;
    registrationFeeId!: number;
    onlineTransactionId!: string;
    registrationInvoiceNumber!: string;
    paidAmount!: number;
    onlineTransactionDateTime!: string;
    paidToBank!: string;
    feeParticularsSelectList!: RegistrationFeeParticularSelectDto[];

    constructor(data?: IRegistrationFeePaymentHistorySelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.schoolAddress = _data["schoolAddress"];
            this.academicYearId = _data["academicYearId"];
            this.studentName = _data["studentName"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.registrationFeeId = _data["registrationFeeId"];
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.registrationInvoiceNumber = _data["registrationInvoiceNumber"];
            this.paidAmount = _data["paidAmount"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"];
            this.paidToBank = _data["paidToBank"];
            if (Array.isArray(_data["feeParticularsSelectList"])) {
                this.feeParticularsSelectList = [] as any;
                for (let item of _data["feeParticularsSelectList"])
                    this.feeParticularsSelectList!.push(RegistrationFeeParticularSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistrationFeePaymentHistorySelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationFeePaymentHistorySelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["schoolAddress"] = this.schoolAddress;
        data["academicYearId"] = this.academicYearId;
        data["studentName"] = this.studentName;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["paymentTypeName"] = this.paymentTypeName;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["registrationFeeId"] = this.registrationFeeId;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["registrationInvoiceNumber"] = this.registrationInvoiceNumber;
        data["paidAmount"] = this.paidAmount;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime;
        data["paidToBank"] = this.paidToBank;
        if (Array.isArray(this.feeParticularsSelectList)) {
            data["feeParticularsSelectList"] = [];
            for (let item of this.feeParticularsSelectList)
                data["feeParticularsSelectList"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegistrationFeePaymentHistorySelectDto {
        const json = this.toJSON();
        let result = new RegistrationFeePaymentHistorySelectDto();
        result.init(json);
        return result;
    }
}

export interface IRegistrationFeePaymentHistorySelectDto {
    schoolName: string;
    schoolAddress: string;
    academicYearId: number;
    studentName: string;
    gradeName: string;
    divisionName: string;
    paymentTypeName: string;
    paymentDate: moment.Moment | undefined;
    registrationFeeId: number;
    onlineTransactionId: string;
    registrationInvoiceNumber: string;
    paidAmount: number;
    onlineTransactionDateTime: string;
    paidToBank: string;
    feeParticularsSelectList: RegistrationFeeParticularSelectDto[];
}

export class PromoteGridResponseDto implements IPromoteGridResponseDto {
    promoteList!: PromoteGridDto[] | undefined;

    constructor(data?: IPromoteGridResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["promoteList"])) {
                this.promoteList = [] as any;
                for (let item of _data["promoteList"])
                    this.promoteList!.push(PromoteGridDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PromoteGridResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PromoteGridResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.promoteList)) {
            data["promoteList"] = [];
            for (let item of this.promoteList)
                data["promoteList"].push(item.toJSON());
        }
        return data;
    }

    clone(): PromoteGridResponseDto {
        const json = this.toJSON();
        let result = new PromoteGridResponseDto();
        result.init(json);
        return result;
    }
}

export interface IPromoteGridResponseDto {
    promoteList: PromoteGridDto[] | undefined;
}

export class PromoteGridDto implements IPromoteGridDto {
    academicYearId!: number;
    studentId!: number;
    fullName!: string;
    rollNumber!: string;
    userId!: number;
    isPassed!: boolean | undefined;
    promotedAcademicYearId!: number | undefined;
    promotedGradeId!: number | undefined;
    promotedDivisionId!: number | undefined;
    statusId!: number;
    isChecked!: boolean | undefined;

    constructor(data?: IPromoteGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.studentId = _data["studentId"];
            this.fullName = _data["fullName"];
            this.rollNumber = _data["rollNumber"];
            this.userId = _data["userId"];
            this.isPassed = _data["isPassed"];
            this.promotedAcademicYearId = _data["promotedAcademicYearId"];
            this.promotedGradeId = _data["promotedGradeId"];
            this.promotedDivisionId = _data["promotedDivisionId"];
            this.statusId = _data["statusId"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): PromoteGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new PromoteGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["studentId"] = this.studentId;
        data["fullName"] = this.fullName;
        data["rollNumber"] = this.rollNumber;
        data["userId"] = this.userId;
        data["isPassed"] = this.isPassed;
        data["promotedAcademicYearId"] = this.promotedAcademicYearId;
        data["promotedGradeId"] = this.promotedGradeId;
        data["promotedDivisionId"] = this.promotedDivisionId;
        data["statusId"] = this.statusId;
        data["isChecked"] = this.isChecked;
        return data;
    }

    clone(): PromoteGridDto {
        const json = this.toJSON();
        let result = new PromoteGridDto();
        result.init(json);
        return result;
    }
}

export interface IPromoteGridDto {
    academicYearId: number;
    studentId: number;
    fullName: string;
    rollNumber: string;
    userId: number;
    isPassed: boolean | undefined;
    promotedAcademicYearId: number | undefined;
    promotedGradeId: number | undefined;
    promotedDivisionId: number | undefined;
    statusId: number;
    isChecked: boolean | undefined;
}

export class PromoteGridRequestDto implements IPromoteGridRequestDto {
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;

    constructor(data?: IPromoteGridRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
        }
    }

    static fromJS(data: any): PromoteGridRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PromoteGridRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        return data;
    }

    clone(): PromoteGridRequestDto {
        const json = this.toJSON();
        let result = new PromoteGridRequestDto();
        result.init(json);
        return result;
    }
}

export interface IPromoteGridRequestDto {
    academicYearId: number;
    gradeId: number;
    divisionId: number;
}

export class PaymentAnalyticsDto implements IPaymentAnalyticsDto {
    paymentAnalyticsSchool!: PaymentAnalyticsSchoolDto;
    paymentAnalyticsGrade!: PaymentAnalyticsGradeDto[];
    paymentAnalyticsDivision!: PaymentAnalyticsDivisionDto[];
    paymentAnalyticsStudent!: PaymentAnalyticsStudentDto[];

    constructor(data?: IPaymentAnalyticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentAnalyticsSchool = _data["paymentAnalyticsSchool"] ? PaymentAnalyticsSchoolDto.fromJS(_data["paymentAnalyticsSchool"]) : <any>undefined;
            if (Array.isArray(_data["paymentAnalyticsGrade"])) {
                this.paymentAnalyticsGrade = [] as any;
                for (let item of _data["paymentAnalyticsGrade"])
                    this.paymentAnalyticsGrade!.push(PaymentAnalyticsGradeDto.fromJS(item));
            }
            if (Array.isArray(_data["paymentAnalyticsDivision"])) {
                this.paymentAnalyticsDivision = [] as any;
                for (let item of _data["paymentAnalyticsDivision"])
                    this.paymentAnalyticsDivision!.push(PaymentAnalyticsDivisionDto.fromJS(item));
            }
            if (Array.isArray(_data["paymentAnalyticsStudent"])) {
                this.paymentAnalyticsStudent = [] as any;
                for (let item of _data["paymentAnalyticsStudent"])
                    this.paymentAnalyticsStudent!.push(PaymentAnalyticsStudentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentAnalyticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentAnalyticsSchool"] = this.paymentAnalyticsSchool ? this.paymentAnalyticsSchool.toJSON() : <any>undefined;
        if (Array.isArray(this.paymentAnalyticsGrade)) {
            data["paymentAnalyticsGrade"] = [];
            for (let item of this.paymentAnalyticsGrade)
                data["paymentAnalyticsGrade"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentAnalyticsDivision)) {
            data["paymentAnalyticsDivision"] = [];
            for (let item of this.paymentAnalyticsDivision)
                data["paymentAnalyticsDivision"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentAnalyticsStudent)) {
            data["paymentAnalyticsStudent"] = [];
            for (let item of this.paymentAnalyticsStudent)
                data["paymentAnalyticsStudent"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaymentAnalyticsDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsDto {
    paymentAnalyticsSchool: PaymentAnalyticsSchoolDto;
    paymentAnalyticsGrade: PaymentAnalyticsGradeDto[];
    paymentAnalyticsDivision: PaymentAnalyticsDivisionDto[];
    paymentAnalyticsStudent: PaymentAnalyticsStudentDto[];
}

export class PaymentAnalyticsSchoolDto implements IPaymentAnalyticsSchoolDto {
    studentId!: number;
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    schoolName!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;

    constructor(data?: IPaymentAnalyticsSchoolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.schoolName = _data["schoolName"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
        }
    }

    static fromJS(data: any): PaymentAnalyticsSchoolDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsSchoolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["schoolName"] = this.schoolName;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        return data;
    }

    clone(): PaymentAnalyticsSchoolDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsSchoolDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsSchoolDto {
    studentId: number;
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    schoolName: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
}

export class PaymentAnalyticsGradeDto implements IPaymentAnalyticsGradeDto {
    studentId!: number;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    gradeName!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;

    constructor(data?: IPaymentAnalyticsGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeName = _data["gradeName"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
        }
    }

    static fromJS(data: any): PaymentAnalyticsGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["gradeName"] = this.gradeName;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        return data;
    }

    clone(): PaymentAnalyticsGradeDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsGradeDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsGradeDto {
    studentId: number;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    gradeName: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
}

export class PaymentAnalyticsDivisionDto implements IPaymentAnalyticsDivisionDto {
    studentId!: number;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    divisionName!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;

    constructor(data?: IPaymentAnalyticsDivisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.divisionName = _data["divisionName"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
        }
    }

    static fromJS(data: any): PaymentAnalyticsDivisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsDivisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["divisionName"] = this.divisionName;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        return data;
    }

    clone(): PaymentAnalyticsDivisionDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsDivisionDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsDivisionDto {
    studentId: number;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    divisionName: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
}

export class PaymentAnalyticsStudentDto implements IPaymentAnalyticsStudentDto {
    studentId!: number;
    studentName!: string;
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;

    constructor(data?: IPaymentAnalyticsStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
        }
    }

    static fromJS(data: any): PaymentAnalyticsStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        return data;
    }

    clone(): PaymentAnalyticsStudentDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsStudentDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsStudentDto {
    studentId: number;
    studentName: string;
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
}

export class ParentDto implements IParentDto {
    parentId!: number | undefined;
    parentTypeId!: number | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    gender!: string | undefined;
    contactNumber!: string | undefined;
    mobileNumber!: string | undefined;
    emailId!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    talukaId!: number | undefined;
    districtId!: number | undefined;
    stateId!: number | undefined;
    countryId!: number | undefined;
    talukaName!: string | undefined;
    districtName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    zipcode!: string | undefined;
    adharNumber!: string | undefined;
    education!: string | undefined;
    occupation!: string | undefined;
    annualIncome!: number | undefined;
    bloodGroup!: string | undefined;
    profileImageURL!: string | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthDate!: moment.Moment | undefined;
    userId!: string | undefined;
    studentId!: number | undefined;
    profileBase64Image!: string | undefined;
    profileImageContentType!: string | undefined;
    studentFullName!: string | undefined;
    parentFullName!: string | undefined;
    parentType!: string | undefined;
    address!: string | undefined;

    constructor(data?: IParentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.parentTypeId = _data["parentTypeId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.gender = _data["gender"];
            this.contactNumber = _data["contactNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.emailId = _data["emailId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.talukaId = _data["talukaId"];
            this.districtId = _data["districtId"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.talukaName = _data["talukaName"];
            this.districtName = _data["districtName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.zipcode = _data["zipcode"];
            this.adharNumber = _data["adharNumber"];
            this.education = _data["education"];
            this.occupation = _data["occupation"];
            this.annualIncome = _data["annualIncome"];
            this.bloodGroup = _data["bloodGroup"];
            this.profileImageURL = _data["profileImageURL"];
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.studentId = _data["studentId"];
            this.profileBase64Image = _data["profileBase64Image"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.studentFullName = _data["studentFullName"];
            this.parentFullName = _data["parentFullName"];
            this.parentType = _data["parentType"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): ParentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parentTypeId"] = this.parentTypeId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["gender"] = this.gender;
        data["contactNumber"] = this.contactNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["emailId"] = this.emailId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["talukaId"] = this.talukaId;
        data["districtId"] = this.districtId;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["talukaName"] = this.talukaName;
        data["districtName"] = this.districtName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["zipcode"] = this.zipcode;
        data["adharNumber"] = this.adharNumber;
        data["education"] = this.education;
        data["occupation"] = this.occupation;
        data["annualIncome"] = this.annualIncome;
        data["bloodGroup"] = this.bloodGroup;
        data["profileImageURL"] = this.profileImageURL;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["studentId"] = this.studentId;
        data["profileBase64Image"] = this.profileBase64Image;
        data["profileImageContentType"] = this.profileImageContentType;
        data["studentFullName"] = this.studentFullName;
        data["parentFullName"] = this.parentFullName;
        data["parentType"] = this.parentType;
        data["address"] = this.address;
        return data;
    }

    clone(): ParentDto {
        const json = this.toJSON();
        let result = new ParentDto();
        result.init(json);
        return result;
    }
}

export interface IParentDto {
    parentId: number | undefined;
    parentTypeId: number | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    gender: string | undefined;
    contactNumber: string | undefined;
    mobileNumber: string | undefined;
    emailId: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    talukaId: number | undefined;
    districtId: number | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    talukaName: string | undefined;
    districtName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    zipcode: string | undefined;
    adharNumber: string | undefined;
    education: string | undefined;
    occupation: string | undefined;
    annualIncome: number | undefined;
    bloodGroup: string | undefined;
    profileImageURL: string | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthDate: moment.Moment | undefined;
    userId: string | undefined;
    studentId: number | undefined;
    profileBase64Image: string | undefined;
    profileImageContentType: string | undefined;
    studentFullName: string | undefined;
    parentFullName: string | undefined;
    parentType: string | undefined;
    address: string | undefined;
}

export class ParentDeleteRespose implements IParentDeleteRespose {
    affectedRows!: number;

    constructor(data?: IParentDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): ParentDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new ParentDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): ParentDeleteRespose {
        const json = this.toJSON();
        let result = new ParentDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IParentDeleteRespose {
    affectedRows: number;
}

export class ParentAppNoticeResponseDto implements IParentAppNoticeResponseDto {
    noticeList!: ParentAppNoticeDto[];

    constructor(data?: IParentAppNoticeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["noticeList"])) {
                this.noticeList = [] as any;
                for (let item of _data["noticeList"])
                    this.noticeList!.push(ParentAppNoticeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParentAppNoticeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppNoticeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.noticeList)) {
            data["noticeList"] = [];
            for (let item of this.noticeList)
                data["noticeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ParentAppNoticeResponseDto {
        const json = this.toJSON();
        let result = new ParentAppNoticeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppNoticeResponseDto {
    noticeList: ParentAppNoticeDto[];
}

export class ParentAppNoticeDto implements IParentAppNoticeDto {
    noticeId!: number;
    studentId!: number;
    gradeId!: number;
    divisionId!: number;
    isImportant!: boolean;
    noticeToType!: number;
    noticeTitle!: string;
    noticeDescription!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    isPublished!: boolean;
    userId!: number;
    roleId!: number;
    roleKey!: string;
    name!: string;
    roleName!: string;
    createdDate!: moment.Moment;
    lstNoticeDetail!: ParentAppNoticeDetailDto[];
    lstNoticeMediaDetail!: NoticetMediaContentDto[];

    constructor(data?: IParentAppNoticeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeId = _data["noticeId"];
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.isImportant = _data["isImportant"];
            this.noticeToType = _data["noticeToType"];
            this.noticeTitle = _data["noticeTitle"];
            this.noticeDescription = _data["noticeDescription"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.roleKey = _data["roleKey"];
            this.name = _data["name"];
            this.roleName = _data["roleName"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["lstNoticeDetail"])) {
                this.lstNoticeDetail = [] as any;
                for (let item of _data["lstNoticeDetail"])
                    this.lstNoticeDetail!.push(ParentAppNoticeDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["lstNoticeMediaDetail"])) {
                this.lstNoticeMediaDetail = [] as any;
                for (let item of _data["lstNoticeMediaDetail"])
                    this.lstNoticeMediaDetail!.push(NoticetMediaContentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParentAppNoticeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppNoticeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeId"] = this.noticeId;
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["isImportant"] = this.isImportant;
        data["noticeToType"] = this.noticeToType;
        data["noticeTitle"] = this.noticeTitle;
        data["noticeDescription"] = this.noticeDescription;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["roleKey"] = this.roleKey;
        data["name"] = this.name;
        data["roleName"] = this.roleName;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        if (Array.isArray(this.lstNoticeDetail)) {
            data["lstNoticeDetail"] = [];
            for (let item of this.lstNoticeDetail)
                data["lstNoticeDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.lstNoticeMediaDetail)) {
            data["lstNoticeMediaDetail"] = [];
            for (let item of this.lstNoticeMediaDetail)
                data["lstNoticeMediaDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ParentAppNoticeDto {
        const json = this.toJSON();
        let result = new ParentAppNoticeDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppNoticeDto {
    noticeId: number;
    studentId: number;
    gradeId: number;
    divisionId: number;
    isImportant: boolean;
    noticeToType: number;
    noticeTitle: string;
    noticeDescription: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    isPublished: boolean;
    userId: number;
    roleId: number;
    roleKey: string;
    name: string;
    roleName: string;
    createdDate: moment.Moment;
    lstNoticeDetail: ParentAppNoticeDetailDto[];
    lstNoticeMediaDetail: NoticetMediaContentDto[];
}

export class ParentAppNoticeDetailDto implements IParentAppNoticeDetailDto {
    noticeId!: number;
    fileName!: string;
    fileType!: number;
    fullPath!: string;
    contentUrl!: string;

    constructor(data?: IParentAppNoticeDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeId = _data["noticeId"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
            this.contentUrl = _data["contentUrl"];
        }
    }

    static fromJS(data: any): ParentAppNoticeDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppNoticeDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeId"] = this.noticeId;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        data["contentUrl"] = this.contentUrl;
        return data;
    }

    clone(): ParentAppNoticeDetailDto {
        const json = this.toJSON();
        let result = new ParentAppNoticeDetailDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppNoticeDetailDto {
    noticeId: number;
    fileName: string;
    fileType: number;
    fullPath: string;
    contentUrl: string;
}

export class NoticetMediaContentDto implements INoticetMediaContentDto {
    noticeId!: number;
    contentUrl!: string;
    fileName!: string;
    fullPath!: string;

    constructor(data?: INoticetMediaContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeId = _data["noticeId"];
            this.contentUrl = _data["contentUrl"];
            this.fileName = _data["fileName"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): NoticetMediaContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoticetMediaContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeId"] = this.noticeId;
        data["contentUrl"] = this.contentUrl;
        data["fileName"] = this.fileName;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): NoticetMediaContentDto {
        const json = this.toJSON();
        let result = new NoticetMediaContentDto();
        result.init(json);
        return result;
    }
}

export interface INoticetMediaContentDto {
    noticeId: number;
    contentUrl: string;
    fileName: string;
    fullPath: string;
}

export class ParentAppNoticeRequestDto implements IParentAppNoticeRequestDto {
    academicYearId!: number;
    studentId!: number;
    month!: number;
    year!: number;

    constructor(data?: IParentAppNoticeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.studentId = _data["studentId"];
            this.month = _data["month"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): ParentAppNoticeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppNoticeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["studentId"] = this.studentId;
        data["month"] = this.month;
        data["year"] = this.year;
        return data;
    }

    clone(): ParentAppNoticeRequestDto {
        const json = this.toJSON();
        let result = new ParentAppNoticeRequestDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppNoticeRequestDto {
    academicYearId: number;
    studentId: number;
    month: number;
    year: number;
}

export class StudentDetailMobileResponseDto implements IStudentDetailMobileResponseDto {
    lstStudents!: StudentDetailMobileDto[];

    constructor(data?: IStudentDetailMobileResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstStudents"])) {
                this.lstStudents = [] as any;
                for (let item of _data["lstStudents"])
                    this.lstStudents!.push(StudentDetailMobileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentDetailMobileResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDetailMobileResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstStudents)) {
            data["lstStudents"] = [];
            for (let item of this.lstStudents)
                data["lstStudents"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentDetailMobileResponseDto {
        const json = this.toJSON();
        let result = new StudentDetailMobileResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStudentDetailMobileResponseDto {
    lstStudents: StudentDetailMobileDto[];
}

export class StudentDetailMobileDto implements IStudentDetailMobileDto {
    studentId!: number;
    parentId!: number;
    studentFullName!: string;
    classId!: number;
    className!: string;
    rollNumber!: string;
    profileImageURL!: string;

    constructor(data?: IStudentDetailMobileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.parentId = _data["parentId"];
            this.studentFullName = _data["studentFullName"];
            this.classId = _data["classId"];
            this.className = _data["className"];
            this.rollNumber = _data["rollNumber"];
            this.profileImageURL = _data["profileImageURL"];
        }
    }

    static fromJS(data: any): StudentDetailMobileDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDetailMobileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["parentId"] = this.parentId;
        data["studentFullName"] = this.studentFullName;
        data["classId"] = this.classId;
        data["className"] = this.className;
        data["rollNumber"] = this.rollNumber;
        data["profileImageURL"] = this.profileImageURL;
        return data;
    }

    clone(): StudentDetailMobileDto {
        const json = this.toJSON();
        let result = new StudentDetailMobileDto();
        result.init(json);
        return result;
    }
}

export interface IStudentDetailMobileDto {
    studentId: number;
    parentId: number;
    studentFullName: string;
    classId: number;
    className: string;
    rollNumber: string;
    profileImageURL: string;
}

export class StudentProfileMobileDto implements IStudentProfileMobileDto {
    studentId!: number;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    studentFullName!: string;
    currentAddressLine1!: string;
    currentAddressLine2!: string;
    currentCountryId!: number | undefined;
    currentStateId!: number | undefined;
    currentDistrictId!: number | undefined;
    currentTalukaId!: number | undefined;
    currentZipcode!: string;
    profileImageURL!: string;
    profileImageContentType!: string;
    profileBase64Image!: string;
    userId!: number | undefined;

    constructor(data?: IStudentProfileMobileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.studentFullName = _data["studentFullName"];
            this.currentAddressLine1 = _data["currentAddressLine1"];
            this.currentAddressLine2 = _data["currentAddressLine2"];
            this.currentCountryId = _data["currentCountryId"];
            this.currentStateId = _data["currentStateId"];
            this.currentDistrictId = _data["currentDistrictId"];
            this.currentTalukaId = _data["currentTalukaId"];
            this.currentZipcode = _data["currentZipcode"];
            this.profileImageURL = _data["profileImageURL"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.profileBase64Image = _data["profileBase64Image"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): StudentProfileMobileDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentProfileMobileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["studentFullName"] = this.studentFullName;
        data["currentAddressLine1"] = this.currentAddressLine1;
        data["currentAddressLine2"] = this.currentAddressLine2;
        data["currentCountryId"] = this.currentCountryId;
        data["currentStateId"] = this.currentStateId;
        data["currentDistrictId"] = this.currentDistrictId;
        data["currentTalukaId"] = this.currentTalukaId;
        data["currentZipcode"] = this.currentZipcode;
        data["profileImageURL"] = this.profileImageURL;
        data["profileImageContentType"] = this.profileImageContentType;
        data["profileBase64Image"] = this.profileBase64Image;
        data["userId"] = this.userId;
        return data;
    }

    clone(): StudentProfileMobileDto {
        const json = this.toJSON();
        let result = new StudentProfileMobileDto();
        result.init(json);
        return result;
    }
}

export interface IStudentProfileMobileDto {
    studentId: number;
    firstName: string;
    middleName: string;
    lastName: string;
    studentFullName: string;
    currentAddressLine1: string;
    currentAddressLine2: string;
    currentCountryId: number | undefined;
    currentStateId: number | undefined;
    currentDistrictId: number | undefined;
    currentTalukaId: number | undefined;
    currentZipcode: string;
    profileImageURL: string;
    profileImageContentType: string;
    profileBase64Image: string;
    userId: number | undefined;
}

export class ParentProfileMobileResponseDto implements IParentProfileMobileResponseDto {
    fatherDetail!: ParentProfileMobileDto;
    motherDetail!: ParentProfileMobileDto;
    guardianDetail!: ParentProfileMobileDto;

    constructor(data?: IParentProfileMobileResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fatherDetail = _data["fatherDetail"] ? ParentProfileMobileDto.fromJS(_data["fatherDetail"]) : <any>undefined;
            this.motherDetail = _data["motherDetail"] ? ParentProfileMobileDto.fromJS(_data["motherDetail"]) : <any>undefined;
            this.guardianDetail = _data["guardianDetail"] ? ParentProfileMobileDto.fromJS(_data["guardianDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParentProfileMobileResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentProfileMobileResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fatherDetail"] = this.fatherDetail ? this.fatherDetail.toJSON() : <any>undefined;
        data["motherDetail"] = this.motherDetail ? this.motherDetail.toJSON() : <any>undefined;
        data["guardianDetail"] = this.guardianDetail ? this.guardianDetail.toJSON() : <any>undefined;
        return data;
    }

    clone(): ParentProfileMobileResponseDto {
        const json = this.toJSON();
        let result = new ParentProfileMobileResponseDto();
        result.init(json);
        return result;
    }
}

export interface IParentProfileMobileResponseDto {
    fatherDetail: ParentProfileMobileDto;
    motherDetail: ParentProfileMobileDto;
    guardianDetail: ParentProfileMobileDto;
}

export class ParentProfileMobileDto implements IParentProfileMobileDto {
    studentId!: number;
    parentId!: number;
    parentTypeId!: number;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    fullName!: string;
    addressLine1!: string;
    addressLine2!: string;
    countryId!: number | undefined;
    stateId!: number | undefined;
    districtId!: number | undefined;
    talukaId!: number | undefined;
    zipcode!: string;
    profileImageURL!: string;
    profileImageContentType!: string;
    profileBase64Image!: string;
    userId!: number | undefined;

    constructor(data?: IParentProfileMobileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.parentId = _data["parentId"];
            this.parentTypeId = _data["parentTypeId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.districtId = _data["districtId"];
            this.talukaId = _data["talukaId"];
            this.zipcode = _data["zipcode"];
            this.profileImageURL = _data["profileImageURL"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.profileBase64Image = _data["profileBase64Image"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ParentProfileMobileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentProfileMobileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["parentId"] = this.parentId;
        data["parentTypeId"] = this.parentTypeId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["districtId"] = this.districtId;
        data["talukaId"] = this.talukaId;
        data["zipcode"] = this.zipcode;
        data["profileImageURL"] = this.profileImageURL;
        data["profileImageContentType"] = this.profileImageContentType;
        data["profileBase64Image"] = this.profileBase64Image;
        data["userId"] = this.userId;
        return data;
    }

    clone(): ParentProfileMobileDto {
        const json = this.toJSON();
        let result = new ParentProfileMobileDto();
        result.init(json);
        return result;
    }
}

export interface IParentProfileMobileDto {
    studentId: number;
    parentId: number;
    parentTypeId: number;
    firstName: string;
    middleName: string;
    lastName: string;
    fullName: string;
    addressLine1: string;
    addressLine2: string;
    countryId: number | undefined;
    stateId: number | undefined;
    districtId: number | undefined;
    talukaId: number | undefined;
    zipcode: string;
    profileImageURL: string;
    profileImageContentType: string;
    profileBase64Image: string;
    userId: number | undefined;
}

export class FeePaymentTopSectionDto implements IFeePaymentTopSectionDto {
    totalFee!: number | undefined;
    totalPaid!: number | undefined;
    totalDue!: number | undefined;
    totalDiscount!: number | undefined;
    feeWavierTypeId!: number | undefined;
    feePaymentParticularSectionDtoList!: FeePaymentParticularSectionDto[];
    feePaymentAndDiscountSectionDtoList!: FeePaymentAndDiscountSectionDto[];
    paymentHistoryReceiptDtoList!: PaymentHistoryReceiptDto[];
    feeInstallmentDetailDtoList!: FeeInstallmentDetailDto[];

    constructor(data?: IFeePaymentTopSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalFee = _data["totalFee"];
            this.totalPaid = _data["totalPaid"];
            this.totalDue = _data["totalDue"];
            this.totalDiscount = _data["totalDiscount"];
            this.feeWavierTypeId = _data["feeWavierTypeId"];
            if (Array.isArray(_data["feePaymentParticularSectionDtoList"])) {
                this.feePaymentParticularSectionDtoList = [] as any;
                for (let item of _data["feePaymentParticularSectionDtoList"])
                    this.feePaymentParticularSectionDtoList!.push(FeePaymentParticularSectionDto.fromJS(item));
            }
            if (Array.isArray(_data["feePaymentAndDiscountSectionDtoList"])) {
                this.feePaymentAndDiscountSectionDtoList = [] as any;
                for (let item of _data["feePaymentAndDiscountSectionDtoList"])
                    this.feePaymentAndDiscountSectionDtoList!.push(FeePaymentAndDiscountSectionDto.fromJS(item));
            }
            if (Array.isArray(_data["paymentHistoryReceiptDtoList"])) {
                this.paymentHistoryReceiptDtoList = [] as any;
                for (let item of _data["paymentHistoryReceiptDtoList"])
                    this.paymentHistoryReceiptDtoList!.push(PaymentHistoryReceiptDto.fromJS(item));
            }
            if (Array.isArray(_data["feeInstallmentDetailDtoList"])) {
                this.feeInstallmentDetailDtoList = [] as any;
                for (let item of _data["feeInstallmentDetailDtoList"])
                    this.feeInstallmentDetailDtoList!.push(FeeInstallmentDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeePaymentTopSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentTopSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalFee"] = this.totalFee;
        data["totalPaid"] = this.totalPaid;
        data["totalDue"] = this.totalDue;
        data["totalDiscount"] = this.totalDiscount;
        data["feeWavierTypeId"] = this.feeWavierTypeId;
        if (Array.isArray(this.feePaymentParticularSectionDtoList)) {
            data["feePaymentParticularSectionDtoList"] = [];
            for (let item of this.feePaymentParticularSectionDtoList)
                data["feePaymentParticularSectionDtoList"].push(item.toJSON());
        }
        if (Array.isArray(this.feePaymentAndDiscountSectionDtoList)) {
            data["feePaymentAndDiscountSectionDtoList"] = [];
            for (let item of this.feePaymentAndDiscountSectionDtoList)
                data["feePaymentAndDiscountSectionDtoList"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentHistoryReceiptDtoList)) {
            data["paymentHistoryReceiptDtoList"] = [];
            for (let item of this.paymentHistoryReceiptDtoList)
                data["paymentHistoryReceiptDtoList"].push(item.toJSON());
        }
        if (Array.isArray(this.feeInstallmentDetailDtoList)) {
            data["feeInstallmentDetailDtoList"] = [];
            for (let item of this.feeInstallmentDetailDtoList)
                data["feeInstallmentDetailDtoList"].push(item.toJSON());
        }
        return data;
    }

    clone(): FeePaymentTopSectionDto {
        const json = this.toJSON();
        let result = new FeePaymentTopSectionDto();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentTopSectionDto {
    totalFee: number | undefined;
    totalPaid: number | undefined;
    totalDue: number | undefined;
    totalDiscount: number | undefined;
    feeWavierTypeId: number | undefined;
    feePaymentParticularSectionDtoList: FeePaymentParticularSectionDto[];
    feePaymentAndDiscountSectionDtoList: FeePaymentAndDiscountSectionDto[];
    paymentHistoryReceiptDtoList: PaymentHistoryReceiptDto[];
    feeInstallmentDetailDtoList: FeeInstallmentDetailDto[];
}

export class FeePaymentParticularSectionDto implements IFeePaymentParticularSectionDto {
    particularName!: string | undefined;
    totalFee!: number | undefined;

    constructor(data?: IFeePaymentParticularSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.particularName = _data["particularName"];
            this.totalFee = _data["totalFee"];
        }
    }

    static fromJS(data: any): FeePaymentParticularSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentParticularSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["particularName"] = this.particularName;
        data["totalFee"] = this.totalFee;
        return data;
    }

    clone(): FeePaymentParticularSectionDto {
        const json = this.toJSON();
        let result = new FeePaymentParticularSectionDto();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentParticularSectionDto {
    particularName: string | undefined;
    totalFee: number | undefined;
}

export class FeePaymentAndDiscountSectionDto implements IFeePaymentAndDiscountSectionDto {
    feeWavierDisplayName!: string | undefined;
    feeWavierTypeId!: number | undefined;
    totalFee!: number | undefined;
    discountInPercent!: number | undefined;
    applicableFee!: number | undefined;
    numberOfInstallments!: number | undefined;
    discountEndDate!: moment.Moment | undefined;

    constructor(data?: IFeePaymentAndDiscountSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeWavierDisplayName = _data["feeWavierDisplayName"];
            this.feeWavierTypeId = _data["feeWavierTypeId"];
            this.totalFee = _data["totalFee"];
            this.discountInPercent = _data["discountInPercent"];
            this.applicableFee = _data["applicableFee"];
            this.numberOfInstallments = _data["numberOfInstallments"];
            this.discountEndDate = _data["discountEndDate"] ? moment(_data["discountEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FeePaymentAndDiscountSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentAndDiscountSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeWavierDisplayName"] = this.feeWavierDisplayName;
        data["feeWavierTypeId"] = this.feeWavierTypeId;
        data["totalFee"] = this.totalFee;
        data["discountInPercent"] = this.discountInPercent;
        data["applicableFee"] = this.applicableFee;
        data["numberOfInstallments"] = this.numberOfInstallments;
        data["discountEndDate"] = this.discountEndDate ? this.discountEndDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): FeePaymentAndDiscountSectionDto {
        const json = this.toJSON();
        let result = new FeePaymentAndDiscountSectionDto();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentAndDiscountSectionDto {
    feeWavierDisplayName: string | undefined;
    feeWavierTypeId: number | undefined;
    totalFee: number | undefined;
    discountInPercent: number | undefined;
    applicableFee: number | undefined;
    numberOfInstallments: number | undefined;
    discountEndDate: moment.Moment | undefined;
}

export class PaymentHistoryReceiptDto implements IPaymentHistoryReceiptDto {
    installmentNumber!: number | undefined;
    invoiceNumber!: string | undefined;
    onlineTransactionDateTime!: moment.Moment | undefined;
    paidAmount!: number | undefined;
    paymentTypeName!: string | undefined;
    chequeDate!: moment.Moment | undefined;
    onlineTransactionId!: string | undefined;
    isChequeOrDDClear!: string | undefined;

    constructor(data?: IPaymentHistoryReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.installmentNumber = _data["installmentNumber"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"] ? moment(_data["onlineTransactionDateTime"].toString()) : <any>undefined;
            this.paidAmount = _data["paidAmount"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.isChequeOrDDClear = _data["isChequeOrDDClear"];
        }
    }

    static fromJS(data: any): PaymentHistoryReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentHistoryReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installmentNumber"] = this.installmentNumber;
        data["invoiceNumber"] = this.invoiceNumber;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime ? this.onlineTransactionDateTime.toISOString() : <any>undefined;
        data["paidAmount"] = this.paidAmount;
        data["paymentTypeName"] = this.paymentTypeName;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["isChequeOrDDClear"] = this.isChequeOrDDClear;
        return data;
    }

    clone(): PaymentHistoryReceiptDto {
        const json = this.toJSON();
        let result = new PaymentHistoryReceiptDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentHistoryReceiptDto {
    installmentNumber: number | undefined;
    invoiceNumber: string | undefined;
    onlineTransactionDateTime: moment.Moment | undefined;
    paidAmount: number | undefined;
    paymentTypeName: string | undefined;
    chequeDate: moment.Moment | undefined;
    onlineTransactionId: string | undefined;
    isChequeOrDDClear: string | undefined;
}

export class FeeInstallmentDetailDto implements IFeeInstallmentDetailDto {
    discountEndDate!: moment.Moment | undefined;
    lateFeeStartDate!: moment.Moment | undefined;
    feeWavierTypeId!: number | undefined;
    installmentNumber!: number | undefined;

    constructor(data?: IFeeInstallmentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discountEndDate = _data["discountEndDate"] ? moment(_data["discountEndDate"].toString()) : <any>undefined;
            this.lateFeeStartDate = _data["lateFeeStartDate"] ? moment(_data["lateFeeStartDate"].toString()) : <any>undefined;
            this.feeWavierTypeId = _data["feeWavierTypeId"];
            this.installmentNumber = _data["installmentNumber"];
        }
    }

    static fromJS(data: any): FeeInstallmentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeInstallmentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discountEndDate"] = this.discountEndDate ? this.discountEndDate.toISOString() : <any>undefined;
        data["lateFeeStartDate"] = this.lateFeeStartDate ? this.lateFeeStartDate.toISOString() : <any>undefined;
        data["feeWavierTypeId"] = this.feeWavierTypeId;
        data["installmentNumber"] = this.installmentNumber;
        return data;
    }

    clone(): FeeInstallmentDetailDto {
        const json = this.toJSON();
        let result = new FeeInstallmentDetailDto();
        result.init(json);
        return result;
    }
}

export interface IFeeInstallmentDetailDto {
    discountEndDate: moment.Moment | undefined;
    lateFeeStartDate: moment.Moment | undefined;
    feeWavierTypeId: number | undefined;
    installmentNumber: number | undefined;
}

export class TransportFeePaymentTopSectionDto implements ITransportFeePaymentTopSectionDto {
    totalFee!: number | undefined;
    totalPaid!: number | undefined;
    totalDue!: number | undefined;
    totalDiscount!: number | undefined;
    transportFeePaymentParticularSectionDtoList!: TransportFeePaymentParticularSectionDto[];
    transportPaymentHistoryReceiptDtoList!: TransportPaymentHistoryReceiptDto[];

    constructor(data?: ITransportFeePaymentTopSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalFee = _data["totalFee"];
            this.totalPaid = _data["totalPaid"];
            this.totalDue = _data["totalDue"];
            this.totalDiscount = _data["totalDiscount"];
            if (Array.isArray(_data["transportFeePaymentParticularSectionDtoList"])) {
                this.transportFeePaymentParticularSectionDtoList = [] as any;
                for (let item of _data["transportFeePaymentParticularSectionDtoList"])
                    this.transportFeePaymentParticularSectionDtoList!.push(TransportFeePaymentParticularSectionDto.fromJS(item));
            }
            if (Array.isArray(_data["transportPaymentHistoryReceiptDtoList"])) {
                this.transportPaymentHistoryReceiptDtoList = [] as any;
                for (let item of _data["transportPaymentHistoryReceiptDtoList"])
                    this.transportPaymentHistoryReceiptDtoList!.push(TransportPaymentHistoryReceiptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportFeePaymentTopSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentTopSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalFee"] = this.totalFee;
        data["totalPaid"] = this.totalPaid;
        data["totalDue"] = this.totalDue;
        data["totalDiscount"] = this.totalDiscount;
        if (Array.isArray(this.transportFeePaymentParticularSectionDtoList)) {
            data["transportFeePaymentParticularSectionDtoList"] = [];
            for (let item of this.transportFeePaymentParticularSectionDtoList)
                data["transportFeePaymentParticularSectionDtoList"].push(item.toJSON());
        }
        if (Array.isArray(this.transportPaymentHistoryReceiptDtoList)) {
            data["transportPaymentHistoryReceiptDtoList"] = [];
            for (let item of this.transportPaymentHistoryReceiptDtoList)
                data["transportPaymentHistoryReceiptDtoList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportFeePaymentTopSectionDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentTopSectionDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentTopSectionDto {
    totalFee: number | undefined;
    totalPaid: number | undefined;
    totalDue: number | undefined;
    totalDiscount: number | undefined;
    transportFeePaymentParticularSectionDtoList: TransportFeePaymentParticularSectionDto[];
    transportPaymentHistoryReceiptDtoList: TransportPaymentHistoryReceiptDto[];
}

export class TransportFeePaymentParticularSectionDto implements ITransportFeePaymentParticularSectionDto {
    consumerId!: number;
    roleId!: number;
    transportConsumerStoppageMappingId!: number;
    routeName!: string;
    pickDropId!: number;
    pickDropPrice!: number;
    months!: number;
    fromDateString!: string | undefined;
    toDateString!: string | undefined;
    stoppageName!: string;
    academicYearId!: number;
    academicYearKey!: string | undefined;
    fullName!: string;
    totalFee!: number;
    discountedFee!: number;
    paidAmount!: number;
    otherPaidAmount!: number;
    dueAmount!: number;
    chequeClearedAmount!: number;
    chequeUnclearAmount!: number;

    constructor(data?: ITransportFeePaymentParticularSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerId = _data["consumerId"];
            this.roleId = _data["roleId"];
            this.transportConsumerStoppageMappingId = _data["transportConsumerStoppageMappingId"];
            this.routeName = _data["routeName"];
            this.pickDropId = _data["pickDropId"];
            this.pickDropPrice = _data["pickDropPrice"];
            this.months = _data["months"];
            this.fromDateString = _data["fromDateString"];
            this.toDateString = _data["toDateString"];
            this.stoppageName = _data["stoppageName"];
            this.academicYearId = _data["academicYearId"];
            this.academicYearKey = _data["academicYearKey"];
            this.fullName = _data["fullName"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.paidAmount = _data["paidAmount"];
            this.otherPaidAmount = _data["otherPaidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.chequeClearedAmount = _data["chequeClearedAmount"];
            this.chequeUnclearAmount = _data["chequeUnclearAmount"];
        }
    }

    static fromJS(data: any): TransportFeePaymentParticularSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportFeePaymentParticularSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerId"] = this.consumerId;
        data["roleId"] = this.roleId;
        data["transportConsumerStoppageMappingId"] = this.transportConsumerStoppageMappingId;
        data["routeName"] = this.routeName;
        data["pickDropId"] = this.pickDropId;
        data["pickDropPrice"] = this.pickDropPrice;
        data["months"] = this.months;
        data["fromDateString"] = this.fromDateString;
        data["toDateString"] = this.toDateString;
        data["stoppageName"] = this.stoppageName;
        data["academicYearId"] = this.academicYearId;
        data["academicYearKey"] = this.academicYearKey;
        data["fullName"] = this.fullName;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["paidAmount"] = this.paidAmount;
        data["otherPaidAmount"] = this.otherPaidAmount;
        data["dueAmount"] = this.dueAmount;
        data["chequeClearedAmount"] = this.chequeClearedAmount;
        data["chequeUnclearAmount"] = this.chequeUnclearAmount;
        return data;
    }

    clone(): TransportFeePaymentParticularSectionDto {
        const json = this.toJSON();
        let result = new TransportFeePaymentParticularSectionDto();
        result.init(json);
        return result;
    }
}

export interface ITransportFeePaymentParticularSectionDto {
    consumerId: number;
    roleId: number;
    transportConsumerStoppageMappingId: number;
    routeName: string;
    pickDropId: number;
    pickDropPrice: number;
    months: number;
    fromDateString: string | undefined;
    toDateString: string | undefined;
    stoppageName: string;
    academicYearId: number;
    academicYearKey: string | undefined;
    fullName: string;
    totalFee: number;
    discountedFee: number;
    paidAmount: number;
    otherPaidAmount: number;
    dueAmount: number;
    chequeClearedAmount: number;
    chequeUnclearAmount: number;
}

export class TransportPaymentHistoryReceiptDto implements ITransportPaymentHistoryReceiptDto {
    installmentNumber!: number | undefined;
    invoiceNumber!: string | undefined;
    onlineTransactionDateTime!: moment.Moment | undefined;
    paidAmount!: number | undefined;
    paymentTypeName!: string | undefined;
    chequeDate!: moment.Moment | undefined;
    onlineTransactionId!: string | undefined;
    isChequeOrDDClear!: string | undefined;

    constructor(data?: ITransportPaymentHistoryReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.installmentNumber = _data["installmentNumber"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"] ? moment(_data["onlineTransactionDateTime"].toString()) : <any>undefined;
            this.paidAmount = _data["paidAmount"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.isChequeOrDDClear = _data["isChequeOrDDClear"];
        }
    }

    static fromJS(data: any): TransportPaymentHistoryReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentHistoryReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installmentNumber"] = this.installmentNumber;
        data["invoiceNumber"] = this.invoiceNumber;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime ? this.onlineTransactionDateTime.toISOString() : <any>undefined;
        data["paidAmount"] = this.paidAmount;
        data["paymentTypeName"] = this.paymentTypeName;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["isChequeOrDDClear"] = this.isChequeOrDDClear;
        return data;
    }

    clone(): TransportPaymentHistoryReceiptDto {
        const json = this.toJSON();
        let result = new TransportPaymentHistoryReceiptDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentHistoryReceiptDto {
    installmentNumber: number | undefined;
    invoiceNumber: string | undefined;
    onlineTransactionDateTime: moment.Moment | undefined;
    paidAmount: number | undefined;
    paymentTypeName: string | undefined;
    chequeDate: moment.Moment | undefined;
    onlineTransactionId: string | undefined;
    isChequeOrDDClear: string | undefined;
}

export class OneMonthEventParentAppResponseDto implements IOneMonthEventParentAppResponseDto {
    oneMonthEventList!: OneMonthEventParentAppDto[];

    constructor(data?: IOneMonthEventParentAppResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["oneMonthEventList"])) {
                this.oneMonthEventList = [] as any;
                for (let item of _data["oneMonthEventList"])
                    this.oneMonthEventList!.push(OneMonthEventParentAppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OneMonthEventParentAppResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new OneMonthEventParentAppResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.oneMonthEventList)) {
            data["oneMonthEventList"] = [];
            for (let item of this.oneMonthEventList)
                data["oneMonthEventList"].push(item.toJSON());
        }
        return data;
    }

    clone(): OneMonthEventParentAppResponseDto {
        const json = this.toJSON();
        let result = new OneMonthEventParentAppResponseDto();
        result.init(json);
        return result;
    }
}

export interface IOneMonthEventParentAppResponseDto {
    oneMonthEventList: OneMonthEventParentAppDto[];
}

export class OneMonthEventParentAppDto implements IOneMonthEventParentAppDto {
    schoolEventId!: number;
    academicYearId!: number | undefined;
    classId!: number | undefined;
    gradeId!: number | undefined;
    gradeName!: string;
    divisionId!: number | undefined;
    divisionName!: string | undefined;
    eventTitle!: string;
    eventDescription!: string;
    eventFess!: string;
    eventVenue!: string;
    eventCoordinator!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    startTime!: moment.Moment | undefined;
    ngbStartTime!: SchoolNgbTimeModel | undefined;
    endTime!: moment.Moment | undefined;
    ngbEndTime!: SchoolNgbTimeModel | undefined;
    isCompulsory!: boolean;
    isPublished!: boolean;
    lstEventDetail!: OneMonthEventFileDetailsParentAppDto[];
    lstEventDate!: OneMonthEventDateParentAppDto[];

    constructor(data?: IOneMonthEventParentAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.academicYearId = _data["academicYearId"];
            this.classId = _data["classId"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.eventTitle = _data["eventTitle"];
            this.eventDescription = _data["eventDescription"];
            this.eventFess = _data["eventFess"];
            this.eventVenue = _data["eventVenue"];
            this.eventCoordinator = _data["eventCoordinator"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.ngbStartTime = _data["ngbStartTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbStartTime"]) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.ngbEndTime = _data["ngbEndTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbEndTime"]) : <any>undefined;
            this.isCompulsory = _data["isCompulsory"];
            this.isPublished = _data["isPublished"];
            if (Array.isArray(_data["lstEventDetail"])) {
                this.lstEventDetail = [] as any;
                for (let item of _data["lstEventDetail"])
                    this.lstEventDetail!.push(OneMonthEventFileDetailsParentAppDto.fromJS(item));
            }
            if (Array.isArray(_data["lstEventDate"])) {
                this.lstEventDate = [] as any;
                for (let item of _data["lstEventDate"])
                    this.lstEventDate!.push(OneMonthEventDateParentAppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OneMonthEventParentAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new OneMonthEventParentAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["academicYearId"] = this.academicYearId;
        data["classId"] = this.classId;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["eventTitle"] = this.eventTitle;
        data["eventDescription"] = this.eventDescription;
        data["eventFess"] = this.eventFess;
        data["eventVenue"] = this.eventVenue;
        data["eventCoordinator"] = this.eventCoordinator;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["ngbStartTime"] = this.ngbStartTime ? this.ngbStartTime.toJSON() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["ngbEndTime"] = this.ngbEndTime ? this.ngbEndTime.toJSON() : <any>undefined;
        data["isCompulsory"] = this.isCompulsory;
        data["isPublished"] = this.isPublished;
        if (Array.isArray(this.lstEventDetail)) {
            data["lstEventDetail"] = [];
            for (let item of this.lstEventDetail)
                data["lstEventDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.lstEventDate)) {
            data["lstEventDate"] = [];
            for (let item of this.lstEventDate)
                data["lstEventDate"].push(item.toJSON());
        }
        return data;
    }

    clone(): OneMonthEventParentAppDto {
        const json = this.toJSON();
        let result = new OneMonthEventParentAppDto();
        result.init(json);
        return result;
    }
}

export interface IOneMonthEventParentAppDto {
    schoolEventId: number;
    academicYearId: number | undefined;
    classId: number | undefined;
    gradeId: number | undefined;
    gradeName: string;
    divisionId: number | undefined;
    divisionName: string | undefined;
    eventTitle: string;
    eventDescription: string;
    eventFess: string;
    eventVenue: string;
    eventCoordinator: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    startTime: moment.Moment | undefined;
    ngbStartTime: SchoolNgbTimeModel | undefined;
    endTime: moment.Moment | undefined;
    ngbEndTime: SchoolNgbTimeModel | undefined;
    isCompulsory: boolean;
    isPublished: boolean;
    lstEventDetail: OneMonthEventFileDetailsParentAppDto[];
    lstEventDate: OneMonthEventDateParentAppDto[];
}

export class OneMonthEventFileDetailsParentAppDto implements IOneMonthEventFileDetailsParentAppDto {
    schoolEventId!: number;
    schoolEventDetailsId!: number;
    fileName!: string;
    fullPath!: string;

    constructor(data?: IOneMonthEventFileDetailsParentAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.schoolEventDetailsId = _data["schoolEventDetailsId"];
            this.fileName = _data["fileName"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): OneMonthEventFileDetailsParentAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new OneMonthEventFileDetailsParentAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["schoolEventDetailsId"] = this.schoolEventDetailsId;
        data["fileName"] = this.fileName;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): OneMonthEventFileDetailsParentAppDto {
        const json = this.toJSON();
        let result = new OneMonthEventFileDetailsParentAppDto();
        result.init(json);
        return result;
    }
}

export interface IOneMonthEventFileDetailsParentAppDto {
    schoolEventId: number;
    schoolEventDetailsId: number;
    fileName: string;
    fullPath: string;
}

export class OneMonthEventDateParentAppDto implements IOneMonthEventDateParentAppDto {
    schoolEventId!: number;
    eventStartDate!: moment.Moment | undefined;
    eventEndDate!: moment.Moment | undefined;

    constructor(data?: IOneMonthEventDateParentAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.eventStartDate = _data["eventStartDate"] ? moment(_data["eventStartDate"].toString()) : <any>undefined;
            this.eventEndDate = _data["eventEndDate"] ? moment(_data["eventEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OneMonthEventDateParentAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new OneMonthEventDateParentAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["eventStartDate"] = this.eventStartDate ? this.eventStartDate.toISOString() : <any>undefined;
        data["eventEndDate"] = this.eventEndDate ? this.eventEndDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): OneMonthEventDateParentAppDto {
        const json = this.toJSON();
        let result = new OneMonthEventDateParentAppDto();
        result.init(json);
        return result;
    }
}

export interface IOneMonthEventDateParentAppDto {
    schoolEventId: number;
    eventStartDate: moment.Moment | undefined;
    eventEndDate: moment.Moment | undefined;
}

export class TeacherOneDayLecturesParentAppResponseDto implements ITeacherOneDayLecturesParentAppResponseDto {
    teacherOneDayLectureList!: TeacherOneDayLecturesParentAppDto[] | undefined;

    constructor(data?: ITeacherOneDayLecturesParentAppResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["teacherOneDayLectureList"])) {
                this.teacherOneDayLectureList = [] as any;
                for (let item of _data["teacherOneDayLectureList"])
                    this.teacherOneDayLectureList!.push(TeacherOneDayLecturesParentAppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherOneDayLecturesParentAppResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherOneDayLecturesParentAppResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.teacherOneDayLectureList)) {
            data["teacherOneDayLectureList"] = [];
            for (let item of this.teacherOneDayLectureList)
                data["teacherOneDayLectureList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeacherOneDayLecturesParentAppResponseDto {
        const json = this.toJSON();
        let result = new TeacherOneDayLecturesParentAppResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherOneDayLecturesParentAppResponseDto {
    teacherOneDayLectureList: TeacherOneDayLecturesParentAppDto[] | undefined;
}

export class TeacherOneDayLecturesParentAppDto implements ITeacherOneDayLecturesParentAppDto {
    academicYearId!: number | undefined;
    teacherName!: string;
    startTime!: string | undefined;
    endTime!: string | undefined;
    gradeId!: number | undefined;
    classId!: number | undefined;
    gradeName!: string;
    divisionId!: number | undefined;
    divisionName!: string;
    dayNo!: number | undefined;
    subjectId!: number | undefined;
    subjectName!: string;

    constructor(data?: ITeacherOneDayLecturesParentAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.teacherName = _data["teacherName"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.gradeId = _data["gradeId"];
            this.classId = _data["classId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.dayNo = _data["dayNo"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): TeacherOneDayLecturesParentAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherOneDayLecturesParentAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["teacherName"] = this.teacherName;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["gradeId"] = this.gradeId;
        data["classId"] = this.classId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["dayNo"] = this.dayNo;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): TeacherOneDayLecturesParentAppDto {
        const json = this.toJSON();
        let result = new TeacherOneDayLecturesParentAppDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherOneDayLecturesParentAppDto {
    academicYearId: number | undefined;
    teacherName: string;
    startTime: string | undefined;
    endTime: string | undefined;
    gradeId: number | undefined;
    classId: number | undefined;
    gradeName: string;
    divisionId: number | undefined;
    divisionName: string;
    dayNo: number | undefined;
    subjectId: number | undefined;
    subjectName: string;
}

export class MissingAttendanceParentAppDto implements IMissingAttendanceParentAppDto {
    academicYearId!: number;
    status!: string;
    studentId!: number;

    constructor(data?: IMissingAttendanceParentAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.status = _data["status"];
            this.studentId = _data["studentId"];
        }
    }

    static fromJS(data: any): MissingAttendanceParentAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new MissingAttendanceParentAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["status"] = this.status;
        data["studentId"] = this.studentId;
        return data;
    }

    clone(): MissingAttendanceParentAppDto {
        const json = this.toJSON();
        let result = new MissingAttendanceParentAppDto();
        result.init(json);
        return result;
    }
}

export interface IMissingAttendanceParentAppDto {
    academicYearId: number;
    status: string;
    studentId: number;
}

export class StudentGradeDivisionParentAppDto implements IStudentGradeDivisionParentAppDto {
    academicYearId!: number;
    gradeId!: number;
    gradeName!: string;
    divisionId!: number;
    divisionName!: string;
    fullName!: string;
    studentId!: number;
    parentId!: number;

    constructor(data?: IStudentGradeDivisionParentAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.fullName = _data["fullName"];
            this.studentId = _data["studentId"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): StudentGradeDivisionParentAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentGradeDivisionParentAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["fullName"] = this.fullName;
        data["studentId"] = this.studentId;
        data["parentId"] = this.parentId;
        return data;
    }

    clone(): StudentGradeDivisionParentAppDto {
        const json = this.toJSON();
        let result = new StudentGradeDivisionParentAppDto();
        result.init(json);
        return result;
    }
}

export interface IStudentGradeDivisionParentAppDto {
    academicYearId: number;
    gradeId: number;
    gradeName: string;
    divisionId: number;
    divisionName: string;
    fullName: string;
    studentId: number;
    parentId: number;
}

export class SchoolParentCalendarResponseDto implements ISchoolParentCalendarResponseDto {
    parentLstEvents!: CalendarParentAppModuleDto[];

    constructor(data?: ISchoolParentCalendarResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["parentLstEvents"])) {
                this.parentLstEvents = [] as any;
                for (let item of _data["parentLstEvents"])
                    this.parentLstEvents!.push(CalendarParentAppModuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchoolParentCalendarResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolParentCalendarResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.parentLstEvents)) {
            data["parentLstEvents"] = [];
            for (let item of this.parentLstEvents)
                data["parentLstEvents"].push(item.toJSON());
        }
        return data;
    }

    clone(): SchoolParentCalendarResponseDto {
        const json = this.toJSON();
        let result = new SchoolParentCalendarResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolParentCalendarResponseDto {
    parentLstEvents: CalendarParentAppModuleDto[];
}

export class CalendarParentAppModuleDto implements ICalendarParentAppModuleDto {
    schoolEventId!: number;
    id!: number;
    eventType!: string;
    academicYearId!: number | undefined;
    classId!: number | undefined;
    eventTitle!: string;
    eventCoordinator!: string;
    eventFess!: number;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    startTime!: moment.Moment | undefined;
    ngbStartTime!: SchoolNgbTimeModel | undefined;
    endTime!: moment.Moment | undefined;
    ngbEndTime!: SchoolNgbTimeModel | undefined;
    isPublished!: boolean;
    isCompulsory!: boolean;
    calendarDate!: moment.Moment | undefined;
    ngbCalendarDate!: SchoolNgbDateModel | undefined;
    holidayReason!: string;
    eventDescription!: string;
    vacationName!: string;
    weeklyOffName!: string;
    vacationStartDate!: moment.Moment | undefined;
    ngbVacationStartDate!: SchoolNgbDateModel | undefined;
    vacationEndDate!: moment.Moment | undefined;
    ngbVacationEndDate!: SchoolNgbDateModel | undefined;
    weeklyOffDate!: moment.Moment | undefined;
    ngbWeeklyOffDate!: SchoolNgbDateModel | undefined;
    lstEventDetail!: SchoolParentCalendarEventDetailAppDto[];

    constructor(data?: ICalendarParentAppModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.id = _data["id"];
            this.eventType = _data["eventType"];
            this.academicYearId = _data["academicYearId"];
            this.classId = _data["classId"];
            this.eventTitle = _data["eventTitle"];
            this.eventCoordinator = _data["eventCoordinator"];
            this.eventFess = _data["eventFess"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.ngbStartTime = _data["ngbStartTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbStartTime"]) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.ngbEndTime = _data["ngbEndTime"] ? SchoolNgbTimeModel.fromJS(_data["ngbEndTime"]) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.isCompulsory = _data["isCompulsory"];
            this.calendarDate = _data["calendarDate"] ? moment(_data["calendarDate"].toString()) : <any>undefined;
            this.ngbCalendarDate = _data["ngbCalendarDate"] ? SchoolNgbDateModel.fromJS(_data["ngbCalendarDate"]) : <any>undefined;
            this.holidayReason = _data["holidayReason"];
            this.eventDescription = _data["eventDescription"];
            this.vacationName = _data["vacationName"];
            this.weeklyOffName = _data["weeklyOffName"];
            this.vacationStartDate = _data["vacationStartDate"] ? moment(_data["vacationStartDate"].toString()) : <any>undefined;
            this.ngbVacationStartDate = _data["ngbVacationStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVacationStartDate"]) : <any>undefined;
            this.vacationEndDate = _data["vacationEndDate"] ? moment(_data["vacationEndDate"].toString()) : <any>undefined;
            this.ngbVacationEndDate = _data["ngbVacationEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbVacationEndDate"]) : <any>undefined;
            this.weeklyOffDate = _data["weeklyOffDate"] ? moment(_data["weeklyOffDate"].toString()) : <any>undefined;
            this.ngbWeeklyOffDate = _data["ngbWeeklyOffDate"] ? SchoolNgbDateModel.fromJS(_data["ngbWeeklyOffDate"]) : <any>undefined;
            if (Array.isArray(_data["lstEventDetail"])) {
                this.lstEventDetail = [] as any;
                for (let item of _data["lstEventDetail"])
                    this.lstEventDetail!.push(SchoolParentCalendarEventDetailAppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CalendarParentAppModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarParentAppModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["id"] = this.id;
        data["eventType"] = this.eventType;
        data["academicYearId"] = this.academicYearId;
        data["classId"] = this.classId;
        data["eventTitle"] = this.eventTitle;
        data["eventCoordinator"] = this.eventCoordinator;
        data["eventFess"] = this.eventFess;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["ngbStartTime"] = this.ngbStartTime ? this.ngbStartTime.toJSON() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["ngbEndTime"] = this.ngbEndTime ? this.ngbEndTime.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["isCompulsory"] = this.isCompulsory;
        data["calendarDate"] = this.calendarDate ? this.calendarDate.toISOString() : <any>undefined;
        data["ngbCalendarDate"] = this.ngbCalendarDate ? this.ngbCalendarDate.toJSON() : <any>undefined;
        data["holidayReason"] = this.holidayReason;
        data["eventDescription"] = this.eventDescription;
        data["vacationName"] = this.vacationName;
        data["weeklyOffName"] = this.weeklyOffName;
        data["vacationStartDate"] = this.vacationStartDate ? this.vacationStartDate.toISOString() : <any>undefined;
        data["ngbVacationStartDate"] = this.ngbVacationStartDate ? this.ngbVacationStartDate.toJSON() : <any>undefined;
        data["vacationEndDate"] = this.vacationEndDate ? this.vacationEndDate.toISOString() : <any>undefined;
        data["ngbVacationEndDate"] = this.ngbVacationEndDate ? this.ngbVacationEndDate.toJSON() : <any>undefined;
        data["weeklyOffDate"] = this.weeklyOffDate ? this.weeklyOffDate.toISOString() : <any>undefined;
        data["ngbWeeklyOffDate"] = this.ngbWeeklyOffDate ? this.ngbWeeklyOffDate.toJSON() : <any>undefined;
        if (Array.isArray(this.lstEventDetail)) {
            data["lstEventDetail"] = [];
            for (let item of this.lstEventDetail)
                data["lstEventDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): CalendarParentAppModuleDto {
        const json = this.toJSON();
        let result = new CalendarParentAppModuleDto();
        result.init(json);
        return result;
    }
}

export interface ICalendarParentAppModuleDto {
    schoolEventId: number;
    id: number;
    eventType: string;
    academicYearId: number | undefined;
    classId: number | undefined;
    eventTitle: string;
    eventCoordinator: string;
    eventFess: number;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    startTime: moment.Moment | undefined;
    ngbStartTime: SchoolNgbTimeModel | undefined;
    endTime: moment.Moment | undefined;
    ngbEndTime: SchoolNgbTimeModel | undefined;
    isPublished: boolean;
    isCompulsory: boolean;
    calendarDate: moment.Moment | undefined;
    ngbCalendarDate: SchoolNgbDateModel | undefined;
    holidayReason: string;
    eventDescription: string;
    vacationName: string;
    weeklyOffName: string;
    vacationStartDate: moment.Moment | undefined;
    ngbVacationStartDate: SchoolNgbDateModel | undefined;
    vacationEndDate: moment.Moment | undefined;
    ngbVacationEndDate: SchoolNgbDateModel | undefined;
    weeklyOffDate: moment.Moment | undefined;
    ngbWeeklyOffDate: SchoolNgbDateModel | undefined;
    lstEventDetail: SchoolParentCalendarEventDetailAppDto[];
}

export class SchoolParentCalendarEventDetailAppDto implements ISchoolParentCalendarEventDetailAppDto {
    schoolEventId!: number;
    schoolEventDetailsId!: number;
    fileName!: string;
    fullPath!: string;

    constructor(data?: ISchoolParentCalendarEventDetailAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolEventId = _data["schoolEventId"];
            this.schoolEventDetailsId = _data["schoolEventDetailsId"];
            this.fileName = _data["fileName"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): SchoolParentCalendarEventDetailAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolParentCalendarEventDetailAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolEventId"] = this.schoolEventId;
        data["schoolEventDetailsId"] = this.schoolEventDetailsId;
        data["fileName"] = this.fileName;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): SchoolParentCalendarEventDetailAppDto {
        const json = this.toJSON();
        let result = new SchoolParentCalendarEventDetailAppDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolParentCalendarEventDetailAppDto {
    schoolEventId: number;
    schoolEventDetailsId: number;
    fileName: string;
    fullPath: string;
}

export class VehicleTrackResponseDto implements IVehicleTrackResponseDto {
    vehicleTrackList!: VehicleTrackDto[];

    constructor(data?: IVehicleTrackResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["vehicleTrackList"])) {
                this.vehicleTrackList = [] as any;
                for (let item of _data["vehicleTrackList"])
                    this.vehicleTrackList!.push(VehicleTrackDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleTrackResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleTrackResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.vehicleTrackList)) {
            data["vehicleTrackList"] = [];
            for (let item of this.vehicleTrackList)
                data["vehicleTrackList"].push(item.toJSON());
        }
        return data;
    }

    clone(): VehicleTrackResponseDto {
        const json = this.toJSON();
        let result = new VehicleTrackResponseDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleTrackResponseDto {
    vehicleTrackList: VehicleTrackDto[];
}

export class VehicleTrackDto implements IVehicleTrackDto {
    lat!: string;
    lng!: string;
    vehicleNo!: string;
    registrationNo!: string;
    stopName!: string;
    orderNo!: number;

    constructor(data?: IVehicleTrackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.vehicleNo = _data["vehicleNo"];
            this.registrationNo = _data["registrationNo"];
            this.stopName = _data["stopName"];
            this.orderNo = _data["orderNo"];
        }
    }

    static fromJS(data: any): VehicleTrackDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleTrackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["vehicleNo"] = this.vehicleNo;
        data["registrationNo"] = this.registrationNo;
        data["stopName"] = this.stopName;
        data["orderNo"] = this.orderNo;
        return data;
    }

    clone(): VehicleTrackDto {
        const json = this.toJSON();
        let result = new VehicleTrackDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleTrackDto {
    lat: string;
    lng: string;
    vehicleNo: string;
    registrationNo: string;
    stopName: string;
    orderNo: number;
}

export class StoppageTrackResponseDto implements IStoppageTrackResponseDto {
    stoppageTrackList!: VehicleTrackDto[];

    constructor(data?: IStoppageTrackResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stoppageTrackList"])) {
                this.stoppageTrackList = [] as any;
                for (let item of _data["stoppageTrackList"])
                    this.stoppageTrackList!.push(VehicleTrackDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoppageTrackResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoppageTrackResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stoppageTrackList)) {
            data["stoppageTrackList"] = [];
            for (let item of this.stoppageTrackList)
                data["stoppageTrackList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StoppageTrackResponseDto {
        const json = this.toJSON();
        let result = new StoppageTrackResponseDto();
        result.init(json);
        return result;
    }
}

export interface IStoppageTrackResponseDto {
    stoppageTrackList: VehicleTrackDto[];
}

export class AddressMasterDto implements IAddressMasterDto {
    countryList!: CountryMasterDto[] | undefined;
    stateList!: StateMasterDto[] | undefined;
    districtList!: DistrictMasterDto[] | undefined;
    talukaList!: TalukaMasterDto[] | undefined;

    constructor(data?: IAddressMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["countryList"])) {
                this.countryList = [] as any;
                for (let item of _data["countryList"])
                    this.countryList!.push(CountryMasterDto.fromJS(item));
            }
            if (Array.isArray(_data["stateList"])) {
                this.stateList = [] as any;
                for (let item of _data["stateList"])
                    this.stateList!.push(StateMasterDto.fromJS(item));
            }
            if (Array.isArray(_data["districtList"])) {
                this.districtList = [] as any;
                for (let item of _data["districtList"])
                    this.districtList!.push(DistrictMasterDto.fromJS(item));
            }
            if (Array.isArray(_data["talukaList"])) {
                this.talukaList = [] as any;
                for (let item of _data["talukaList"])
                    this.talukaList!.push(TalukaMasterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddressMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.countryList)) {
            data["countryList"] = [];
            for (let item of this.countryList)
                data["countryList"].push(item.toJSON());
        }
        if (Array.isArray(this.stateList)) {
            data["stateList"] = [];
            for (let item of this.stateList)
                data["stateList"].push(item.toJSON());
        }
        if (Array.isArray(this.districtList)) {
            data["districtList"] = [];
            for (let item of this.districtList)
                data["districtList"].push(item.toJSON());
        }
        if (Array.isArray(this.talukaList)) {
            data["talukaList"] = [];
            for (let item of this.talukaList)
                data["talukaList"].push(item.toJSON());
        }
        return data;
    }

    clone(): AddressMasterDto {
        const json = this.toJSON();
        let result = new AddressMasterDto();
        result.init(json);
        return result;
    }
}

export interface IAddressMasterDto {
    countryList: CountryMasterDto[] | undefined;
    stateList: StateMasterDto[] | undefined;
    districtList: DistrictMasterDto[] | undefined;
    talukaList: TalukaMasterDto[] | undefined;
}

export class CountryMasterDto implements ICountryMasterDto {
    countryId!: number;
    countryName!: string | undefined;
    countryKey!: string | undefined;

    constructor(data?: ICountryMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.countryKey = _data["countryKey"];
        }
    }

    static fromJS(data: any): CountryMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["countryKey"] = this.countryKey;
        return data;
    }

    clone(): CountryMasterDto {
        const json = this.toJSON();
        let result = new CountryMasterDto();
        result.init(json);
        return result;
    }
}

export interface ICountryMasterDto {
    countryId: number;
    countryName: string | undefined;
    countryKey: string | undefined;
}

export class StateMasterDto implements IStateMasterDto {
    stateId!: number;
    countryId!: number;
    stateName!: string | undefined;
    stateKey!: string | undefined;

    constructor(data?: IStateMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.stateName = _data["stateName"];
            this.stateKey = _data["stateKey"];
        }
    }

    static fromJS(data: any): StateMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["stateName"] = this.stateName;
        data["stateKey"] = this.stateKey;
        return data;
    }

    clone(): StateMasterDto {
        const json = this.toJSON();
        let result = new StateMasterDto();
        result.init(json);
        return result;
    }
}

export interface IStateMasterDto {
    stateId: number;
    countryId: number;
    stateName: string | undefined;
    stateKey: string | undefined;
}

export class DistrictMasterDto implements IDistrictMasterDto {
    districtId!: number;
    stateId!: number;
    districtName!: string | undefined;
    districtKey!: string | undefined;

    constructor(data?: IDistrictMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.districtId = _data["districtId"];
            this.stateId = _data["stateId"];
            this.districtName = _data["districtName"];
            this.districtKey = _data["districtKey"];
        }
    }

    static fromJS(data: any): DistrictMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["districtId"] = this.districtId;
        data["stateId"] = this.stateId;
        data["districtName"] = this.districtName;
        data["districtKey"] = this.districtKey;
        return data;
    }

    clone(): DistrictMasterDto {
        const json = this.toJSON();
        let result = new DistrictMasterDto();
        result.init(json);
        return result;
    }
}

export interface IDistrictMasterDto {
    districtId: number;
    stateId: number;
    districtName: string | undefined;
    districtKey: string | undefined;
}

export class TalukaMasterDto implements ITalukaMasterDto {
    talukaId!: number;
    districtId!: number;
    talukaName!: string | undefined;
    talukaKey!: string | undefined;

    constructor(data?: ITalukaMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.talukaId = _data["talukaId"];
            this.districtId = _data["districtId"];
            this.talukaName = _data["talukaName"];
            this.talukaKey = _data["talukaKey"];
        }
    }

    static fromJS(data: any): TalukaMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new TalukaMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["talukaId"] = this.talukaId;
        data["districtId"] = this.districtId;
        data["talukaName"] = this.talukaName;
        data["talukaKey"] = this.talukaKey;
        return data;
    }

    clone(): TalukaMasterDto {
        const json = this.toJSON();
        let result = new TalukaMasterDto();
        result.init(json);
        return result;
    }
}

export interface ITalukaMasterDto {
    talukaId: number;
    districtId: number;
    talukaName: string | undefined;
    talukaKey: string | undefined;
}

export class MediumTypeResponse implements IMediumTypeResponse {
    mediumTypes!: MediumType[];

    constructor(data?: IMediumTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["mediumTypes"])) {
                this.mediumTypes = [] as any;
                for (let item of _data["mediumTypes"])
                    this.mediumTypes!.push(MediumType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MediumTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MediumTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.mediumTypes)) {
            data["mediumTypes"] = [];
            for (let item of this.mediumTypes)
                data["mediumTypes"].push(item.toJSON());
        }
        return data;
    }

    clone(): MediumTypeResponse {
        const json = this.toJSON();
        let result = new MediumTypeResponse();
        result.init(json);
        return result;
    }
}

export interface IMediumTypeResponse {
    mediumTypes: MediumType[];
}

export class MediumType implements IMediumType {
    mediumTypeId!: number;
    mediumTypeName!: string | undefined;
    mediumTypeKey!: string | undefined;

    constructor(data?: IMediumType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mediumTypeId = _data["mediumTypeId"];
            this.mediumTypeName = _data["mediumTypeName"];
            this.mediumTypeKey = _data["mediumTypeKey"];
        }
    }

    static fromJS(data: any): MediumType {
        data = typeof data === 'object' ? data : {};
        let result = new MediumType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mediumTypeId"] = this.mediumTypeId;
        data["mediumTypeName"] = this.mediumTypeName;
        data["mediumTypeKey"] = this.mediumTypeKey;
        return data;
    }

    clone(): MediumType {
        const json = this.toJSON();
        let result = new MediumType();
        result.init(json);
        return result;
    }
}

export interface IMediumType {
    mediumTypeId: number;
    mediumTypeName: string | undefined;
    mediumTypeKey: string | undefined;
}

export class AcademicYearResponse implements IAcademicYearResponse {
    academicYears!: AcademicYear[];

    constructor(data?: IAcademicYearResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["academicYears"])) {
                this.academicYears = [] as any;
                for (let item of _data["academicYears"])
                    this.academicYears!.push(AcademicYear.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AcademicYearResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicYearResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.academicYears)) {
            data["academicYears"] = [];
            for (let item of this.academicYears)
                data["academicYears"].push(item.toJSON());
        }
        return data;
    }

    clone(): AcademicYearResponse {
        const json = this.toJSON();
        let result = new AcademicYearResponse();
        result.init(json);
        return result;
    }
}

export interface IAcademicYearResponse {
    academicYears: AcademicYear[];
}

export class AcademicYear implements IAcademicYear {
    academicYearId!: number;
    academicYearName!: string;
    academicYearKey!: string;

    constructor(data?: IAcademicYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.academicYearName = _data["academicYearName"];
            this.academicYearKey = _data["academicYearKey"];
        }
    }

    static fromJS(data: any): AcademicYear {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicYear();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["academicYearName"] = this.academicYearName;
        data["academicYearKey"] = this.academicYearKey;
        return data;
    }

    clone(): AcademicYear {
        const json = this.toJSON();
        let result = new AcademicYear();
        result.init(json);
        return result;
    }
}

export interface IAcademicYear {
    academicYearId: number;
    academicYearName: string;
    academicYearKey: string;
}

export class GradeDivisionMasterDto implements IGradeDivisionMasterDto {
    schoolGradeDivisionMatrixCascadeList!: SchoolGradeDivisionMatrixDto[] | undefined;
    grades!: Grade[] | undefined;
    divisions!: Division[] | undefined;

    constructor(data?: IGradeDivisionMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["schoolGradeDivisionMatrixCascadeList"])) {
                this.schoolGradeDivisionMatrixCascadeList = [] as any;
                for (let item of _data["schoolGradeDivisionMatrixCascadeList"])
                    this.schoolGradeDivisionMatrixCascadeList!.push(SchoolGradeDivisionMatrixDto.fromJS(item));
            }
            if (Array.isArray(_data["grades"])) {
                this.grades = [] as any;
                for (let item of _data["grades"])
                    this.grades!.push(Grade.fromJS(item));
            }
            if (Array.isArray(_data["divisions"])) {
                this.divisions = [] as any;
                for (let item of _data["divisions"])
                    this.divisions!.push(Division.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GradeDivisionMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDivisionMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schoolGradeDivisionMatrixCascadeList)) {
            data["schoolGradeDivisionMatrixCascadeList"] = [];
            for (let item of this.schoolGradeDivisionMatrixCascadeList)
                data["schoolGradeDivisionMatrixCascadeList"].push(item.toJSON());
        }
        if (Array.isArray(this.grades)) {
            data["grades"] = [];
            for (let item of this.grades)
                data["grades"].push(item.toJSON());
        }
        if (Array.isArray(this.divisions)) {
            data["divisions"] = [];
            for (let item of this.divisions)
                data["divisions"].push(item.toJSON());
        }
        return data;
    }

    clone(): GradeDivisionMasterDto {
        const json = this.toJSON();
        let result = new GradeDivisionMasterDto();
        result.init(json);
        return result;
    }
}

export interface IGradeDivisionMasterDto {
    schoolGradeDivisionMatrixCascadeList: SchoolGradeDivisionMatrixDto[] | undefined;
    grades: Grade[] | undefined;
    divisions: Division[] | undefined;
}

export class Division implements IDivision {
    divisionId!: number | undefined;
    divisionName!: string | undefined;

    constructor(data?: IDivision) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
        }
    }

    static fromJS(data: any): Division {
        data = typeof data === 'object' ? data : {};
        let result = new Division();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        return data;
    }

    clone(): Division {
        const json = this.toJSON();
        let result = new Division();
        result.init(json);
        return result;
    }
}

export interface IDivision {
    divisionId: number | undefined;
    divisionName: string | undefined;
}

export class MonthMasterResponse implements IMonthMasterResponse {
    monthMasters!: MonthMasterDto[];

    constructor(data?: IMonthMasterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["monthMasters"])) {
                this.monthMasters = [] as any;
                for (let item of _data["monthMasters"])
                    this.monthMasters!.push(MonthMasterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MonthMasterResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MonthMasterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.monthMasters)) {
            data["monthMasters"] = [];
            for (let item of this.monthMasters)
                data["monthMasters"].push(item.toJSON());
        }
        return data;
    }

    clone(): MonthMasterResponse {
        const json = this.toJSON();
        let result = new MonthMasterResponse();
        result.init(json);
        return result;
    }
}

export interface IMonthMasterResponse {
    monthMasters: MonthMasterDto[];
}

export class MonthMasterDto implements IMonthMasterDto {
    monthMasterId!: number;
    monthName!: string | undefined;
    monthNameKey!: string | undefined;

    constructor(data?: IMonthMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.monthMasterId = _data["monthMasterId"];
            this.monthName = _data["monthName"];
            this.monthNameKey = _data["monthNameKey"];
        }
    }

    static fromJS(data: any): MonthMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new MonthMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monthMasterId"] = this.monthMasterId;
        data["monthName"] = this.monthName;
        data["monthNameKey"] = this.monthNameKey;
        return data;
    }

    clone(): MonthMasterDto {
        const json = this.toJSON();
        let result = new MonthMasterDto();
        result.init(json);
        return result;
    }
}

export interface IMonthMasterDto {
    monthMasterId: number;
    monthName: string | undefined;
    monthNameKey: string | undefined;
}

export class TeacherDropdownSelectListResponseDto implements ITeacherDropdownSelectListResponseDto {
    lstDropdownValues!: TeacherDropdownSelectListDto[];

    constructor(data?: ITeacherDropdownSelectListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstDropdownValues"])) {
                this.lstDropdownValues = [] as any;
                for (let item of _data["lstDropdownValues"])
                    this.lstDropdownValues!.push(TeacherDropdownSelectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherDropdownSelectListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDropdownSelectListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstDropdownValues)) {
            data["lstDropdownValues"] = [];
            for (let item of this.lstDropdownValues)
                data["lstDropdownValues"].push(item.toJSON());
        }
        return data;
    }

    clone(): TeacherDropdownSelectListResponseDto {
        const json = this.toJSON();
        let result = new TeacherDropdownSelectListResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherDropdownSelectListResponseDto {
    lstDropdownValues: TeacherDropdownSelectListDto[];
}

export class TeacherDropdownSelectListDto implements ITeacherDropdownSelectListDto {
    teacherId!: number;
    teacherName!: string;
    subjectMasterId!: number;

    constructor(data?: ITeacherDropdownSelectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            this.teacherName = _data["teacherName"];
            this.subjectMasterId = _data["subjectMasterId"];
        }
    }

    static fromJS(data: any): TeacherDropdownSelectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDropdownSelectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        data["teacherName"] = this.teacherName;
        data["subjectMasterId"] = this.subjectMasterId;
        return data;
    }

    clone(): TeacherDropdownSelectListDto {
        const json = this.toJSON();
        let result = new TeacherDropdownSelectListDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherDropdownSelectListDto {
    teacherId: number;
    teacherName: string;
    subjectMasterId: number;
}

export class SchoolDto implements ISchoolDto {
    schoolId!: number | undefined;
    schoolName!: string | undefined;
    schoolCode!: string | undefined;
    schoolCodeNo!: string | undefined;
    schoolAddress!: string | undefined;
    mediumTypeName!: string | undefined;
    schoolEmail!: string | undefined;
    schoolContactNo1!: string | undefined;
    schoolContactNo2!: string | undefined;
    schoolAddressLine1!: string | undefined;
    schoolAddressLine2!: string | undefined;
    talukaId!: number | undefined;
    districtId!: number | undefined;
    stateId!: number | undefined;
    countryId!: number | undefined;
    talukaName!: string | undefined;
    districtName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    pincode!: string | undefined;
    establishmentDate!: moment.Moment | undefined;
    ngbEstablishmentDate!: SchoolNgbDateModel | undefined;
    schoolRank!: string | undefined;
    schoolWebsiteUrl!: string | undefined;
    logoUrl!: string | undefined;
    bannerUrl!: string | undefined;
    schoolDescription!: string | undefined;
    contactPersonName!: string | undefined;
    contactPersonRole!: string | undefined;
    contactPersonEmail!: string | undefined;
    contactPersonMobileNo!: string | undefined;
    academicYearId!: number | undefined;
    authorisedBy!: string | undefined;
    section!: string | undefined;
    schoolMediumId!: number | undefined;
    schoolPermission!: string | undefined;
    registrationNumber!: string | undefined;
    schoolType!: string | undefined;
    udiseNumber!: string | undefined;
    board!: string | undefined;
    affiliationNumber!: string | undefined;
    hscOrSscIndexNo!: string | undefined;
    base64LogoImage!: string | undefined;
    logoImageContentType!: string | undefined;
    langaugeCode!: string | undefined;

    constructor(data?: ISchoolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolId = _data["schoolId"];
            this.schoolName = _data["schoolName"];
            this.schoolCode = _data["schoolCode"];
            this.schoolCodeNo = _data["schoolCodeNo"];
            this.schoolAddress = _data["schoolAddress"];
            this.mediumTypeName = _data["mediumTypeName"];
            this.schoolEmail = _data["schoolEmail"];
            this.schoolContactNo1 = _data["schoolContactNo1"];
            this.schoolContactNo2 = _data["schoolContactNo2"];
            this.schoolAddressLine1 = _data["schoolAddressLine1"];
            this.schoolAddressLine2 = _data["schoolAddressLine2"];
            this.talukaId = _data["talukaId"];
            this.districtId = _data["districtId"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.talukaName = _data["talukaName"];
            this.districtName = _data["districtName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.pincode = _data["pincode"];
            this.establishmentDate = _data["establishmentDate"] ? moment(_data["establishmentDate"].toString()) : <any>undefined;
            this.ngbEstablishmentDate = _data["ngbEstablishmentDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEstablishmentDate"]) : <any>undefined;
            this.schoolRank = _data["schoolRank"];
            this.schoolWebsiteUrl = _data["schoolWebsiteUrl"];
            this.logoUrl = _data["logoUrl"];
            this.bannerUrl = _data["bannerUrl"];
            this.schoolDescription = _data["schoolDescription"];
            this.contactPersonName = _data["contactPersonName"];
            this.contactPersonRole = _data["contactPersonRole"];
            this.contactPersonEmail = _data["contactPersonEmail"];
            this.contactPersonMobileNo = _data["contactPersonMobileNo"];
            this.academicYearId = _data["academicYearId"];
            this.authorisedBy = _data["authorisedBy"];
            this.section = _data["section"];
            this.schoolMediumId = _data["schoolMediumId"];
            this.schoolPermission = _data["schoolPermission"];
            this.registrationNumber = _data["registrationNumber"];
            this.schoolType = _data["schoolType"];
            this.udiseNumber = _data["udiseNumber"];
            this.board = _data["board"];
            this.affiliationNumber = _data["affiliationNumber"];
            this.hscOrSscIndexNo = _data["hscOrSscIndexNo"];
            this.base64LogoImage = _data["base64LogoImage"];
            this.logoImageContentType = _data["logoImageContentType"];
            this.langaugeCode = _data["langaugeCode"];
        }
    }

    static fromJS(data: any): SchoolDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolId"] = this.schoolId;
        data["schoolName"] = this.schoolName;
        data["schoolCode"] = this.schoolCode;
        data["schoolCodeNo"] = this.schoolCodeNo;
        data["schoolAddress"] = this.schoolAddress;
        data["mediumTypeName"] = this.mediumTypeName;
        data["schoolEmail"] = this.schoolEmail;
        data["schoolContactNo1"] = this.schoolContactNo1;
        data["schoolContactNo2"] = this.schoolContactNo2;
        data["schoolAddressLine1"] = this.schoolAddressLine1;
        data["schoolAddressLine2"] = this.schoolAddressLine2;
        data["talukaId"] = this.talukaId;
        data["districtId"] = this.districtId;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["talukaName"] = this.talukaName;
        data["districtName"] = this.districtName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["pincode"] = this.pincode;
        data["establishmentDate"] = this.establishmentDate ? this.establishmentDate.toISOString() : <any>undefined;
        data["ngbEstablishmentDate"] = this.ngbEstablishmentDate ? this.ngbEstablishmentDate.toJSON() : <any>undefined;
        data["schoolRank"] = this.schoolRank;
        data["schoolWebsiteUrl"] = this.schoolWebsiteUrl;
        data["logoUrl"] = this.logoUrl;
        data["bannerUrl"] = this.bannerUrl;
        data["schoolDescription"] = this.schoolDescription;
        data["contactPersonName"] = this.contactPersonName;
        data["contactPersonRole"] = this.contactPersonRole;
        data["contactPersonEmail"] = this.contactPersonEmail;
        data["contactPersonMobileNo"] = this.contactPersonMobileNo;
        data["academicYearId"] = this.academicYearId;
        data["authorisedBy"] = this.authorisedBy;
        data["section"] = this.section;
        data["schoolMediumId"] = this.schoolMediumId;
        data["schoolPermission"] = this.schoolPermission;
        data["registrationNumber"] = this.registrationNumber;
        data["schoolType"] = this.schoolType;
        data["udiseNumber"] = this.udiseNumber;
        data["board"] = this.board;
        data["affiliationNumber"] = this.affiliationNumber;
        data["hscOrSscIndexNo"] = this.hscOrSscIndexNo;
        data["base64LogoImage"] = this.base64LogoImage;
        data["logoImageContentType"] = this.logoImageContentType;
        data["langaugeCode"] = this.langaugeCode;
        return data;
    }

    clone(): SchoolDto {
        const json = this.toJSON();
        let result = new SchoolDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolDto {
    schoolId: number | undefined;
    schoolName: string | undefined;
    schoolCode: string | undefined;
    schoolCodeNo: string | undefined;
    schoolAddress: string | undefined;
    mediumTypeName: string | undefined;
    schoolEmail: string | undefined;
    schoolContactNo1: string | undefined;
    schoolContactNo2: string | undefined;
    schoolAddressLine1: string | undefined;
    schoolAddressLine2: string | undefined;
    talukaId: number | undefined;
    districtId: number | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    talukaName: string | undefined;
    districtName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    pincode: string | undefined;
    establishmentDate: moment.Moment | undefined;
    ngbEstablishmentDate: SchoolNgbDateModel | undefined;
    schoolRank: string | undefined;
    schoolWebsiteUrl: string | undefined;
    logoUrl: string | undefined;
    bannerUrl: string | undefined;
    schoolDescription: string | undefined;
    contactPersonName: string | undefined;
    contactPersonRole: string | undefined;
    contactPersonEmail: string | undefined;
    contactPersonMobileNo: string | undefined;
    academicYearId: number | undefined;
    authorisedBy: string | undefined;
    section: string | undefined;
    schoolMediumId: number | undefined;
    schoolPermission: string | undefined;
    registrationNumber: string | undefined;
    schoolType: string | undefined;
    udiseNumber: string | undefined;
    board: string | undefined;
    affiliationNumber: string | undefined;
    hscOrSscIndexNo: string | undefined;
    base64LogoImage: string | undefined;
    logoImageContentType: string | undefined;
    langaugeCode: string | undefined;
}

export class SchoolSettingDto implements ISchoolSettingDto {
    schoolId!: number | undefined;
    academicYearId!: number | undefined;
    academicYearStartMonth!: moment.Moment | undefined;
    ngbAcademicYearStartMonth!: SchoolNgbDateModel | undefined;
    invoiceNoPrefix!: string | undefined;
    invoiceNoStartNumber!: number | undefined;
    transportInvoiceNoPrefix!: string | undefined;
    transportInvoiceNoStartNumber!: number | undefined;
    additionalFeeInvoiceNoPrefix!: string | undefined;
    additionalFeeInvoiceNoStartNumber!: number | undefined;
    schoolKitInvoiceNoPrefix!: string | undefined;
    schoolKitInvoiceNoStartNumber!: number | undefined;
    registrationFeeInvoiceNoPrefix!: string | undefined;
    registrationFeeInvoiceNoStartNumber!: number | undefined;
    serialNoStartNumber!: number | undefined;
    accountNumber!: string | undefined;
    accountTypeId!: number | undefined;
    ifscCode!: string | undefined;
    accountName!: string | undefined;
    schoolEmail!: string | undefined;
    schoolContactNo1!: string | undefined;
    langaugeCode!: string | undefined;
    isSharedTransport!: boolean | undefined;
    isFeeApplicableToStaff!: boolean | undefined;
    monthList!: number[];

    constructor(data?: ISchoolSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolId = _data["schoolId"];
            this.academicYearId = _data["academicYearId"];
            this.academicYearStartMonth = _data["academicYearStartMonth"] ? moment(_data["academicYearStartMonth"].toString()) : <any>undefined;
            this.ngbAcademicYearStartMonth = _data["ngbAcademicYearStartMonth"] ? SchoolNgbDateModel.fromJS(_data["ngbAcademicYearStartMonth"]) : <any>undefined;
            this.invoiceNoPrefix = _data["invoiceNoPrefix"];
            this.invoiceNoStartNumber = _data["invoiceNoStartNumber"];
            this.transportInvoiceNoPrefix = _data["transportInvoiceNoPrefix"];
            this.transportInvoiceNoStartNumber = _data["transportInvoiceNoStartNumber"];
            this.additionalFeeInvoiceNoPrefix = _data["additionalFeeInvoiceNoPrefix"];
            this.additionalFeeInvoiceNoStartNumber = _data["additionalFeeInvoiceNoStartNumber"];
            this.schoolKitInvoiceNoPrefix = _data["schoolKitInvoiceNoPrefix"];
            this.schoolKitInvoiceNoStartNumber = _data["schoolKitInvoiceNoStartNumber"];
            this.registrationFeeInvoiceNoPrefix = _data["registrationFeeInvoiceNoPrefix"];
            this.registrationFeeInvoiceNoStartNumber = _data["registrationFeeInvoiceNoStartNumber"];
            this.serialNoStartNumber = _data["serialNoStartNumber"];
            this.accountNumber = _data["accountNumber"];
            this.accountTypeId = _data["accountTypeId"];
            this.ifscCode = _data["ifscCode"];
            this.accountName = _data["accountName"];
            this.schoolEmail = _data["schoolEmail"];
            this.schoolContactNo1 = _data["schoolContactNo1"];
            this.langaugeCode = _data["langaugeCode"];
            this.isSharedTransport = _data["isSharedTransport"];
            this.isFeeApplicableToStaff = _data["isFeeApplicableToStaff"];
            if (Array.isArray(_data["monthList"])) {
                this.monthList = [] as any;
                for (let item of _data["monthList"])
                    this.monthList!.push(item);
            }
        }
    }

    static fromJS(data: any): SchoolSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolId"] = this.schoolId;
        data["academicYearId"] = this.academicYearId;
        data["academicYearStartMonth"] = this.academicYearStartMonth ? this.academicYearStartMonth.toISOString() : <any>undefined;
        data["ngbAcademicYearStartMonth"] = this.ngbAcademicYearStartMonth ? this.ngbAcademicYearStartMonth.toJSON() : <any>undefined;
        data["invoiceNoPrefix"] = this.invoiceNoPrefix;
        data["invoiceNoStartNumber"] = this.invoiceNoStartNumber;
        data["transportInvoiceNoPrefix"] = this.transportInvoiceNoPrefix;
        data["transportInvoiceNoStartNumber"] = this.transportInvoiceNoStartNumber;
        data["additionalFeeInvoiceNoPrefix"] = this.additionalFeeInvoiceNoPrefix;
        data["additionalFeeInvoiceNoStartNumber"] = this.additionalFeeInvoiceNoStartNumber;
        data["schoolKitInvoiceNoPrefix"] = this.schoolKitInvoiceNoPrefix;
        data["schoolKitInvoiceNoStartNumber"] = this.schoolKitInvoiceNoStartNumber;
        data["registrationFeeInvoiceNoPrefix"] = this.registrationFeeInvoiceNoPrefix;
        data["registrationFeeInvoiceNoStartNumber"] = this.registrationFeeInvoiceNoStartNumber;
        data["serialNoStartNumber"] = this.serialNoStartNumber;
        data["accountNumber"] = this.accountNumber;
        data["accountTypeId"] = this.accountTypeId;
        data["ifscCode"] = this.ifscCode;
        data["accountName"] = this.accountName;
        data["schoolEmail"] = this.schoolEmail;
        data["schoolContactNo1"] = this.schoolContactNo1;
        data["langaugeCode"] = this.langaugeCode;
        data["isSharedTransport"] = this.isSharedTransport;
        data["isFeeApplicableToStaff"] = this.isFeeApplicableToStaff;
        if (Array.isArray(this.monthList)) {
            data["monthList"] = [];
            for (let item of this.monthList)
                data["monthList"].push(item);
        }
        return data;
    }

    clone(): SchoolSettingDto {
        const json = this.toJSON();
        let result = new SchoolSettingDto();
        result.init(json);
        return result;
    }
}

export interface ISchoolSettingDto {
    schoolId: number | undefined;
    academicYearId: number | undefined;
    academicYearStartMonth: moment.Moment | undefined;
    ngbAcademicYearStartMonth: SchoolNgbDateModel | undefined;
    invoiceNoPrefix: string | undefined;
    invoiceNoStartNumber: number | undefined;
    transportInvoiceNoPrefix: string | undefined;
    transportInvoiceNoStartNumber: number | undefined;
    additionalFeeInvoiceNoPrefix: string | undefined;
    additionalFeeInvoiceNoStartNumber: number | undefined;
    schoolKitInvoiceNoPrefix: string | undefined;
    schoolKitInvoiceNoStartNumber: number | undefined;
    registrationFeeInvoiceNoPrefix: string | undefined;
    registrationFeeInvoiceNoStartNumber: number | undefined;
    serialNoStartNumber: number | undefined;
    accountNumber: string | undefined;
    accountTypeId: number | undefined;
    ifscCode: string | undefined;
    accountName: string | undefined;
    schoolEmail: string | undefined;
    schoolContactNo1: string | undefined;
    langaugeCode: string | undefined;
    isSharedTransport: boolean | undefined;
    isFeeApplicableToStaff: boolean | undefined;
    monthList: number[];
}

export class AppVersionDto implements IAppVersionDto {
    configurationValue!: string | undefined;
    isUpdateCheck!: boolean;

    constructor(data?: IAppVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configurationValue = _data["configurationValue"];
            this.isUpdateCheck = _data["isUpdateCheck"];
        }
    }

    static fromJS(data: any): AppVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configurationValue"] = this.configurationValue;
        data["isUpdateCheck"] = this.isUpdateCheck;
        return data;
    }

    clone(): AppVersionDto {
        const json = this.toJSON();
        let result = new AppVersionDto();
        result.init(json);
        return result;
    }
}

export interface IAppVersionDto {
    configurationValue: string | undefined;
    isUpdateCheck: boolean;
}

export class ResponseImportStudentDataDto implements IResponseImportStudentDataDto {
    hasPaymentHistoryList!: ResposnsePaymentHistory[];
    hasDublicateGenRegNoList!: ResposnseDublicateGenRegNo[];
    students!: ImportStudentDataDto[];
    suceess!: number;
    insertedCount!: number;
    updatedCount!: number;

    constructor(data?: IResponseImportStudentDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["hasPaymentHistoryList"])) {
                this.hasPaymentHistoryList = [] as any;
                for (let item of _data["hasPaymentHistoryList"])
                    this.hasPaymentHistoryList!.push(ResposnsePaymentHistory.fromJS(item));
            }
            if (Array.isArray(_data["hasDublicateGenRegNoList"])) {
                this.hasDublicateGenRegNoList = [] as any;
                for (let item of _data["hasDublicateGenRegNoList"])
                    this.hasDublicateGenRegNoList!.push(ResposnseDublicateGenRegNo.fromJS(item));
            }
            if (Array.isArray(_data["students"])) {
                this.students = [] as any;
                for (let item of _data["students"])
                    this.students!.push(ImportStudentDataDto.fromJS(item));
            }
            this.suceess = _data["suceess"];
            this.insertedCount = _data["insertedCount"];
            this.updatedCount = _data["updatedCount"];
        }
    }

    static fromJS(data: any): ResponseImportStudentDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseImportStudentDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hasPaymentHistoryList)) {
            data["hasPaymentHistoryList"] = [];
            for (let item of this.hasPaymentHistoryList)
                data["hasPaymentHistoryList"].push(item.toJSON());
        }
        if (Array.isArray(this.hasDublicateGenRegNoList)) {
            data["hasDublicateGenRegNoList"] = [];
            for (let item of this.hasDublicateGenRegNoList)
                data["hasDublicateGenRegNoList"].push(item.toJSON());
        }
        if (Array.isArray(this.students)) {
            data["students"] = [];
            for (let item of this.students)
                data["students"].push(item.toJSON());
        }
        data["suceess"] = this.suceess;
        data["insertedCount"] = this.insertedCount;
        data["updatedCount"] = this.updatedCount;
        return data;
    }

    clone(): ResponseImportStudentDataDto {
        const json = this.toJSON();
        let result = new ResponseImportStudentDataDto();
        result.init(json);
        return result;
    }
}

export interface IResponseImportStudentDataDto {
    hasPaymentHistoryList: ResposnsePaymentHistory[];
    hasDublicateGenRegNoList: ResposnseDublicateGenRegNo[];
    students: ImportStudentDataDto[];
    suceess: number;
    insertedCount: number;
    updatedCount: number;
}

export class ResposnsePaymentHistory implements IResposnsePaymentHistory {
    student_First_Name!: string;
    student_Middle_Name!: string;
    student_Last_Name!: string;
    hasPaymentHistory!: number;

    constructor(data?: IResposnsePaymentHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.student_First_Name = _data["student_First_Name"];
            this.student_Middle_Name = _data["student_Middle_Name"];
            this.student_Last_Name = _data["student_Last_Name"];
            this.hasPaymentHistory = _data["hasPaymentHistory"];
        }
    }

    static fromJS(data: any): ResposnsePaymentHistory {
        data = typeof data === 'object' ? data : {};
        let result = new ResposnsePaymentHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["student_First_Name"] = this.student_First_Name;
        data["student_Middle_Name"] = this.student_Middle_Name;
        data["student_Last_Name"] = this.student_Last_Name;
        data["hasPaymentHistory"] = this.hasPaymentHistory;
        return data;
    }

    clone(): ResposnsePaymentHistory {
        const json = this.toJSON();
        let result = new ResposnsePaymentHistory();
        result.init(json);
        return result;
    }
}

export interface IResposnsePaymentHistory {
    student_First_Name: string;
    student_Middle_Name: string;
    student_Last_Name: string;
    hasPaymentHistory: number;
}

export class ResposnseDublicateGenRegNo implements IResposnseDublicateGenRegNo {
    student_First_Name!: string;
    student_Middle_Name!: string;
    student_Last_Name!: string;
    studentId!: number;
    genRegNoExist!: number;

    constructor(data?: IResposnseDublicateGenRegNo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.student_First_Name = _data["student_First_Name"];
            this.student_Middle_Name = _data["student_Middle_Name"];
            this.student_Last_Name = _data["student_Last_Name"];
            this.studentId = _data["studentId"];
            this.genRegNoExist = _data["genRegNoExist"];
        }
    }

    static fromJS(data: any): ResposnseDublicateGenRegNo {
        data = typeof data === 'object' ? data : {};
        let result = new ResposnseDublicateGenRegNo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["student_First_Name"] = this.student_First_Name;
        data["student_Middle_Name"] = this.student_Middle_Name;
        data["student_Last_Name"] = this.student_Last_Name;
        data["studentId"] = this.studentId;
        data["genRegNoExist"] = this.genRegNoExist;
        return data;
    }

    clone(): ResposnseDublicateGenRegNo {
        const json = this.toJSON();
        let result = new ResposnseDublicateGenRegNo();
        result.init(json);
        return result;
    }
}

export interface IResposnseDublicateGenRegNo {
    student_First_Name: string;
    student_Middle_Name: string;
    student_Last_Name: string;
    studentId: number;
    genRegNoExist: number;
}

export class ImportStudentDataDto implements IImportStudentDataDto {
    gen_Reg_No!: string;
    admission_No!: string;
    roll_No!: string;
    grade!: string;
    division!: string;
    admission_Date!: moment.Moment | undefined;
    cbsC_Student_Id!: string;
    student_First_Name!: string;
    student_Middle_Name!: string;
    student_Last_Name!: string;
    gender!: string;
    adhaar_No!: string;
    religion!: string;
    category!: string;
    cast!: string;
    sub_Caste!: string;
    nationality!: string;
    mother_Tongue!: string;
    emergency_Contact_Person_Name!: string;
    emergency_Contact_No!: string;
    family_Doctor_Name!: string;
    family_Doctor_No!: string;
    birth_Place!: string;
    birthDate!: moment.Moment | undefined;
    date_Of_Birth_In_Words!: string;
    birth_Country!: string;
    birth_State!: string;
    birth_District!: string;
    birth_Taluka!: string;
    current_Address_Line_1!: string;
    current_Address_Line_2!: string;
    current_Pincode!: string;
    current_Country!: string;
    current_State!: string;
    current_District!: string;
    current_Taluka!: string;
    blood_Group!: string;
    height!: number | undefined;
    weight!: number | undefined;
    medical_History_Notes!: string;
    previous_School_Name!: string;
    previous_School_Standard!: string;
    previous_School_Division!: string;
    progress_Note_From_Last_School!: string;
    conduct_Note_From_Last_School!: string;
    reason_of_Leaving_School!: string;
    date_of_Leaving_of_Previous_School!: moment.Moment | undefined;
    remark!: string;
    is_New_Student!: boolean;
    is_Deactive!: boolean;
    is_RTE!: boolean;
    apply_Concession!: boolean;
    concession_Fee!: number | undefined;
    academic_Year!: string;
    previousAcademicYearPendingFeeAmount!: number | undefined;
    do_you_required_parent_mobile_app_access!: boolean;
    mobile_Number_for_Application_Access!: string;
    appAccessOneTimePassword!: string;
    passwordSalt!: string;
    upassword!: string;
    father_First_Name!: string;
    father_Middle_Name!: string;
    father_Last_Name!: string;
    father_Gender!: string;
    father_Mobile_No!: string;
    father_Alternate_Contact_No!: string;
    father_Email_Id!: string;
    father_Address_Line_1!: string;
    father_Address_Line_2!: string;
    father_Country!: string;
    father_State!: string;
    father_District!: string;
    father_Taluka!: string;
    father_Pincode!: string;
    father_Adhaar_No!: string;
    father_Education!: string;
    father_Birth_Date!: moment.Moment | undefined;
    father_Occupation!: string;
    father_Annual_Income!: number | undefined;
    father_Blood_Group!: string;
    mother_First_Name!: string;
    mother_Middle_Name!: string;
    mother_Last_Name!: string;
    mother_Gender!: string;
    mother_Mobile_No!: string;
    mother_Alternate_Contact_No!: string;
    mother_Email_Id!: string;
    mother_Address_Line_1!: string;
    mother_Address_Line_2!: string;
    mother_Country!: string;
    mother_State!: string;
    mother_District!: string;
    mother_Taluka!: string;
    mother_Pincode!: string;
    mother_Adhaar_No!: string;
    mother_Education!: string;
    mother_Birth_Date!: moment.Moment | undefined;
    mother_Occupation!: string;
    mother_Annual_Income!: number | undefined;
    mother_Blood_Group!: string;
    guardian_First_Name!: string;
    guardian_Middle_Name!: string;
    guardian_Last_Name!: string;
    guardian_Gender!: string;
    guardian_Mobile_No!: string;
    guardian_Alternate_Contact_No!: string;
    guardian_Email_Id!: string;
    guardian_Address_Line_1!: string;
    guardian_Address_Line_2!: string;
    guardian_Country!: string;
    guardian_State!: string;
    guardian_District!: string;
    guardian_Taluka!: string;
    guardian_Pincode!: string;
    guardian_Adhaar_No!: string;
    guardian_Education!: string;
    guardian_Birth_Date!: moment.Moment | undefined;
    guardian_Occupation!: string;
    guardian_Annual_Income!: number | undefined;
    guardian_Blood_Group!: string;
    current_CountryId!: number | undefined;
    current_StateId!: number | undefined;
    current_DistrictId!: number | undefined;
    current_TalukaId!: number | undefined;
    birth_CountryId!: number | undefined;
    birth_StateId!: number | undefined;
    birth_DistrictId!: number | undefined;
    birth_TalukaId!: number | undefined;
    father_CountryId!: number | undefined;
    father_StateId!: number | undefined;
    father_DistrictId!: number | undefined;
    father_TalukaId!: number | undefined;
    mother_CountryId!: number | undefined;
    mother_StateId!: number | undefined;
    mother_DistrictId!: number | undefined;
    mother_TalukaId!: number | undefined;
    gaurdian_CountryId!: number | undefined;
    gaurdian_StateId!: number | undefined;
    gaurdian_DistrictId!: number | undefined;
    gaurdian_TalukaId!: number | undefined;

    constructor(data?: IImportStudentDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gen_Reg_No = _data["gen_Reg_No"];
            this.admission_No = _data["admission_No"];
            this.roll_No = _data["roll_No"];
            this.grade = _data["grade"];
            this.division = _data["division"];
            this.admission_Date = _data["admission_Date"] ? moment(_data["admission_Date"].toString()) : <any>undefined;
            this.cbsC_Student_Id = _data["cbsC_Student_Id"];
            this.student_First_Name = _data["student_First_Name"];
            this.student_Middle_Name = _data["student_Middle_Name"];
            this.student_Last_Name = _data["student_Last_Name"];
            this.gender = _data["gender"];
            this.adhaar_No = _data["adhaar_No"];
            this.religion = _data["religion"];
            this.category = _data["category"];
            this.cast = _data["cast"];
            this.sub_Caste = _data["sub_Caste"];
            this.nationality = _data["nationality"];
            this.mother_Tongue = _data["mother_Tongue"];
            this.emergency_Contact_Person_Name = _data["emergency_Contact_Person_Name"];
            this.emergency_Contact_No = _data["emergency_Contact_No"];
            this.family_Doctor_Name = _data["family_Doctor_Name"];
            this.family_Doctor_No = _data["family_Doctor_No"];
            this.birth_Place = _data["birth_Place"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.date_Of_Birth_In_Words = _data["date_Of_Birth_In_Words"];
            this.birth_Country = _data["birth_Country"];
            this.birth_State = _data["birth_State"];
            this.birth_District = _data["birth_District"];
            this.birth_Taluka = _data["birth_Taluka"];
            this.current_Address_Line_1 = _data["current_Address_Line_1"];
            this.current_Address_Line_2 = _data["current_Address_Line_2"];
            this.current_Pincode = _data["current_Pincode"];
            this.current_Country = _data["current_Country"];
            this.current_State = _data["current_State"];
            this.current_District = _data["current_District"];
            this.current_Taluka = _data["current_Taluka"];
            this.blood_Group = _data["blood_Group"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.medical_History_Notes = _data["medical_History_Notes"];
            this.previous_School_Name = _data["previous_School_Name"];
            this.previous_School_Standard = _data["previous_School_Standard"];
            this.previous_School_Division = _data["previous_School_Division"];
            this.progress_Note_From_Last_School = _data["progress_Note_From_Last_School"];
            this.conduct_Note_From_Last_School = _data["conduct_Note_From_Last_School"];
            this.reason_of_Leaving_School = _data["reason_of_Leaving_School"];
            this.date_of_Leaving_of_Previous_School = _data["date_of_Leaving_of_Previous_School"] ? moment(_data["date_of_Leaving_of_Previous_School"].toString()) : <any>undefined;
            this.remark = _data["remark"];
            this.is_New_Student = _data["is_New_Student"];
            this.is_Deactive = _data["is_Deactive"];
            this.is_RTE = _data["is_RTE"];
            this.apply_Concession = _data["apply_Concession"];
            this.concession_Fee = _data["concession_Fee"];
            this.academic_Year = _data["academic_Year"];
            this.previousAcademicYearPendingFeeAmount = _data["previousAcademicYearPendingFeeAmount"];
            this.do_you_required_parent_mobile_app_access = _data["do_you_required_parent_mobile_app_access"];
            this.mobile_Number_for_Application_Access = _data["mobile_Number_for_Application_Access"];
            this.appAccessOneTimePassword = _data["appAccessOneTimePassword"];
            this.passwordSalt = _data["passwordSalt"];
            this.upassword = _data["upassword"];
            this.father_First_Name = _data["father_First_Name"];
            this.father_Middle_Name = _data["father_Middle_Name"];
            this.father_Last_Name = _data["father_Last_Name"];
            this.father_Gender = _data["father_Gender"];
            this.father_Mobile_No = _data["father_Mobile_No"];
            this.father_Alternate_Contact_No = _data["father_Alternate_Contact_No"];
            this.father_Email_Id = _data["father_Email_Id"];
            this.father_Address_Line_1 = _data["father_Address_Line_1"];
            this.father_Address_Line_2 = _data["father_Address_Line_2"];
            this.father_Country = _data["father_Country"];
            this.father_State = _data["father_State"];
            this.father_District = _data["father_District"];
            this.father_Taluka = _data["father_Taluka"];
            this.father_Pincode = _data["father_Pincode"];
            this.father_Adhaar_No = _data["father_Adhaar_No"];
            this.father_Education = _data["father_Education"];
            this.father_Birth_Date = _data["father_Birth_Date"] ? moment(_data["father_Birth_Date"].toString()) : <any>undefined;
            this.father_Occupation = _data["father_Occupation"];
            this.father_Annual_Income = _data["father_Annual_Income"];
            this.father_Blood_Group = _data["father_Blood_Group"];
            this.mother_First_Name = _data["mother_First_Name"];
            this.mother_Middle_Name = _data["mother_Middle_Name"];
            this.mother_Last_Name = _data["mother_Last_Name"];
            this.mother_Gender = _data["mother_Gender"];
            this.mother_Mobile_No = _data["mother_Mobile_No"];
            this.mother_Alternate_Contact_No = _data["mother_Alternate_Contact_No"];
            this.mother_Email_Id = _data["mother_Email_Id"];
            this.mother_Address_Line_1 = _data["mother_Address_Line_1"];
            this.mother_Address_Line_2 = _data["mother_Address_Line_2"];
            this.mother_Country = _data["mother_Country"];
            this.mother_State = _data["mother_State"];
            this.mother_District = _data["mother_District"];
            this.mother_Taluka = _data["mother_Taluka"];
            this.mother_Pincode = _data["mother_Pincode"];
            this.mother_Adhaar_No = _data["mother_Adhaar_No"];
            this.mother_Education = _data["mother_Education"];
            this.mother_Birth_Date = _data["mother_Birth_Date"] ? moment(_data["mother_Birth_Date"].toString()) : <any>undefined;
            this.mother_Occupation = _data["mother_Occupation"];
            this.mother_Annual_Income = _data["mother_Annual_Income"];
            this.mother_Blood_Group = _data["mother_Blood_Group"];
            this.guardian_First_Name = _data["guardian_First_Name"];
            this.guardian_Middle_Name = _data["guardian_Middle_Name"];
            this.guardian_Last_Name = _data["guardian_Last_Name"];
            this.guardian_Gender = _data["guardian_Gender"];
            this.guardian_Mobile_No = _data["guardian_Mobile_No"];
            this.guardian_Alternate_Contact_No = _data["guardian_Alternate_Contact_No"];
            this.guardian_Email_Id = _data["guardian_Email_Id"];
            this.guardian_Address_Line_1 = _data["guardian_Address_Line_1"];
            this.guardian_Address_Line_2 = _data["guardian_Address_Line_2"];
            this.guardian_Country = _data["guardian_Country"];
            this.guardian_State = _data["guardian_State"];
            this.guardian_District = _data["guardian_District"];
            this.guardian_Taluka = _data["guardian_Taluka"];
            this.guardian_Pincode = _data["guardian_Pincode"];
            this.guardian_Adhaar_No = _data["guardian_Adhaar_No"];
            this.guardian_Education = _data["guardian_Education"];
            this.guardian_Birth_Date = _data["guardian_Birth_Date"] ? moment(_data["guardian_Birth_Date"].toString()) : <any>undefined;
            this.guardian_Occupation = _data["guardian_Occupation"];
            this.guardian_Annual_Income = _data["guardian_Annual_Income"];
            this.guardian_Blood_Group = _data["guardian_Blood_Group"];
            this.current_CountryId = _data["current_CountryId"];
            this.current_StateId = _data["current_StateId"];
            this.current_DistrictId = _data["current_DistrictId"];
            this.current_TalukaId = _data["current_TalukaId"];
            this.birth_CountryId = _data["birth_CountryId"];
            this.birth_StateId = _data["birth_StateId"];
            this.birth_DistrictId = _data["birth_DistrictId"];
            this.birth_TalukaId = _data["birth_TalukaId"];
            this.father_CountryId = _data["father_CountryId"];
            this.father_StateId = _data["father_StateId"];
            this.father_DistrictId = _data["father_DistrictId"];
            this.father_TalukaId = _data["father_TalukaId"];
            this.mother_CountryId = _data["mother_CountryId"];
            this.mother_StateId = _data["mother_StateId"];
            this.mother_DistrictId = _data["mother_DistrictId"];
            this.mother_TalukaId = _data["mother_TalukaId"];
            this.gaurdian_CountryId = _data["gaurdian_CountryId"];
            this.gaurdian_StateId = _data["gaurdian_StateId"];
            this.gaurdian_DistrictId = _data["gaurdian_DistrictId"];
            this.gaurdian_TalukaId = _data["gaurdian_TalukaId"];
        }
    }

    static fromJS(data: any): ImportStudentDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportStudentDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gen_Reg_No"] = this.gen_Reg_No;
        data["admission_No"] = this.admission_No;
        data["roll_No"] = this.roll_No;
        data["grade"] = this.grade;
        data["division"] = this.division;
        data["admission_Date"] = this.admission_Date ? this.admission_Date.toISOString() : <any>undefined;
        data["cbsC_Student_Id"] = this.cbsC_Student_Id;
        data["student_First_Name"] = this.student_First_Name;
        data["student_Middle_Name"] = this.student_Middle_Name;
        data["student_Last_Name"] = this.student_Last_Name;
        data["gender"] = this.gender;
        data["adhaar_No"] = this.adhaar_No;
        data["religion"] = this.religion;
        data["category"] = this.category;
        data["cast"] = this.cast;
        data["sub_Caste"] = this.sub_Caste;
        data["nationality"] = this.nationality;
        data["mother_Tongue"] = this.mother_Tongue;
        data["emergency_Contact_Person_Name"] = this.emergency_Contact_Person_Name;
        data["emergency_Contact_No"] = this.emergency_Contact_No;
        data["family_Doctor_Name"] = this.family_Doctor_Name;
        data["family_Doctor_No"] = this.family_Doctor_No;
        data["birth_Place"] = this.birth_Place;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["date_Of_Birth_In_Words"] = this.date_Of_Birth_In_Words;
        data["birth_Country"] = this.birth_Country;
        data["birth_State"] = this.birth_State;
        data["birth_District"] = this.birth_District;
        data["birth_Taluka"] = this.birth_Taluka;
        data["current_Address_Line_1"] = this.current_Address_Line_1;
        data["current_Address_Line_2"] = this.current_Address_Line_2;
        data["current_Pincode"] = this.current_Pincode;
        data["current_Country"] = this.current_Country;
        data["current_State"] = this.current_State;
        data["current_District"] = this.current_District;
        data["current_Taluka"] = this.current_Taluka;
        data["blood_Group"] = this.blood_Group;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["medical_History_Notes"] = this.medical_History_Notes;
        data["previous_School_Name"] = this.previous_School_Name;
        data["previous_School_Standard"] = this.previous_School_Standard;
        data["previous_School_Division"] = this.previous_School_Division;
        data["progress_Note_From_Last_School"] = this.progress_Note_From_Last_School;
        data["conduct_Note_From_Last_School"] = this.conduct_Note_From_Last_School;
        data["reason_of_Leaving_School"] = this.reason_of_Leaving_School;
        data["date_of_Leaving_of_Previous_School"] = this.date_of_Leaving_of_Previous_School ? this.date_of_Leaving_of_Previous_School.toISOString() : <any>undefined;
        data["remark"] = this.remark;
        data["is_New_Student"] = this.is_New_Student;
        data["is_Deactive"] = this.is_Deactive;
        data["is_RTE"] = this.is_RTE;
        data["apply_Concession"] = this.apply_Concession;
        data["concession_Fee"] = this.concession_Fee;
        data["academic_Year"] = this.academic_Year;
        data["previousAcademicYearPendingFeeAmount"] = this.previousAcademicYearPendingFeeAmount;
        data["do_you_required_parent_mobile_app_access"] = this.do_you_required_parent_mobile_app_access;
        data["mobile_Number_for_Application_Access"] = this.mobile_Number_for_Application_Access;
        data["appAccessOneTimePassword"] = this.appAccessOneTimePassword;
        data["passwordSalt"] = this.passwordSalt;
        data["upassword"] = this.upassword;
        data["father_First_Name"] = this.father_First_Name;
        data["father_Middle_Name"] = this.father_Middle_Name;
        data["father_Last_Name"] = this.father_Last_Name;
        data["father_Gender"] = this.father_Gender;
        data["father_Mobile_No"] = this.father_Mobile_No;
        data["father_Alternate_Contact_No"] = this.father_Alternate_Contact_No;
        data["father_Email_Id"] = this.father_Email_Id;
        data["father_Address_Line_1"] = this.father_Address_Line_1;
        data["father_Address_Line_2"] = this.father_Address_Line_2;
        data["father_Country"] = this.father_Country;
        data["father_State"] = this.father_State;
        data["father_District"] = this.father_District;
        data["father_Taluka"] = this.father_Taluka;
        data["father_Pincode"] = this.father_Pincode;
        data["father_Adhaar_No"] = this.father_Adhaar_No;
        data["father_Education"] = this.father_Education;
        data["father_Birth_Date"] = this.father_Birth_Date ? this.father_Birth_Date.toISOString() : <any>undefined;
        data["father_Occupation"] = this.father_Occupation;
        data["father_Annual_Income"] = this.father_Annual_Income;
        data["father_Blood_Group"] = this.father_Blood_Group;
        data["mother_First_Name"] = this.mother_First_Name;
        data["mother_Middle_Name"] = this.mother_Middle_Name;
        data["mother_Last_Name"] = this.mother_Last_Name;
        data["mother_Gender"] = this.mother_Gender;
        data["mother_Mobile_No"] = this.mother_Mobile_No;
        data["mother_Alternate_Contact_No"] = this.mother_Alternate_Contact_No;
        data["mother_Email_Id"] = this.mother_Email_Id;
        data["mother_Address_Line_1"] = this.mother_Address_Line_1;
        data["mother_Address_Line_2"] = this.mother_Address_Line_2;
        data["mother_Country"] = this.mother_Country;
        data["mother_State"] = this.mother_State;
        data["mother_District"] = this.mother_District;
        data["mother_Taluka"] = this.mother_Taluka;
        data["mother_Pincode"] = this.mother_Pincode;
        data["mother_Adhaar_No"] = this.mother_Adhaar_No;
        data["mother_Education"] = this.mother_Education;
        data["mother_Birth_Date"] = this.mother_Birth_Date ? this.mother_Birth_Date.toISOString() : <any>undefined;
        data["mother_Occupation"] = this.mother_Occupation;
        data["mother_Annual_Income"] = this.mother_Annual_Income;
        data["mother_Blood_Group"] = this.mother_Blood_Group;
        data["guardian_First_Name"] = this.guardian_First_Name;
        data["guardian_Middle_Name"] = this.guardian_Middle_Name;
        data["guardian_Last_Name"] = this.guardian_Last_Name;
        data["guardian_Gender"] = this.guardian_Gender;
        data["guardian_Mobile_No"] = this.guardian_Mobile_No;
        data["guardian_Alternate_Contact_No"] = this.guardian_Alternate_Contact_No;
        data["guardian_Email_Id"] = this.guardian_Email_Id;
        data["guardian_Address_Line_1"] = this.guardian_Address_Line_1;
        data["guardian_Address_Line_2"] = this.guardian_Address_Line_2;
        data["guardian_Country"] = this.guardian_Country;
        data["guardian_State"] = this.guardian_State;
        data["guardian_District"] = this.guardian_District;
        data["guardian_Taluka"] = this.guardian_Taluka;
        data["guardian_Pincode"] = this.guardian_Pincode;
        data["guardian_Adhaar_No"] = this.guardian_Adhaar_No;
        data["guardian_Education"] = this.guardian_Education;
        data["guardian_Birth_Date"] = this.guardian_Birth_Date ? this.guardian_Birth_Date.toISOString() : <any>undefined;
        data["guardian_Occupation"] = this.guardian_Occupation;
        data["guardian_Annual_Income"] = this.guardian_Annual_Income;
        data["guardian_Blood_Group"] = this.guardian_Blood_Group;
        data["current_CountryId"] = this.current_CountryId;
        data["current_StateId"] = this.current_StateId;
        data["current_DistrictId"] = this.current_DistrictId;
        data["current_TalukaId"] = this.current_TalukaId;
        data["birth_CountryId"] = this.birth_CountryId;
        data["birth_StateId"] = this.birth_StateId;
        data["birth_DistrictId"] = this.birth_DistrictId;
        data["birth_TalukaId"] = this.birth_TalukaId;
        data["father_CountryId"] = this.father_CountryId;
        data["father_StateId"] = this.father_StateId;
        data["father_DistrictId"] = this.father_DistrictId;
        data["father_TalukaId"] = this.father_TalukaId;
        data["mother_CountryId"] = this.mother_CountryId;
        data["mother_StateId"] = this.mother_StateId;
        data["mother_DistrictId"] = this.mother_DistrictId;
        data["mother_TalukaId"] = this.mother_TalukaId;
        data["gaurdian_CountryId"] = this.gaurdian_CountryId;
        data["gaurdian_StateId"] = this.gaurdian_StateId;
        data["gaurdian_DistrictId"] = this.gaurdian_DistrictId;
        data["gaurdian_TalukaId"] = this.gaurdian_TalukaId;
        return data;
    }

    clone(): ImportStudentDataDto {
        const json = this.toJSON();
        let result = new ImportStudentDataDto();
        result.init(json);
        return result;
    }
}

export interface IImportStudentDataDto {
    gen_Reg_No: string;
    admission_No: string;
    roll_No: string;
    grade: string;
    division: string;
    admission_Date: moment.Moment | undefined;
    cbsC_Student_Id: string;
    student_First_Name: string;
    student_Middle_Name: string;
    student_Last_Name: string;
    gender: string;
    adhaar_No: string;
    religion: string;
    category: string;
    cast: string;
    sub_Caste: string;
    nationality: string;
    mother_Tongue: string;
    emergency_Contact_Person_Name: string;
    emergency_Contact_No: string;
    family_Doctor_Name: string;
    family_Doctor_No: string;
    birth_Place: string;
    birthDate: moment.Moment | undefined;
    date_Of_Birth_In_Words: string;
    birth_Country: string;
    birth_State: string;
    birth_District: string;
    birth_Taluka: string;
    current_Address_Line_1: string;
    current_Address_Line_2: string;
    current_Pincode: string;
    current_Country: string;
    current_State: string;
    current_District: string;
    current_Taluka: string;
    blood_Group: string;
    height: number | undefined;
    weight: number | undefined;
    medical_History_Notes: string;
    previous_School_Name: string;
    previous_School_Standard: string;
    previous_School_Division: string;
    progress_Note_From_Last_School: string;
    conduct_Note_From_Last_School: string;
    reason_of_Leaving_School: string;
    date_of_Leaving_of_Previous_School: moment.Moment | undefined;
    remark: string;
    is_New_Student: boolean;
    is_Deactive: boolean;
    is_RTE: boolean;
    apply_Concession: boolean;
    concession_Fee: number | undefined;
    academic_Year: string;
    previousAcademicYearPendingFeeAmount: number | undefined;
    do_you_required_parent_mobile_app_access: boolean;
    mobile_Number_for_Application_Access: string;
    appAccessOneTimePassword: string;
    passwordSalt: string;
    upassword: string;
    father_First_Name: string;
    father_Middle_Name: string;
    father_Last_Name: string;
    father_Gender: string;
    father_Mobile_No: string;
    father_Alternate_Contact_No: string;
    father_Email_Id: string;
    father_Address_Line_1: string;
    father_Address_Line_2: string;
    father_Country: string;
    father_State: string;
    father_District: string;
    father_Taluka: string;
    father_Pincode: string;
    father_Adhaar_No: string;
    father_Education: string;
    father_Birth_Date: moment.Moment | undefined;
    father_Occupation: string;
    father_Annual_Income: number | undefined;
    father_Blood_Group: string;
    mother_First_Name: string;
    mother_Middle_Name: string;
    mother_Last_Name: string;
    mother_Gender: string;
    mother_Mobile_No: string;
    mother_Alternate_Contact_No: string;
    mother_Email_Id: string;
    mother_Address_Line_1: string;
    mother_Address_Line_2: string;
    mother_Country: string;
    mother_State: string;
    mother_District: string;
    mother_Taluka: string;
    mother_Pincode: string;
    mother_Adhaar_No: string;
    mother_Education: string;
    mother_Birth_Date: moment.Moment | undefined;
    mother_Occupation: string;
    mother_Annual_Income: number | undefined;
    mother_Blood_Group: string;
    guardian_First_Name: string;
    guardian_Middle_Name: string;
    guardian_Last_Name: string;
    guardian_Gender: string;
    guardian_Mobile_No: string;
    guardian_Alternate_Contact_No: string;
    guardian_Email_Id: string;
    guardian_Address_Line_1: string;
    guardian_Address_Line_2: string;
    guardian_Country: string;
    guardian_State: string;
    guardian_District: string;
    guardian_Taluka: string;
    guardian_Pincode: string;
    guardian_Adhaar_No: string;
    guardian_Education: string;
    guardian_Birth_Date: moment.Moment | undefined;
    guardian_Occupation: string;
    guardian_Annual_Income: number | undefined;
    guardian_Blood_Group: string;
    current_CountryId: number | undefined;
    current_StateId: number | undefined;
    current_DistrictId: number | undefined;
    current_TalukaId: number | undefined;
    birth_CountryId: number | undefined;
    birth_StateId: number | undefined;
    birth_DistrictId: number | undefined;
    birth_TalukaId: number | undefined;
    father_CountryId: number | undefined;
    father_StateId: number | undefined;
    father_DistrictId: number | undefined;
    father_TalukaId: number | undefined;
    mother_CountryId: number | undefined;
    mother_StateId: number | undefined;
    mother_DistrictId: number | undefined;
    mother_TalukaId: number | undefined;
    gaurdian_CountryId: number | undefined;
    gaurdian_StateId: number | undefined;
    gaurdian_DistrictId: number | undefined;
    gaurdian_TalukaId: number | undefined;
}

export class ResponseImportSubjectDataDto implements IResponseImportSubjectDataDto {
    subjects!: ImportSubjectDataDto[];
    suceess!: number;

    constructor(data?: IResponseImportSubjectDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(ImportSubjectDataDto.fromJS(item));
            }
            this.suceess = _data["suceess"];
        }
    }

    static fromJS(data: any): ResponseImportSubjectDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseImportSubjectDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        data["suceess"] = this.suceess;
        return data;
    }

    clone(): ResponseImportSubjectDataDto {
        const json = this.toJSON();
        let result = new ResponseImportSubjectDataDto();
        result.init(json);
        return result;
    }
}

export interface IResponseImportSubjectDataDto {
    subjects: ImportSubjectDataDto[];
    suceess: number;
}

export class ImportSubjectDataDto implements IImportSubjectDataDto {
    subject_Name!: string;

    constructor(data?: IImportSubjectDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject_Name = _data["subject_Name"];
        }
    }

    static fromJS(data: any): ImportSubjectDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSubjectDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject_Name"] = this.subject_Name;
        return data;
    }

    clone(): ImportSubjectDataDto {
        const json = this.toJSON();
        let result = new ImportSubjectDataDto();
        result.init(json);
        return result;
    }
}

export interface IImportSubjectDataDto {
    subject_Name: string;
}

export class ResponseImportTeacherDataDto implements IResponseImportTeacherDataDto {
    teachers!: ImportTeacherDataDto[];
    suceess!: number;
    insertedCount!: number;
    updatedCount!: number;

    constructor(data?: IResponseImportTeacherDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["teachers"])) {
                this.teachers = [] as any;
                for (let item of _data["teachers"])
                    this.teachers!.push(ImportTeacherDataDto.fromJS(item));
            }
            this.suceess = _data["suceess"];
            this.insertedCount = _data["insertedCount"];
            this.updatedCount = _data["updatedCount"];
        }
    }

    static fromJS(data: any): ResponseImportTeacherDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseImportTeacherDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.teachers)) {
            data["teachers"] = [];
            for (let item of this.teachers)
                data["teachers"].push(item.toJSON());
        }
        data["suceess"] = this.suceess;
        data["insertedCount"] = this.insertedCount;
        data["updatedCount"] = this.updatedCount;
        return data;
    }

    clone(): ResponseImportTeacherDataDto {
        const json = this.toJSON();
        let result = new ResponseImportTeacherDataDto();
        result.init(json);
        return result;
    }
}

export interface IResponseImportTeacherDataDto {
    teachers: ImportTeacherDataDto[];
    suceess: number;
    insertedCount: number;
    updatedCount: number;
}

export class ImportTeacherDataDto implements IImportTeacherDataDto {
    firstName!: string;
    middleName!: string;
    lastName!: string;
    gender!: string;
    mobileNumber!: string;
    contactNumber!: string;
    emailId!: string;
    addressLine1!: string;
    addressLine2!: string;
    countryName!: string;
    stateName!: string;
    districtName!: string;
    talukaName!: string;
    pincode!: string;
    adharNumber!: string;
    education!: string;
    birthDate!: moment.Moment | undefined;
    bloodGroup!: string;
    isAppAccess!: boolean | undefined;
    appAccessMobileNo!: string;
    appAccessOneTimePassword!: string;
    passwordSalt!: string;
    upassword!: string;
    countryId!: number;
    stateId!: number;
    districtId!: number;
    talukaId!: number;

    constructor(data?: IImportTeacherDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.gender = _data["gender"];
            this.mobileNumber = _data["mobileNumber"];
            this.contactNumber = _data["contactNumber"];
            this.emailId = _data["emailId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.districtName = _data["districtName"];
            this.talukaName = _data["talukaName"];
            this.pincode = _data["pincode"];
            this.adharNumber = _data["adharNumber"];
            this.education = _data["education"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.bloodGroup = _data["bloodGroup"];
            this.isAppAccess = _data["isAppAccess"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.appAccessOneTimePassword = _data["appAccessOneTimePassword"];
            this.passwordSalt = _data["passwordSalt"];
            this.upassword = _data["upassword"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.districtId = _data["districtId"];
            this.talukaId = _data["talukaId"];
        }
    }

    static fromJS(data: any): ImportTeacherDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTeacherDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["gender"] = this.gender;
        data["mobileNumber"] = this.mobileNumber;
        data["contactNumber"] = this.contactNumber;
        data["emailId"] = this.emailId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["districtName"] = this.districtName;
        data["talukaName"] = this.talukaName;
        data["pincode"] = this.pincode;
        data["adharNumber"] = this.adharNumber;
        data["education"] = this.education;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["bloodGroup"] = this.bloodGroup;
        data["isAppAccess"] = this.isAppAccess;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["appAccessOneTimePassword"] = this.appAccessOneTimePassword;
        data["passwordSalt"] = this.passwordSalt;
        data["upassword"] = this.upassword;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["districtId"] = this.districtId;
        data["talukaId"] = this.talukaId;
        return data;
    }

    clone(): ImportTeacherDataDto {
        const json = this.toJSON();
        let result = new ImportTeacherDataDto();
        result.init(json);
        return result;
    }
}

export interface IImportTeacherDataDto {
    firstName: string;
    middleName: string;
    lastName: string;
    gender: string;
    mobileNumber: string;
    contactNumber: string;
    emailId: string;
    addressLine1: string;
    addressLine2: string;
    countryName: string;
    stateName: string;
    districtName: string;
    talukaName: string;
    pincode: string;
    adharNumber: string;
    education: string;
    birthDate: moment.Moment | undefined;
    bloodGroup: string;
    isAppAccess: boolean | undefined;
    appAccessMobileNo: string;
    appAccessOneTimePassword: string;
    passwordSalt: string;
    upassword: string;
    countryId: number;
    stateId: number;
    districtId: number;
    talukaId: number;
}

export class SubjectMappingDropdownResponseDto implements ISubjectMappingDropdownResponseDto {
    subjectsList!: SubjectMappingDropdownDto[];

    constructor(data?: ISubjectMappingDropdownResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subjectsList"])) {
                this.subjectsList = [] as any;
                for (let item of _data["subjectsList"])
                    this.subjectsList!.push(SubjectMappingDropdownDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubjectMappingDropdownResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMappingDropdownResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subjectsList)) {
            data["subjectsList"] = [];
            for (let item of this.subjectsList)
                data["subjectsList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubjectMappingDropdownResponseDto {
        const json = this.toJSON();
        let result = new SubjectMappingDropdownResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMappingDropdownResponseDto {
    subjectsList: SubjectMappingDropdownDto[];
}

export class SubjectMappingDropdownDto implements ISubjectMappingDropdownDto {
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    subjectId!: number;
    academicYearId!: number | undefined;
    subjectName!: string;

    constructor(data?: ISubjectMappingDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.subjectId = _data["subjectId"];
            this.academicYearId = _data["academicYearId"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): SubjectMappingDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMappingDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["subjectId"] = this.subjectId;
        data["academicYearId"] = this.academicYearId;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): SubjectMappingDropdownDto {
        const json = this.toJSON();
        let result = new SubjectMappingDropdownDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectMappingDropdownDto {
    gradeId: number | undefined;
    divisionId: number | undefined;
    subjectId: number;
    academicYearId: number | undefined;
    subjectName: string;
}

export class ParentAppHomeworkResponseDto implements IParentAppHomeworkResponseDto {
    homeworkList!: ParentAppHomeworkDto[];

    constructor(data?: IParentAppHomeworkResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["homeworkList"])) {
                this.homeworkList = [] as any;
                for (let item of _data["homeworkList"])
                    this.homeworkList!.push(ParentAppHomeworkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParentAppHomeworkResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppHomeworkResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.homeworkList)) {
            data["homeworkList"] = [];
            for (let item of this.homeworkList)
                data["homeworkList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ParentAppHomeworkResponseDto {
        const json = this.toJSON();
        let result = new ParentAppHomeworkResponseDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppHomeworkResponseDto {
    homeworkList: ParentAppHomeworkDto[];
}

export class ParentAppHomeworkDto implements IParentAppHomeworkDto {
    homeworkId!: number;
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    studentId!: number;
    subjectId!: number;
    subjectName!: string;
    homeworkTitle!: string;
    homeworkDescription!: string;
    fromDate!: moment.Moment;
    ngbFromDate!: SchoolNgbDateModel | undefined;
    tillDate!: moment.Moment;
    ngbTillDate!: SchoolNgbDateModel | undefined;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    endDate!: moment.Moment | undefined;
    ngbEndDate!: SchoolNgbDateModel | undefined;
    isPublished!: boolean;
    userId!: number;
    fileType!: MediaContentType4;
    lstMediaVideoText!: ParentAppHomeworkMediaContentDto[];
    lstHomeworkDetail!: ParentAppHomeworkDetailDto[];

    constructor(data?: IParentAppHomeworkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.homeworkId = _data["homeworkId"];
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.studentId = _data["studentId"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.homeworkTitle = _data["homeworkTitle"];
            this.homeworkDescription = _data["homeworkDescription"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.ngbFromDate = _data["ngbFromDate"] ? SchoolNgbDateModel.fromJS(_data["ngbFromDate"]) : <any>undefined;
            this.tillDate = _data["tillDate"] ? moment(_data["tillDate"].toString()) : <any>undefined;
            this.ngbTillDate = _data["ngbTillDate"] ? SchoolNgbDateModel.fromJS(_data["ngbTillDate"]) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.ngbEndDate = _data["ngbEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbEndDate"]) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.userId = _data["userId"];
            this.fileType = _data["fileType"];
            if (Array.isArray(_data["lstMediaVideoText"])) {
                this.lstMediaVideoText = [] as any;
                for (let item of _data["lstMediaVideoText"])
                    this.lstMediaVideoText!.push(ParentAppHomeworkMediaContentDto.fromJS(item));
            }
            if (Array.isArray(_data["lstHomeworkDetail"])) {
                this.lstHomeworkDetail = [] as any;
                for (let item of _data["lstHomeworkDetail"])
                    this.lstHomeworkDetail!.push(ParentAppHomeworkDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParentAppHomeworkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppHomeworkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["homeworkId"] = this.homeworkId;
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["studentId"] = this.studentId;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["homeworkTitle"] = this.homeworkTitle;
        data["homeworkDescription"] = this.homeworkDescription;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["ngbFromDate"] = this.ngbFromDate ? this.ngbFromDate.toJSON() : <any>undefined;
        data["tillDate"] = this.tillDate ? this.tillDate.toISOString() : <any>undefined;
        data["ngbTillDate"] = this.ngbTillDate ? this.ngbTillDate.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ngbEndDate"] = this.ngbEndDate ? this.ngbEndDate.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["userId"] = this.userId;
        data["fileType"] = this.fileType;
        if (Array.isArray(this.lstMediaVideoText)) {
            data["lstMediaVideoText"] = [];
            for (let item of this.lstMediaVideoText)
                data["lstMediaVideoText"].push(item.toJSON());
        }
        if (Array.isArray(this.lstHomeworkDetail)) {
            data["lstHomeworkDetail"] = [];
            for (let item of this.lstHomeworkDetail)
                data["lstHomeworkDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ParentAppHomeworkDto {
        const json = this.toJSON();
        let result = new ParentAppHomeworkDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppHomeworkDto {
    homeworkId: number;
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    studentId: number;
    subjectId: number;
    subjectName: string;
    homeworkTitle: string;
    homeworkDescription: string;
    fromDate: moment.Moment;
    ngbFromDate: SchoolNgbDateModel | undefined;
    tillDate: moment.Moment;
    ngbTillDate: SchoolNgbDateModel | undefined;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    endDate: moment.Moment | undefined;
    ngbEndDate: SchoolNgbDateModel | undefined;
    isPublished: boolean;
    userId: number;
    fileType: MediaContentType4;
    lstMediaVideoText: ParentAppHomeworkMediaContentDto[];
    lstHomeworkDetail: ParentAppHomeworkDetailDto[];
}

export enum MediaContentType4 {
    IMAGE = 1,
    VIDEO = 2,
}

export class ParentAppHomeworkMediaContentDto implements IParentAppHomeworkMediaContentDto {
    homeworkId!: number;
    contentUrl!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IParentAppHomeworkMediaContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.homeworkId = _data["homeworkId"];
            this.contentUrl = _data["contentUrl"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): ParentAppHomeworkMediaContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppHomeworkMediaContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["homeworkId"] = this.homeworkId;
        data["contentUrl"] = this.contentUrl;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): ParentAppHomeworkMediaContentDto {
        const json = this.toJSON();
        let result = new ParentAppHomeworkMediaContentDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppHomeworkMediaContentDto {
    homeworkId: number;
    contentUrl: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class ParentAppHomeworkDetailDto implements IParentAppHomeworkDetailDto {
    homeworkId!: number;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IParentAppHomeworkDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.homeworkId = _data["homeworkId"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): ParentAppHomeworkDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppHomeworkDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["homeworkId"] = this.homeworkId;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): ParentAppHomeworkDetailDto {
        const json = this.toJSON();
        let result = new ParentAppHomeworkDetailDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppHomeworkDetailDto {
    homeworkId: number;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class ParentAppHomeworkRequestDto implements IParentAppHomeworkRequestDto {
    academicYearId!: number;
    month!: number;
    year!: number;
    studentId!: number;

    constructor(data?: IParentAppHomeworkRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.studentId = _data["studentId"];
        }
    }

    static fromJS(data: any): ParentAppHomeworkRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppHomeworkRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["month"] = this.month;
        data["year"] = this.year;
        data["studentId"] = this.studentId;
        return data;
    }

    clone(): ParentAppHomeworkRequestDto {
        const json = this.toJSON();
        let result = new ParentAppHomeworkRequestDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppHomeworkRequestDto {
    academicYearId: number;
    month: number;
    year: number;
    studentId: number;
}

export class GradeDto implements IGradeDto {
    gradeId!: number | undefined;
    gradeName!: string | undefined;

    constructor(data?: IGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
        }
    }

    static fromJS(data: any): GradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        return data;
    }

    clone(): GradeDto {
        const json = this.toJSON();
        let result = new GradeDto();
        result.init(json);
        return result;
    }
}

export interface IGradeDto {
    gradeId: number | undefined;
    gradeName: string | undefined;
}

export class GradeUpdateRespose implements IGradeUpdateRespose {
    exits!: number;

    constructor(data?: IGradeUpdateRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exits = _data["exits"];
        }
    }

    static fromJS(data: any): GradeUpdateRespose {
        data = typeof data === 'object' ? data : {};
        let result = new GradeUpdateRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exits"] = this.exits;
        return data;
    }

    clone(): GradeUpdateRespose {
        const json = this.toJSON();
        let result = new GradeUpdateRespose();
        result.init(json);
        return result;
    }
}

export interface IGradeUpdateRespose {
    exits: number;
}

export class GradeDeleteRespose implements IGradeDeleteRespose {
    affectedRows!: number;

    constructor(data?: IGradeDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): GradeDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): GradeDeleteRespose {
        const json = this.toJSON();
        let result = new GradeDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IGradeDeleteRespose {
    affectedRows: number;
}

export class GradeDivisionMatrixDto implements IGradeDivisionMatrixDto {
    gradeId!: number;
    gradeName!: string;
    divisionId!: number[];
    gradeDivisions!: string;

    constructor(data?: IGradeDivisionMatrixDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            if (Array.isArray(_data["divisionId"])) {
                this.divisionId = [] as any;
                for (let item of _data["divisionId"])
                    this.divisionId!.push(item);
            }
            this.gradeDivisions = _data["gradeDivisions"];
        }
    }

    static fromJS(data: any): GradeDivisionMatrixDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDivisionMatrixDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        if (Array.isArray(this.divisionId)) {
            data["divisionId"] = [];
            for (let item of this.divisionId)
                data["divisionId"].push(item);
        }
        data["gradeDivisions"] = this.gradeDivisions;
        return data;
    }

    clone(): GradeDivisionMatrixDto {
        const json = this.toJSON();
        let result = new GradeDivisionMatrixDto();
        result.init(json);
        return result;
    }
}

export interface IGradeDivisionMatrixDto {
    gradeId: number;
    gradeName: string;
    divisionId: number[];
    gradeDivisions: string;
}

export class GradeDivisionMatrixDeleteRespose implements IGradeDivisionMatrixDeleteRespose {
    affectedRows!: number;

    constructor(data?: IGradeDivisionMatrixDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): GradeDivisionMatrixDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDivisionMatrixDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): GradeDivisionMatrixDeleteRespose {
        const json = this.toJSON();
        let result = new GradeDivisionMatrixDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IGradeDivisionMatrixDeleteRespose {
    affectedRows: number;
}

export class ParentAppGalleryResponseDto implements IParentAppGalleryResponseDto {
    galleryList!: ParentAppGalleryDto[];

    constructor(data?: IParentAppGalleryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["galleryList"])) {
                this.galleryList = [] as any;
                for (let item of _data["galleryList"])
                    this.galleryList!.push(ParentAppGalleryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParentAppGalleryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppGalleryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.galleryList)) {
            data["galleryList"] = [];
            for (let item of this.galleryList)
                data["galleryList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ParentAppGalleryResponseDto {
        const json = this.toJSON();
        let result = new ParentAppGalleryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppGalleryResponseDto {
    galleryList: ParentAppGalleryDto[];
}

export class ParentAppGalleryDto implements IParentAppGalleryDto {
    galleryId!: number;
    studentId!: number;
    gradeId!: number;
    divisionId!: number;
    galleryToType!: number | undefined;
    galleryTitle!: string;
    description!: string;
    startDate!: moment.Moment | undefined;
    ngbStartDate!: SchoolNgbDateModel | undefined;
    isPublished!: boolean;
    userId!: number;
    roleId!: number;
    roleKey!: string;
    name!: string;
    roleName!: string;
    createdDate!: moment.Moment;
    lstGalleryDetail!: ParentAppGalleryDetailDto[];
    lstGalleryMediaDetail!: MediaGalleryContentDto[];

    constructor(data?: IParentAppGalleryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.galleryId = _data["galleryId"];
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.galleryToType = _data["galleryToType"];
            this.galleryTitle = _data["galleryTitle"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.ngbStartDate = _data["ngbStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbStartDate"]) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.roleKey = _data["roleKey"];
            this.name = _data["name"];
            this.roleName = _data["roleName"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["lstGalleryDetail"])) {
                this.lstGalleryDetail = [] as any;
                for (let item of _data["lstGalleryDetail"])
                    this.lstGalleryDetail!.push(ParentAppGalleryDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["lstGalleryMediaDetail"])) {
                this.lstGalleryMediaDetail = [] as any;
                for (let item of _data["lstGalleryMediaDetail"])
                    this.lstGalleryMediaDetail!.push(MediaGalleryContentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParentAppGalleryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppGalleryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["galleryId"] = this.galleryId;
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["galleryToType"] = this.galleryToType;
        data["galleryTitle"] = this.galleryTitle;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ngbStartDate"] = this.ngbStartDate ? this.ngbStartDate.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["roleKey"] = this.roleKey;
        data["name"] = this.name;
        data["roleName"] = this.roleName;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        if (Array.isArray(this.lstGalleryDetail)) {
            data["lstGalleryDetail"] = [];
            for (let item of this.lstGalleryDetail)
                data["lstGalleryDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.lstGalleryMediaDetail)) {
            data["lstGalleryMediaDetail"] = [];
            for (let item of this.lstGalleryMediaDetail)
                data["lstGalleryMediaDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ParentAppGalleryDto {
        const json = this.toJSON();
        let result = new ParentAppGalleryDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppGalleryDto {
    galleryId: number;
    studentId: number;
    gradeId: number;
    divisionId: number;
    galleryToType: number | undefined;
    galleryTitle: string;
    description: string;
    startDate: moment.Moment | undefined;
    ngbStartDate: SchoolNgbDateModel | undefined;
    isPublished: boolean;
    userId: number;
    roleId: number;
    roleKey: string;
    name: string;
    roleName: string;
    createdDate: moment.Moment;
    lstGalleryDetail: ParentAppGalleryDetailDto[];
    lstGalleryMediaDetail: MediaGalleryContentDto[];
}

export class ParentAppGalleryDetailDto implements IParentAppGalleryDetailDto {
    galleryId!: number;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IParentAppGalleryDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.galleryId = _data["galleryId"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): ParentAppGalleryDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppGalleryDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["galleryId"] = this.galleryId;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): ParentAppGalleryDetailDto {
        const json = this.toJSON();
        let result = new ParentAppGalleryDetailDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppGalleryDetailDto {
    galleryId: number;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class MediaGalleryContentDto implements IMediaGalleryContentDto {
    galleryId!: number;
    contentUrl!: string;
    fileName!: string;
    fileType!: number;
    fullPath!: string;

    constructor(data?: IMediaGalleryContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.galleryId = _data["galleryId"];
            this.contentUrl = _data["contentUrl"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fullPath = _data["fullPath"];
        }
    }

    static fromJS(data: any): MediaGalleryContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaGalleryContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["galleryId"] = this.galleryId;
        data["contentUrl"] = this.contentUrl;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fullPath"] = this.fullPath;
        return data;
    }

    clone(): MediaGalleryContentDto {
        const json = this.toJSON();
        let result = new MediaGalleryContentDto();
        result.init(json);
        return result;
    }
}

export interface IMediaGalleryContentDto {
    galleryId: number;
    contentUrl: string;
    fileName: string;
    fileType: number;
    fullPath: string;
}

export class ParentAppGalleryRequestDto implements IParentAppGalleryRequestDto {
    academicYearId!: number;
    fromDate!: moment.Moment;
    tillDate!: moment.Moment;
    studentId!: number;

    constructor(data?: IParentAppGalleryRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.tillDate = _data["tillDate"] ? moment(_data["tillDate"].toString()) : <any>undefined;
            this.studentId = _data["studentId"];
        }
    }

    static fromJS(data: any): ParentAppGalleryRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAppGalleryRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["tillDate"] = this.tillDate ? this.tillDate.toISOString() : <any>undefined;
        data["studentId"] = this.studentId;
        return data;
    }

    clone(): ParentAppGalleryRequestDto {
        const json = this.toJSON();
        let result = new ParentAppGalleryRequestDto();
        result.init(json);
        return result;
    }
}

export interface IParentAppGalleryRequestDto {
    academicYearId: number;
    fromDate: moment.Moment;
    tillDate: moment.Moment;
    studentId: number;
}

export class FeeWavierTypeSelectDto implements IFeeWavierTypeSelectDto {
    feeWavierTypeId!: number;
    academicYearId!: number;
    feeWavierTypeName!: string;
    feeWavierDisplayName!: string;
    description!: string;
    categoryId!: number;
    numberOfInstallments!: number | undefined;
    discountInPercent!: number | undefined;
    latePerDayFeeInPercent!: number | undefined;
    isActive!: boolean;
    feeWavierTypesInstallmentsDetailsTypes!: FeeWavierTypesInstallmentsDetailsTypeDto[] | undefined;
    isInstallmentUsedInFeePayment!: boolean;

    constructor(data?: IFeeWavierTypeSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeWavierTypeId = _data["feeWavierTypeId"];
            this.academicYearId = _data["academicYearId"];
            this.feeWavierTypeName = _data["feeWavierTypeName"];
            this.feeWavierDisplayName = _data["feeWavierDisplayName"];
            this.description = _data["description"];
            this.categoryId = _data["categoryId"];
            this.numberOfInstallments = _data["numberOfInstallments"];
            this.discountInPercent = _data["discountInPercent"];
            this.latePerDayFeeInPercent = _data["latePerDayFeeInPercent"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["feeWavierTypesInstallmentsDetailsTypes"])) {
                this.feeWavierTypesInstallmentsDetailsTypes = [] as any;
                for (let item of _data["feeWavierTypesInstallmentsDetailsTypes"])
                    this.feeWavierTypesInstallmentsDetailsTypes!.push(FeeWavierTypesInstallmentsDetailsTypeDto.fromJS(item));
            }
            this.isInstallmentUsedInFeePayment = _data["isInstallmentUsedInFeePayment"];
        }
    }

    static fromJS(data: any): FeeWavierTypeSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeWavierTypeSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeWavierTypeId"] = this.feeWavierTypeId;
        data["academicYearId"] = this.academicYearId;
        data["feeWavierTypeName"] = this.feeWavierTypeName;
        data["feeWavierDisplayName"] = this.feeWavierDisplayName;
        data["description"] = this.description;
        data["categoryId"] = this.categoryId;
        data["numberOfInstallments"] = this.numberOfInstallments;
        data["discountInPercent"] = this.discountInPercent;
        data["latePerDayFeeInPercent"] = this.latePerDayFeeInPercent;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.feeWavierTypesInstallmentsDetailsTypes)) {
            data["feeWavierTypesInstallmentsDetailsTypes"] = [];
            for (let item of this.feeWavierTypesInstallmentsDetailsTypes)
                data["feeWavierTypesInstallmentsDetailsTypes"].push(item.toJSON());
        }
        data["isInstallmentUsedInFeePayment"] = this.isInstallmentUsedInFeePayment;
        return data;
    }

    clone(): FeeWavierTypeSelectDto {
        const json = this.toJSON();
        let result = new FeeWavierTypeSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFeeWavierTypeSelectDto {
    feeWavierTypeId: number;
    academicYearId: number;
    feeWavierTypeName: string;
    feeWavierDisplayName: string;
    description: string;
    categoryId: number;
    numberOfInstallments: number | undefined;
    discountInPercent: number | undefined;
    latePerDayFeeInPercent: number | undefined;
    isActive: boolean;
    feeWavierTypesInstallmentsDetailsTypes: FeeWavierTypesInstallmentsDetailsTypeDto[] | undefined;
    isInstallmentUsedInFeePayment: boolean;
}

export class FeeWavierTypesInstallmentsDetailsTypeDto implements IFeeWavierTypesInstallmentsDetailsTypeDto {
    feeWavierTypesInstallmentsDetailsTypeId!: number;
    lateFeeStartDate!: moment.Moment | undefined;
    ngbLateFeeStartDate!: SchoolNgbDateModel | undefined;
    discountEndDate!: moment.Moment | undefined;
    ngbDiscountEndDate!: SchoolNgbDateModel | undefined;

    constructor(data?: IFeeWavierTypesInstallmentsDetailsTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeWavierTypesInstallmentsDetailsTypeId = _data["feeWavierTypesInstallmentsDetailsTypeId"];
            this.lateFeeStartDate = _data["lateFeeStartDate"] ? moment(_data["lateFeeStartDate"].toString()) : <any>undefined;
            this.ngbLateFeeStartDate = _data["ngbLateFeeStartDate"] ? SchoolNgbDateModel.fromJS(_data["ngbLateFeeStartDate"]) : <any>undefined;
            this.discountEndDate = _data["discountEndDate"] ? moment(_data["discountEndDate"].toString()) : <any>undefined;
            this.ngbDiscountEndDate = _data["ngbDiscountEndDate"] ? SchoolNgbDateModel.fromJS(_data["ngbDiscountEndDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeeWavierTypesInstallmentsDetailsTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeWavierTypesInstallmentsDetailsTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeWavierTypesInstallmentsDetailsTypeId"] = this.feeWavierTypesInstallmentsDetailsTypeId;
        data["lateFeeStartDate"] = this.lateFeeStartDate ? this.lateFeeStartDate.toISOString() : <any>undefined;
        data["ngbLateFeeStartDate"] = this.ngbLateFeeStartDate ? this.ngbLateFeeStartDate.toJSON() : <any>undefined;
        data["discountEndDate"] = this.discountEndDate ? this.discountEndDate.toISOString() : <any>undefined;
        data["ngbDiscountEndDate"] = this.ngbDiscountEndDate ? this.ngbDiscountEndDate.toJSON() : <any>undefined;
        return data;
    }

    clone(): FeeWavierTypesInstallmentsDetailsTypeDto {
        const json = this.toJSON();
        let result = new FeeWavierTypesInstallmentsDetailsTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFeeWavierTypesInstallmentsDetailsTypeDto {
    feeWavierTypesInstallmentsDetailsTypeId: number;
    lateFeeStartDate: moment.Moment | undefined;
    ngbLateFeeStartDate: SchoolNgbDateModel | undefined;
    discountEndDate: moment.Moment | undefined;
    ngbDiscountEndDate: SchoolNgbDateModel | undefined;
}

export class CommonSuccessResponse implements ICommonSuccessResponse {
    id!: number;
    statusCode!: CommonSuccessResponseEnum;
    message!: string;

    constructor(data?: ICommonSuccessResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CommonSuccessResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CommonSuccessResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        return data;
    }

    clone(): CommonSuccessResponse {
        const json = this.toJSON();
        let result = new CommonSuccessResponse();
        result.init(json);
        return result;
    }
}

export interface ICommonSuccessResponse {
    id: number;
    statusCode: CommonSuccessResponseEnum;
    message: string;
}

export enum CommonSuccessResponseEnum {
    FEE_WAVIER_ALREADY_EXIST = 101,
    FEE_WAVIER_ALREADY_USED = 102,
    SUCCESS = 200,
}

export class FeeWavierTypeUpsertDto implements IFeeWavierTypeUpsertDto {
    feeWavierTypeId!: number;
    academicYearId!: number;
    feeWavierTypeName!: string;
    feeWavierDisplayName!: string;
    description!: string;
    categoryId!: number;
    numberOfInstallments!: number | undefined;
    discountInPercent!: number | undefined;
    latePerDayFeeInPercent!: number | undefined;
    isActive!: boolean;
    userId!: number;
    feeWavierTypesInstallmentsDetailsTypes!: FeeWavierTypesInstallmentsDetailsTypeDto[] | undefined;

    constructor(data?: IFeeWavierTypeUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeWavierTypeId = _data["feeWavierTypeId"];
            this.academicYearId = _data["academicYearId"];
            this.feeWavierTypeName = _data["feeWavierTypeName"];
            this.feeWavierDisplayName = _data["feeWavierDisplayName"];
            this.description = _data["description"];
            this.categoryId = _data["categoryId"];
            this.numberOfInstallments = _data["numberOfInstallments"];
            this.discountInPercent = _data["discountInPercent"];
            this.latePerDayFeeInPercent = _data["latePerDayFeeInPercent"];
            this.isActive = _data["isActive"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["feeWavierTypesInstallmentsDetailsTypes"])) {
                this.feeWavierTypesInstallmentsDetailsTypes = [] as any;
                for (let item of _data["feeWavierTypesInstallmentsDetailsTypes"])
                    this.feeWavierTypesInstallmentsDetailsTypes!.push(FeeWavierTypesInstallmentsDetailsTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeeWavierTypeUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeWavierTypeUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeWavierTypeId"] = this.feeWavierTypeId;
        data["academicYearId"] = this.academicYearId;
        data["feeWavierTypeName"] = this.feeWavierTypeName;
        data["feeWavierDisplayName"] = this.feeWavierDisplayName;
        data["description"] = this.description;
        data["categoryId"] = this.categoryId;
        data["numberOfInstallments"] = this.numberOfInstallments;
        data["discountInPercent"] = this.discountInPercent;
        data["latePerDayFeeInPercent"] = this.latePerDayFeeInPercent;
        data["isActive"] = this.isActive;
        data["userId"] = this.userId;
        if (Array.isArray(this.feeWavierTypesInstallmentsDetailsTypes)) {
            data["feeWavierTypesInstallmentsDetailsTypes"] = [];
            for (let item of this.feeWavierTypesInstallmentsDetailsTypes)
                data["feeWavierTypesInstallmentsDetailsTypes"].push(item.toJSON());
        }
        return data;
    }

    clone(): FeeWavierTypeUpsertDto {
        const json = this.toJSON();
        let result = new FeeWavierTypeUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IFeeWavierTypeUpsertDto {
    feeWavierTypeId: number;
    academicYearId: number;
    feeWavierTypeName: string;
    feeWavierDisplayName: string;
    description: string;
    categoryId: number;
    numberOfInstallments: number | undefined;
    discountInPercent: number | undefined;
    latePerDayFeeInPercent: number | undefined;
    isActive: boolean;
    userId: number;
    feeWavierTypesInstallmentsDetailsTypes: FeeWavierTypesInstallmentsDetailsTypeDto[] | undefined;
}

export class FeeWavierTypeDeleteResponseDto implements IFeeWavierTypeDeleteResponseDto {
    affectedRows!: number;

    constructor(data?: IFeeWavierTypeDeleteResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): FeeWavierTypeDeleteResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeWavierTypeDeleteResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): FeeWavierTypeDeleteResponseDto {
        const json = this.toJSON();
        let result = new FeeWavierTypeDeleteResponseDto();
        result.init(json);
        return result;
    }
}

export interface IFeeWavierTypeDeleteResponseDto {
    affectedRows: number;
}

export class FeePaymentSelectDto implements IFeePaymentSelectDto {
    paymentInstallmentDone!: number;
    skipDiscountCount!: number;
    fullName!: string;
    generalRegistrationNo!: string;
    isNewStudent!: boolean;
    isRTEStudent!: boolean;
    isConsationApplicable!: boolean;
    consationAmount!: number;
    previousAcademicYearPendingFeeAmount!: number;
    appAccessMobileNo!: string;
    academicYearId!: number;
    rollNumber!: string;
    gradeName!: string;
    divisionName!: string;
    classId!: number | undefined;
    feePaymentDiscountList!: FeePaymentDiscount[];
    feePaymentAdditionalDiscountList!: FeePaymentAdditionalDiscount[];
    feePaymentParticularsList!: FeePaymentParticulars[];
    usedInstallmentList!: number[];

    constructor(data?: IFeePaymentSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentInstallmentDone = _data["paymentInstallmentDone"];
            this.skipDiscountCount = _data["skipDiscountCount"];
            this.fullName = _data["fullName"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.isNewStudent = _data["isNewStudent"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isConsationApplicable = _data["isConsationApplicable"];
            this.consationAmount = _data["consationAmount"];
            this.previousAcademicYearPendingFeeAmount = _data["previousAcademicYearPendingFeeAmount"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.academicYearId = _data["academicYearId"];
            this.rollNumber = _data["rollNumber"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.classId = _data["classId"];
            if (Array.isArray(_data["feePaymentDiscountList"])) {
                this.feePaymentDiscountList = [] as any;
                for (let item of _data["feePaymentDiscountList"])
                    this.feePaymentDiscountList!.push(FeePaymentDiscount.fromJS(item));
            }
            if (Array.isArray(_data["feePaymentAdditionalDiscountList"])) {
                this.feePaymentAdditionalDiscountList = [] as any;
                for (let item of _data["feePaymentAdditionalDiscountList"])
                    this.feePaymentAdditionalDiscountList!.push(FeePaymentAdditionalDiscount.fromJS(item));
            }
            if (Array.isArray(_data["feePaymentParticularsList"])) {
                this.feePaymentParticularsList = [] as any;
                for (let item of _data["feePaymentParticularsList"])
                    this.feePaymentParticularsList!.push(FeePaymentParticulars.fromJS(item));
            }
            if (Array.isArray(_data["usedInstallmentList"])) {
                this.usedInstallmentList = [] as any;
                for (let item of _data["usedInstallmentList"])
                    this.usedInstallmentList!.push(item);
            }
        }
    }

    static fromJS(data: any): FeePaymentSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentInstallmentDone"] = this.paymentInstallmentDone;
        data["skipDiscountCount"] = this.skipDiscountCount;
        data["fullName"] = this.fullName;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["isNewStudent"] = this.isNewStudent;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isConsationApplicable"] = this.isConsationApplicable;
        data["consationAmount"] = this.consationAmount;
        data["previousAcademicYearPendingFeeAmount"] = this.previousAcademicYearPendingFeeAmount;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["academicYearId"] = this.academicYearId;
        data["rollNumber"] = this.rollNumber;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["classId"] = this.classId;
        if (Array.isArray(this.feePaymentDiscountList)) {
            data["feePaymentDiscountList"] = [];
            for (let item of this.feePaymentDiscountList)
                data["feePaymentDiscountList"].push(item.toJSON());
        }
        if (Array.isArray(this.feePaymentAdditionalDiscountList)) {
            data["feePaymentAdditionalDiscountList"] = [];
            for (let item of this.feePaymentAdditionalDiscountList)
                data["feePaymentAdditionalDiscountList"].push(item.toJSON());
        }
        if (Array.isArray(this.feePaymentParticularsList)) {
            data["feePaymentParticularsList"] = [];
            for (let item of this.feePaymentParticularsList)
                data["feePaymentParticularsList"].push(item.toJSON());
        }
        if (Array.isArray(this.usedInstallmentList)) {
            data["usedInstallmentList"] = [];
            for (let item of this.usedInstallmentList)
                data["usedInstallmentList"].push(item);
        }
        return data;
    }

    clone(): FeePaymentSelectDto {
        const json = this.toJSON();
        let result = new FeePaymentSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentSelectDto {
    paymentInstallmentDone: number;
    skipDiscountCount: number;
    fullName: string;
    generalRegistrationNo: string;
    isNewStudent: boolean;
    isRTEStudent: boolean;
    isConsationApplicable: boolean;
    consationAmount: number;
    previousAcademicYearPendingFeeAmount: number;
    appAccessMobileNo: string;
    academicYearId: number;
    rollNumber: string;
    gradeName: string;
    divisionName: string;
    classId: number | undefined;
    feePaymentDiscountList: FeePaymentDiscount[];
    feePaymentAdditionalDiscountList: FeePaymentAdditionalDiscount[];
    feePaymentParticularsList: FeePaymentParticulars[];
    usedInstallmentList: number[];
}

export class FeePaymentDiscount implements IFeePaymentDiscount {
    academicYearId!: number;
    feeParticularWavierMappingId!: number;

    constructor(data?: IFeePaymentDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.feeParticularWavierMappingId = _data["feeParticularWavierMappingId"];
        }
    }

    static fromJS(data: any): FeePaymentDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["feeParticularWavierMappingId"] = this.feeParticularWavierMappingId;
        return data;
    }

    clone(): FeePaymentDiscount {
        const json = this.toJSON();
        let result = new FeePaymentDiscount();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentDiscount {
    academicYearId: number;
    feeParticularWavierMappingId: number;
}

export class FeePaymentAdditionalDiscount implements IFeePaymentAdditionalDiscount {
    feeAdditionalDiscountId!: number;
    academicYearId!: number;
    additionalDiscountedAmount!: number;
    installmentPaybleFee!: number;
    paymentInstallmentNumber!: number | undefined;
    additionalDiscountedRemark!: string;
    appliedDate!: string | undefined;
    totalFee!: number;

    constructor(data?: IFeePaymentAdditionalDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeAdditionalDiscountId = _data["feeAdditionalDiscountId"];
            this.academicYearId = _data["academicYearId"];
            this.additionalDiscountedAmount = _data["additionalDiscountedAmount"];
            this.installmentPaybleFee = _data["installmentPaybleFee"];
            this.paymentInstallmentNumber = _data["paymentInstallmentNumber"];
            this.additionalDiscountedRemark = _data["additionalDiscountedRemark"];
            this.appliedDate = _data["appliedDate"];
            this.totalFee = _data["totalFee"];
        }
    }

    static fromJS(data: any): FeePaymentAdditionalDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentAdditionalDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeAdditionalDiscountId"] = this.feeAdditionalDiscountId;
        data["academicYearId"] = this.academicYearId;
        data["additionalDiscountedAmount"] = this.additionalDiscountedAmount;
        data["installmentPaybleFee"] = this.installmentPaybleFee;
        data["paymentInstallmentNumber"] = this.paymentInstallmentNumber;
        data["additionalDiscountedRemark"] = this.additionalDiscountedRemark;
        data["appliedDate"] = this.appliedDate;
        data["totalFee"] = this.totalFee;
        return data;
    }

    clone(): FeePaymentAdditionalDiscount {
        const json = this.toJSON();
        let result = new FeePaymentAdditionalDiscount();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentAdditionalDiscount {
    feeAdditionalDiscountId: number;
    academicYearId: number;
    additionalDiscountedAmount: number;
    installmentPaybleFee: number;
    paymentInstallmentNumber: number | undefined;
    additionalDiscountedRemark: string;
    appliedDate: string | undefined;
    totalFee: number;
}

export class FeePaymentParticulars implements IFeePaymentParticulars {
    additionalDiscInPercentage!: number;
    feeParticularId!: number;
    isDiscountApplicable!: boolean;
    particularName!: string;
    totalFee!: number;
    feeAfterDiscount!: number;
    paybleFee!: number;
    dueAmount!: number;
    alreadyPaid!: number;
    additionalDiscAmount!: number;
    showError!: boolean;

    constructor(data?: IFeePaymentParticulars) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additionalDiscInPercentage = _data["additionalDiscInPercentage"];
            this.feeParticularId = _data["feeParticularId"];
            this.isDiscountApplicable = _data["isDiscountApplicable"];
            this.particularName = _data["particularName"];
            this.totalFee = _data["totalFee"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.paybleFee = _data["paybleFee"];
            this.dueAmount = _data["dueAmount"];
            this.alreadyPaid = _data["alreadyPaid"];
            this.additionalDiscAmount = _data["additionalDiscAmount"];
            this.showError = _data["showError"];
        }
    }

    static fromJS(data: any): FeePaymentParticulars {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentParticulars();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalDiscInPercentage"] = this.additionalDiscInPercentage;
        data["feeParticularId"] = this.feeParticularId;
        data["isDiscountApplicable"] = this.isDiscountApplicable;
        data["particularName"] = this.particularName;
        data["totalFee"] = this.totalFee;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["paybleFee"] = this.paybleFee;
        data["dueAmount"] = this.dueAmount;
        data["alreadyPaid"] = this.alreadyPaid;
        data["additionalDiscAmount"] = this.additionalDiscAmount;
        data["showError"] = this.showError;
        return data;
    }

    clone(): FeePaymentParticulars {
        const json = this.toJSON();
        let result = new FeePaymentParticulars();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentParticulars {
    additionalDiscInPercentage: number;
    feeParticularId: number;
    isDiscountApplicable: boolean;
    particularName: string;
    totalFee: number;
    feeAfterDiscount: number;
    paybleFee: number;
    dueAmount: number;
    alreadyPaid: number;
    additionalDiscAmount: number;
    showError: boolean;
}

export class FeePaymentUpsertDto implements IFeePaymentUpsertDto {
    academicYearId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    studentId!: number | undefined;
    onlineTransactionId!: string | undefined;
    onlineTransactionDateTime!: moment.Moment | undefined;
    ngbOnlineTransactionDateTime!: SchoolNgbDateModel | undefined;
    onlinePaymentRequest!: string | undefined;
    onlinePaymentResponse!: string | undefined;
    paidToBank!: string | undefined;
    paidAmount!: number | undefined;
    paymentTypeId!: number | undefined;
    chequeNumber!: string;
    chequeDate!: moment.Moment | undefined;
    ngbChequeDate!: SchoolNgbDateModel | undefined;
    chequeBank!: string;
    chequeAmount!: number | undefined;
    isChequeClear!: boolean | undefined;
    skipDiscount!: boolean | undefined;
    feeWavierTypesInstallmentsDetailsId!: number | undefined;
    remark!: string;
    additionalDiscountedAmount!: number | undefined;
    installmentPaybleFee!: number | undefined;
    additionalDiscountedRemark!: string | undefined;
    userId!: number | undefined;
    feePaymentAppliedWavierMappingTypeUpsertDtoList!: FeePaymentAppliedWavierMappingTypeUpsertDto[] | undefined;
    feePaymentDetailTypeUpsertDtoList!: FeePaymentDetailTypeUpsertDto[] | undefined;

    constructor(data?: IFeePaymentUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.studentId = _data["studentId"];
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"] ? moment(_data["onlineTransactionDateTime"].toString()) : <any>undefined;
            this.ngbOnlineTransactionDateTime = _data["ngbOnlineTransactionDateTime"] ? SchoolNgbDateModel.fromJS(_data["ngbOnlineTransactionDateTime"]) : <any>undefined;
            this.onlinePaymentRequest = _data["onlinePaymentRequest"];
            this.onlinePaymentResponse = _data["onlinePaymentResponse"];
            this.paidToBank = _data["paidToBank"];
            this.paidAmount = _data["paidAmount"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.ngbChequeDate = _data["ngbChequeDate"] ? SchoolNgbDateModel.fromJS(_data["ngbChequeDate"]) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.chequeAmount = _data["chequeAmount"];
            this.isChequeClear = _data["isChequeClear"];
            this.skipDiscount = _data["skipDiscount"];
            this.feeWavierTypesInstallmentsDetailsId = _data["feeWavierTypesInstallmentsDetailsId"];
            this.remark = _data["remark"];
            this.additionalDiscountedAmount = _data["additionalDiscountedAmount"];
            this.installmentPaybleFee = _data["installmentPaybleFee"];
            this.additionalDiscountedRemark = _data["additionalDiscountedRemark"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["feePaymentAppliedWavierMappingTypeUpsertDtoList"])) {
                this.feePaymentAppliedWavierMappingTypeUpsertDtoList = [] as any;
                for (let item of _data["feePaymentAppliedWavierMappingTypeUpsertDtoList"])
                    this.feePaymentAppliedWavierMappingTypeUpsertDtoList!.push(FeePaymentAppliedWavierMappingTypeUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["feePaymentDetailTypeUpsertDtoList"])) {
                this.feePaymentDetailTypeUpsertDtoList = [] as any;
                for (let item of _data["feePaymentDetailTypeUpsertDtoList"])
                    this.feePaymentDetailTypeUpsertDtoList!.push(FeePaymentDetailTypeUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeePaymentUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["studentId"] = this.studentId;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime ? this.onlineTransactionDateTime.toISOString() : <any>undefined;
        data["ngbOnlineTransactionDateTime"] = this.ngbOnlineTransactionDateTime ? this.ngbOnlineTransactionDateTime.toJSON() : <any>undefined;
        data["onlinePaymentRequest"] = this.onlinePaymentRequest;
        data["onlinePaymentResponse"] = this.onlinePaymentResponse;
        data["paidToBank"] = this.paidToBank;
        data["paidAmount"] = this.paidAmount;
        data["paymentTypeId"] = this.paymentTypeId;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["ngbChequeDate"] = this.ngbChequeDate ? this.ngbChequeDate.toJSON() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["chequeAmount"] = this.chequeAmount;
        data["isChequeClear"] = this.isChequeClear;
        data["skipDiscount"] = this.skipDiscount;
        data["feeWavierTypesInstallmentsDetailsId"] = this.feeWavierTypesInstallmentsDetailsId;
        data["remark"] = this.remark;
        data["additionalDiscountedAmount"] = this.additionalDiscountedAmount;
        data["installmentPaybleFee"] = this.installmentPaybleFee;
        data["additionalDiscountedRemark"] = this.additionalDiscountedRemark;
        data["userId"] = this.userId;
        if (Array.isArray(this.feePaymentAppliedWavierMappingTypeUpsertDtoList)) {
            data["feePaymentAppliedWavierMappingTypeUpsertDtoList"] = [];
            for (let item of this.feePaymentAppliedWavierMappingTypeUpsertDtoList)
                data["feePaymentAppliedWavierMappingTypeUpsertDtoList"].push(item.toJSON());
        }
        if (Array.isArray(this.feePaymentDetailTypeUpsertDtoList)) {
            data["feePaymentDetailTypeUpsertDtoList"] = [];
            for (let item of this.feePaymentDetailTypeUpsertDtoList)
                data["feePaymentDetailTypeUpsertDtoList"].push(item.toJSON());
        }
        return data;
    }

    clone(): FeePaymentUpsertDto {
        const json = this.toJSON();
        let result = new FeePaymentUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentUpsertDto {
    academicYearId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    studentId: number | undefined;
    onlineTransactionId: string | undefined;
    onlineTransactionDateTime: moment.Moment | undefined;
    ngbOnlineTransactionDateTime: SchoolNgbDateModel | undefined;
    onlinePaymentRequest: string | undefined;
    onlinePaymentResponse: string | undefined;
    paidToBank: string | undefined;
    paidAmount: number | undefined;
    paymentTypeId: number | undefined;
    chequeNumber: string;
    chequeDate: moment.Moment | undefined;
    ngbChequeDate: SchoolNgbDateModel | undefined;
    chequeBank: string;
    chequeAmount: number | undefined;
    isChequeClear: boolean | undefined;
    skipDiscount: boolean | undefined;
    feeWavierTypesInstallmentsDetailsId: number | undefined;
    remark: string;
    additionalDiscountedAmount: number | undefined;
    installmentPaybleFee: number | undefined;
    additionalDiscountedRemark: string | undefined;
    userId: number | undefined;
    feePaymentAppliedWavierMappingTypeUpsertDtoList: FeePaymentAppliedWavierMappingTypeUpsertDto[] | undefined;
    feePaymentDetailTypeUpsertDtoList: FeePaymentDetailTypeUpsertDto[] | undefined;
}

export class FeePaymentAppliedWavierMappingTypeUpsertDto implements IFeePaymentAppliedWavierMappingTypeUpsertDto {
    feeParticularWavierMappingId!: number;
    discountedPercent!: number;
    discountedAmount!: number;

    constructor(data?: IFeePaymentAppliedWavierMappingTypeUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularWavierMappingId = _data["feeParticularWavierMappingId"];
            this.discountedPercent = _data["discountedPercent"];
            this.discountedAmount = _data["discountedAmount"];
        }
    }

    static fromJS(data: any): FeePaymentAppliedWavierMappingTypeUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentAppliedWavierMappingTypeUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularWavierMappingId"] = this.feeParticularWavierMappingId;
        data["discountedPercent"] = this.discountedPercent;
        data["discountedAmount"] = this.discountedAmount;
        return data;
    }

    clone(): FeePaymentAppliedWavierMappingTypeUpsertDto {
        const json = this.toJSON();
        let result = new FeePaymentAppliedWavierMappingTypeUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentAppliedWavierMappingTypeUpsertDto {
    feeParticularWavierMappingId: number;
    discountedPercent: number;
    discountedAmount: number;
}

export class FeePaymentDetailTypeUpsertDto implements IFeePaymentDetailTypeUpsertDto {
    feeParticularId!: number;
    otherFeeReason!: string;
    paidAmount!: number;
    feeAfterDiscount!: number;
    additionalDiscInPercentage!: number;
    additionalDiscAmount!: number;

    constructor(data?: IFeePaymentDetailTypeUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularId = _data["feeParticularId"];
            this.otherFeeReason = _data["otherFeeReason"];
            this.paidAmount = _data["paidAmount"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.additionalDiscInPercentage = _data["additionalDiscInPercentage"];
            this.additionalDiscAmount = _data["additionalDiscAmount"];
        }
    }

    static fromJS(data: any): FeePaymentDetailTypeUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentDetailTypeUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularId"] = this.feeParticularId;
        data["otherFeeReason"] = this.otherFeeReason;
        data["paidAmount"] = this.paidAmount;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["additionalDiscInPercentage"] = this.additionalDiscInPercentage;
        data["additionalDiscAmount"] = this.additionalDiscAmount;
        return data;
    }

    clone(): FeePaymentDetailTypeUpsertDto {
        const json = this.toJSON();
        let result = new FeePaymentDetailTypeUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentDetailTypeUpsertDto {
    feeParticularId: number;
    otherFeeReason: string;
    paidAmount: number;
    feeAfterDiscount: number;
    additionalDiscInPercentage: number;
    additionalDiscAmount: number;
}

export class PaymentFeePageMasterActivityList implements IPaymentFeePageMasterActivityList {
    availFeeWavierDiscList!: AvailFeeWavierDiscDto[];
    availFeeWavierDiscByInstallments!: AvailFeeWavierDiscByInstallmentDto[];
    totalFee!: number;
    installmentDetails!: FeeWaiverDto[] | undefined;

    constructor(data?: IPaymentFeePageMasterActivityList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["availFeeWavierDiscList"])) {
                this.availFeeWavierDiscList = [] as any;
                for (let item of _data["availFeeWavierDiscList"])
                    this.availFeeWavierDiscList!.push(AvailFeeWavierDiscDto.fromJS(item));
            }
            if (Array.isArray(_data["availFeeWavierDiscByInstallments"])) {
                this.availFeeWavierDiscByInstallments = [] as any;
                for (let item of _data["availFeeWavierDiscByInstallments"])
                    this.availFeeWavierDiscByInstallments!.push(AvailFeeWavierDiscByInstallmentDto.fromJS(item));
            }
            this.totalFee = _data["totalFee"];
            if (Array.isArray(_data["installmentDetails"])) {
                this.installmentDetails = [] as any;
                for (let item of _data["installmentDetails"])
                    this.installmentDetails!.push(FeeWaiverDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentFeePageMasterActivityList {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentFeePageMasterActivityList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.availFeeWavierDiscList)) {
            data["availFeeWavierDiscList"] = [];
            for (let item of this.availFeeWavierDiscList)
                data["availFeeWavierDiscList"].push(item.toJSON());
        }
        if (Array.isArray(this.availFeeWavierDiscByInstallments)) {
            data["availFeeWavierDiscByInstallments"] = [];
            for (let item of this.availFeeWavierDiscByInstallments)
                data["availFeeWavierDiscByInstallments"].push(item.toJSON());
        }
        data["totalFee"] = this.totalFee;
        if (Array.isArray(this.installmentDetails)) {
            data["installmentDetails"] = [];
            for (let item of this.installmentDetails)
                data["installmentDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaymentFeePageMasterActivityList {
        const json = this.toJSON();
        let result = new PaymentFeePageMasterActivityList();
        result.init(json);
        return result;
    }
}

export interface IPaymentFeePageMasterActivityList {
    availFeeWavierDiscList: AvailFeeWavierDiscDto[];
    availFeeWavierDiscByInstallments: AvailFeeWavierDiscByInstallmentDto[];
    totalFee: number;
    installmentDetails: FeeWaiverDto[] | undefined;
}

export class AvailFeeWavierDiscDto implements IAvailFeeWavierDiscDto {
    totalFee!: number;
    feeParticularWavierMappingId!: number;
    appliedFeeParticularWavierMappingId!: number;
    gradeId!: number;
    divisionId!: number;
    feeWavierTypeId!: number;
    sortBy!: number;
    feeWavierDisplayName!: string;
    feeWavierTypeName!: string;
    discountInPercent!: number;
    latePerDayFeeInPercent!: number | undefined;
    numberOfInstallments!: number;
    applicableFee!: number;
    lateFeeStartDate!: moment.Moment | undefined;
    discountEndDate!: moment.Moment | undefined;

    constructor(data?: IAvailFeeWavierDiscDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalFee = _data["totalFee"];
            this.feeParticularWavierMappingId = _data["feeParticularWavierMappingId"];
            this.appliedFeeParticularWavierMappingId = _data["appliedFeeParticularWavierMappingId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.feeWavierTypeId = _data["feeWavierTypeId"];
            this.sortBy = _data["sortBy"];
            this.feeWavierDisplayName = _data["feeWavierDisplayName"];
            this.feeWavierTypeName = _data["feeWavierTypeName"];
            this.discountInPercent = _data["discountInPercent"];
            this.latePerDayFeeInPercent = _data["latePerDayFeeInPercent"];
            this.numberOfInstallments = _data["numberOfInstallments"];
            this.applicableFee = _data["applicableFee"];
            this.lateFeeStartDate = _data["lateFeeStartDate"] ? moment(_data["lateFeeStartDate"].toString()) : <any>undefined;
            this.discountEndDate = _data["discountEndDate"] ? moment(_data["discountEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AvailFeeWavierDiscDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvailFeeWavierDiscDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalFee"] = this.totalFee;
        data["feeParticularWavierMappingId"] = this.feeParticularWavierMappingId;
        data["appliedFeeParticularWavierMappingId"] = this.appliedFeeParticularWavierMappingId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["feeWavierTypeId"] = this.feeWavierTypeId;
        data["sortBy"] = this.sortBy;
        data["feeWavierDisplayName"] = this.feeWavierDisplayName;
        data["feeWavierTypeName"] = this.feeWavierTypeName;
        data["discountInPercent"] = this.discountInPercent;
        data["latePerDayFeeInPercent"] = this.latePerDayFeeInPercent;
        data["numberOfInstallments"] = this.numberOfInstallments;
        data["applicableFee"] = this.applicableFee;
        data["lateFeeStartDate"] = this.lateFeeStartDate ? this.lateFeeStartDate.toISOString() : <any>undefined;
        data["discountEndDate"] = this.discountEndDate ? this.discountEndDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): AvailFeeWavierDiscDto {
        const json = this.toJSON();
        let result = new AvailFeeWavierDiscDto();
        result.init(json);
        return result;
    }
}

export interface IAvailFeeWavierDiscDto {
    totalFee: number;
    feeParticularWavierMappingId: number;
    appliedFeeParticularWavierMappingId: number;
    gradeId: number;
    divisionId: number;
    feeWavierTypeId: number;
    sortBy: number;
    feeWavierDisplayName: string;
    feeWavierTypeName: string;
    discountInPercent: number;
    latePerDayFeeInPercent: number | undefined;
    numberOfInstallments: number;
    applicableFee: number;
    lateFeeStartDate: moment.Moment | undefined;
    discountEndDate: moment.Moment | undefined;
}

export class AvailFeeWavierDiscByInstallmentDto implements IAvailFeeWavierDiscByInstallmentDto {
    installmentNumber!: number;
    discountEndDate!: moment.Moment | undefined;
    feeWavierTypeId!: number;
    feeWavierTypesInstallmentsDetailsId!: number | undefined;
    feeWavierDisplayName!: string | undefined;

    constructor(data?: IAvailFeeWavierDiscByInstallmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.installmentNumber = _data["installmentNumber"];
            this.discountEndDate = _data["discountEndDate"] ? moment(_data["discountEndDate"].toString()) : <any>undefined;
            this.feeWavierTypeId = _data["feeWavierTypeId"];
            this.feeWavierTypesInstallmentsDetailsId = _data["feeWavierTypesInstallmentsDetailsId"];
            this.feeWavierDisplayName = _data["feeWavierDisplayName"];
        }
    }

    static fromJS(data: any): AvailFeeWavierDiscByInstallmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvailFeeWavierDiscByInstallmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installmentNumber"] = this.installmentNumber;
        data["discountEndDate"] = this.discountEndDate ? this.discountEndDate.toISOString() : <any>undefined;
        data["feeWavierTypeId"] = this.feeWavierTypeId;
        data["feeWavierTypesInstallmentsDetailsId"] = this.feeWavierTypesInstallmentsDetailsId;
        data["feeWavierDisplayName"] = this.feeWavierDisplayName;
        return data;
    }

    clone(): AvailFeeWavierDiscByInstallmentDto {
        const json = this.toJSON();
        let result = new AvailFeeWavierDiscByInstallmentDto();
        result.init(json);
        return result;
    }
}

export interface IAvailFeeWavierDiscByInstallmentDto {
    installmentNumber: number;
    discountEndDate: moment.Moment | undefined;
    feeWavierTypeId: number;
    feeWavierTypesInstallmentsDetailsId: number | undefined;
    feeWavierDisplayName: string | undefined;
}

export class FeeWaiverDto implements IFeeWaiverDto {
    feeParticularWavierMappingId!: number;
    feeWavierTypeId!: number | undefined;
    feeWavierTypeName!: string;
    feeWavierDisplayName!: string;
    discountInPercent!: number | undefined;
    latePerDayFeeInPercent!: number | undefined;
    isAlreadyAdded!: boolean;
    isFeePaymentAlreadyDone!: boolean | undefined;
    lateFeeStartDate!: moment.Moment | undefined;
    discountEndDate!: moment.Moment | undefined;
    numberOfInstallments!: number | undefined;
    installmentNumber!: number | undefined;

    constructor(data?: IFeeWaiverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularWavierMappingId = _data["feeParticularWavierMappingId"];
            this.feeWavierTypeId = _data["feeWavierTypeId"];
            this.feeWavierTypeName = _data["feeWavierTypeName"];
            this.feeWavierDisplayName = _data["feeWavierDisplayName"];
            this.discountInPercent = _data["discountInPercent"];
            this.latePerDayFeeInPercent = _data["latePerDayFeeInPercent"];
            this.isAlreadyAdded = _data["isAlreadyAdded"];
            this.isFeePaymentAlreadyDone = _data["isFeePaymentAlreadyDone"];
            this.lateFeeStartDate = _data["lateFeeStartDate"] ? moment(_data["lateFeeStartDate"].toString()) : <any>undefined;
            this.discountEndDate = _data["discountEndDate"] ? moment(_data["discountEndDate"].toString()) : <any>undefined;
            this.numberOfInstallments = _data["numberOfInstallments"];
            this.installmentNumber = _data["installmentNumber"];
        }
    }

    static fromJS(data: any): FeeWaiverDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeWaiverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularWavierMappingId"] = this.feeParticularWavierMappingId;
        data["feeWavierTypeId"] = this.feeWavierTypeId;
        data["feeWavierTypeName"] = this.feeWavierTypeName;
        data["feeWavierDisplayName"] = this.feeWavierDisplayName;
        data["discountInPercent"] = this.discountInPercent;
        data["latePerDayFeeInPercent"] = this.latePerDayFeeInPercent;
        data["isAlreadyAdded"] = this.isAlreadyAdded;
        data["isFeePaymentAlreadyDone"] = this.isFeePaymentAlreadyDone;
        data["lateFeeStartDate"] = this.lateFeeStartDate ? this.lateFeeStartDate.toISOString() : <any>undefined;
        data["discountEndDate"] = this.discountEndDate ? this.discountEndDate.toISOString() : <any>undefined;
        data["numberOfInstallments"] = this.numberOfInstallments;
        data["installmentNumber"] = this.installmentNumber;
        return data;
    }

    clone(): FeeWaiverDto {
        const json = this.toJSON();
        let result = new FeeWaiverDto();
        result.init(json);
        return result;
    }
}

export interface IFeeWaiverDto {
    feeParticularWavierMappingId: number;
    feeWavierTypeId: number | undefined;
    feeWavierTypeName: string;
    feeWavierDisplayName: string;
    discountInPercent: number | undefined;
    latePerDayFeeInPercent: number | undefined;
    isAlreadyAdded: boolean;
    isFeePaymentAlreadyDone: boolean | undefined;
    lateFeeStartDate: moment.Moment | undefined;
    discountEndDate: moment.Moment | undefined;
    numberOfInstallments: number | undefined;
    installmentNumber: number | undefined;
}

export class FeePaymentHistorySelectDto implements IFeePaymentHistorySelectDto {
    schoolName!: string;
    schoolAddress!: string;
    academicYearId!: number;
    studentName!: string;
    gradeName!: string;
    divisionName!: string;
    rollNumber!: string;
    generalRegistrationNo!: string | undefined;
    paymentTypeName!: string;
    paymentDate!: moment.Moment | undefined;
    chequeDate!: moment.Moment | undefined;
    chequeBank!: string;
    transactionId!: string;
    invoiceNumber!: string;
    feeParticularsSelectList!: FeeParticularsSelectDto[];

    constructor(data?: IFeePaymentHistorySelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.schoolAddress = _data["schoolAddress"];
            this.academicYearId = _data["academicYearId"];
            this.studentName = _data["studentName"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.transactionId = _data["transactionId"];
            this.invoiceNumber = _data["invoiceNumber"];
            if (Array.isArray(_data["feeParticularsSelectList"])) {
                this.feeParticularsSelectList = [] as any;
                for (let item of _data["feeParticularsSelectList"])
                    this.feeParticularsSelectList!.push(FeeParticularsSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeePaymentHistorySelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeePaymentHistorySelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["schoolAddress"] = this.schoolAddress;
        data["academicYearId"] = this.academicYearId;
        data["studentName"] = this.studentName;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["paymentTypeName"] = this.paymentTypeName;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["transactionId"] = this.transactionId;
        data["invoiceNumber"] = this.invoiceNumber;
        if (Array.isArray(this.feeParticularsSelectList)) {
            data["feeParticularsSelectList"] = [];
            for (let item of this.feeParticularsSelectList)
                data["feeParticularsSelectList"].push(item.toJSON());
        }
        return data;
    }

    clone(): FeePaymentHistorySelectDto {
        const json = this.toJSON();
        let result = new FeePaymentHistorySelectDto();
        result.init(json);
        return result;
    }
}

export interface IFeePaymentHistorySelectDto {
    schoolName: string;
    schoolAddress: string;
    academicYearId: number;
    studentName: string;
    gradeName: string;
    divisionName: string;
    rollNumber: string;
    generalRegistrationNo: string | undefined;
    paymentTypeName: string;
    paymentDate: moment.Moment | undefined;
    chequeDate: moment.Moment | undefined;
    chequeBank: string;
    transactionId: string;
    invoiceNumber: string;
    feeParticularsSelectList: FeeParticularsSelectDto[];
}

export class FeeParticularsSelectDto implements IFeeParticularsSelectDto {
    feeParticularId!: number;
    particularName!: string;
    totalFee!: number;
    feeAfterDiscount!: number;
    paidAmount!: number;
    dueAmount!: number;
    alreadyPaid!: number;

    constructor(data?: IFeeParticularsSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularId = _data["feeParticularId"];
            this.particularName = _data["particularName"];
            this.totalFee = _data["totalFee"];
            this.feeAfterDiscount = _data["feeAfterDiscount"];
            this.paidAmount = _data["paidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.alreadyPaid = _data["alreadyPaid"];
        }
    }

    static fromJS(data: any): FeeParticularsSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeParticularsSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularId"] = this.feeParticularId;
        data["particularName"] = this.particularName;
        data["totalFee"] = this.totalFee;
        data["feeAfterDiscount"] = this.feeAfterDiscount;
        data["paidAmount"] = this.paidAmount;
        data["dueAmount"] = this.dueAmount;
        data["alreadyPaid"] = this.alreadyPaid;
        return data;
    }

    clone(): FeeParticularsSelectDto {
        const json = this.toJSON();
        let result = new FeeParticularsSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFeeParticularsSelectDto {
    feeParticularId: number;
    particularName: string;
    totalFee: number;
    feeAfterDiscount: number;
    paidAmount: number;
    dueAmount: number;
    alreadyPaid: number;
}

export class DaywisePaymentReportDTO implements IDaywisePaymentReportDTO {
    cashDaywisePaymentReport!: CashDaywisePaymentReport;
    chequeDaywisePaymentReport!: ChequeDaywisePaymentReport;
    ddDaywisePaymentReport!: DDDaywisePaymentReport;
    upiPaymentDaywisePaymentReport!: UpiPaymentDaywisePaymentReport;
    netBankingDaywisePaymentReport!: NetBankingDaywisePaymentReport;
    cardDaywisePaymentReport!: CardDaywisePaymentReport;

    constructor(data?: IDaywisePaymentReportDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashDaywisePaymentReport = _data["cashDaywisePaymentReport"] ? CashDaywisePaymentReport.fromJS(_data["cashDaywisePaymentReport"]) : <any>undefined;
            this.chequeDaywisePaymentReport = _data["chequeDaywisePaymentReport"] ? ChequeDaywisePaymentReport.fromJS(_data["chequeDaywisePaymentReport"]) : <any>undefined;
            this.ddDaywisePaymentReport = _data["ddDaywisePaymentReport"] ? DDDaywisePaymentReport.fromJS(_data["ddDaywisePaymentReport"]) : <any>undefined;
            this.upiPaymentDaywisePaymentReport = _data["upiPaymentDaywisePaymentReport"] ? UpiPaymentDaywisePaymentReport.fromJS(_data["upiPaymentDaywisePaymentReport"]) : <any>undefined;
            this.netBankingDaywisePaymentReport = _data["netBankingDaywisePaymentReport"] ? NetBankingDaywisePaymentReport.fromJS(_data["netBankingDaywisePaymentReport"]) : <any>undefined;
            this.cardDaywisePaymentReport = _data["cardDaywisePaymentReport"] ? CardDaywisePaymentReport.fromJS(_data["cardDaywisePaymentReport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DaywisePaymentReportDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DaywisePaymentReportDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashDaywisePaymentReport"] = this.cashDaywisePaymentReport ? this.cashDaywisePaymentReport.toJSON() : <any>undefined;
        data["chequeDaywisePaymentReport"] = this.chequeDaywisePaymentReport ? this.chequeDaywisePaymentReport.toJSON() : <any>undefined;
        data["ddDaywisePaymentReport"] = this.ddDaywisePaymentReport ? this.ddDaywisePaymentReport.toJSON() : <any>undefined;
        data["upiPaymentDaywisePaymentReport"] = this.upiPaymentDaywisePaymentReport ? this.upiPaymentDaywisePaymentReport.toJSON() : <any>undefined;
        data["netBankingDaywisePaymentReport"] = this.netBankingDaywisePaymentReport ? this.netBankingDaywisePaymentReport.toJSON() : <any>undefined;
        data["cardDaywisePaymentReport"] = this.cardDaywisePaymentReport ? this.cardDaywisePaymentReport.toJSON() : <any>undefined;
        return data;
    }

    clone(): DaywisePaymentReportDTO {
        const json = this.toJSON();
        let result = new DaywisePaymentReportDTO();
        result.init(json);
        return result;
    }
}

export interface IDaywisePaymentReportDTO {
    cashDaywisePaymentReport: CashDaywisePaymentReport;
    chequeDaywisePaymentReport: ChequeDaywisePaymentReport;
    ddDaywisePaymentReport: DDDaywisePaymentReport;
    upiPaymentDaywisePaymentReport: UpiPaymentDaywisePaymentReport;
    netBankingDaywisePaymentReport: NetBankingDaywisePaymentReport;
    cardDaywisePaymentReport: CardDaywisePaymentReport;
}

export class CashDaywisePaymentReport implements ICashDaywisePaymentReport {
    cashDaywisePaymentReportList!: DaywisePaymentReport[];
    cashDaywisePaymentReportTotal!: DaywisePaymentReportTotal;

    constructor(data?: ICashDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cashDaywisePaymentReportList"])) {
                this.cashDaywisePaymentReportList = [] as any;
                for (let item of _data["cashDaywisePaymentReportList"])
                    this.cashDaywisePaymentReportList!.push(DaywisePaymentReport.fromJS(item));
            }
            this.cashDaywisePaymentReportTotal = _data["cashDaywisePaymentReportTotal"] ? DaywisePaymentReportTotal.fromJS(_data["cashDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new CashDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cashDaywisePaymentReportList)) {
            data["cashDaywisePaymentReportList"] = [];
            for (let item of this.cashDaywisePaymentReportList)
                data["cashDaywisePaymentReportList"].push(item.toJSON());
        }
        data["cashDaywisePaymentReportTotal"] = this.cashDaywisePaymentReportTotal ? this.cashDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): CashDaywisePaymentReport {
        const json = this.toJSON();
        let result = new CashDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface ICashDaywisePaymentReport {
    cashDaywisePaymentReportList: DaywisePaymentReport[];
    cashDaywisePaymentReportTotal: DaywisePaymentReportTotal;
}

export class DaywisePaymentReport implements IDaywisePaymentReport {
    studentName!: string;
    class!: string;
    generalRegistrationNo!: string;
    chequeNumber!: string;
    chequeDate!: moment.Moment;
    chequeBank!: string;
    academicYearName!: string;
    paymentAmount!: number;
    invoiceNumber!: string;
    transactionDate!: moment.Moment;
    paymentMode!: string;
    chequeUnclearedAmount!: number;
    transactionBy!: string;
    transactionId!: string;

    constructor(data?: IDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentName = _data["studentName"];
            this.class = _data["class"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.academicYearName = _data["academicYearName"];
            this.paymentAmount = _data["paymentAmount"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.transactionDate = _data["transactionDate"] ? moment(_data["transactionDate"].toString()) : <any>undefined;
            this.paymentMode = _data["paymentMode"];
            this.chequeUnclearedAmount = _data["chequeUnclearedAmount"];
            this.transactionBy = _data["transactionBy"];
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): DaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new DaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["class"] = this.class;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["academicYearName"] = this.academicYearName;
        data["paymentAmount"] = this.paymentAmount;
        data["invoiceNumber"] = this.invoiceNumber;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["paymentMode"] = this.paymentMode;
        data["chequeUnclearedAmount"] = this.chequeUnclearedAmount;
        data["transactionBy"] = this.transactionBy;
        data["transactionId"] = this.transactionId;
        return data;
    }

    clone(): DaywisePaymentReport {
        const json = this.toJSON();
        let result = new DaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface IDaywisePaymentReport {
    studentName: string;
    class: string;
    generalRegistrationNo: string;
    chequeNumber: string;
    chequeDate: moment.Moment;
    chequeBank: string;
    academicYearName: string;
    paymentAmount: number;
    invoiceNumber: string;
    transactionDate: moment.Moment;
    paymentMode: string;
    chequeUnclearedAmount: number;
    transactionBy: string;
    transactionId: string;
}

export class DaywisePaymentReportTotal implements IDaywisePaymentReportTotal {
    totalPaymentAmount!: number;
    totalChequeUnclearedAmount!: number;

    constructor(data?: IDaywisePaymentReportTotal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPaymentAmount = _data["totalPaymentAmount"];
            this.totalChequeUnclearedAmount = _data["totalChequeUnclearedAmount"];
        }
    }

    static fromJS(data: any): DaywisePaymentReportTotal {
        data = typeof data === 'object' ? data : {};
        let result = new DaywisePaymentReportTotal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPaymentAmount"] = this.totalPaymentAmount;
        data["totalChequeUnclearedAmount"] = this.totalChequeUnclearedAmount;
        return data;
    }

    clone(): DaywisePaymentReportTotal {
        const json = this.toJSON();
        let result = new DaywisePaymentReportTotal();
        result.init(json);
        return result;
    }
}

export interface IDaywisePaymentReportTotal {
    totalPaymentAmount: number;
    totalChequeUnclearedAmount: number;
}

export class ChequeDaywisePaymentReport implements IChequeDaywisePaymentReport {
    chequeDaywisePaymentReportList!: DaywisePaymentReport[];
    chequeDaywisePaymentReportTotal!: DaywisePaymentReportTotal;

    constructor(data?: IChequeDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chequeDaywisePaymentReportList"])) {
                this.chequeDaywisePaymentReportList = [] as any;
                for (let item of _data["chequeDaywisePaymentReportList"])
                    this.chequeDaywisePaymentReportList!.push(DaywisePaymentReport.fromJS(item));
            }
            this.chequeDaywisePaymentReportTotal = _data["chequeDaywisePaymentReportTotal"] ? DaywisePaymentReportTotal.fromJS(_data["chequeDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChequeDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new ChequeDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chequeDaywisePaymentReportList)) {
            data["chequeDaywisePaymentReportList"] = [];
            for (let item of this.chequeDaywisePaymentReportList)
                data["chequeDaywisePaymentReportList"].push(item.toJSON());
        }
        data["chequeDaywisePaymentReportTotal"] = this.chequeDaywisePaymentReportTotal ? this.chequeDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): ChequeDaywisePaymentReport {
        const json = this.toJSON();
        let result = new ChequeDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface IChequeDaywisePaymentReport {
    chequeDaywisePaymentReportList: DaywisePaymentReport[];
    chequeDaywisePaymentReportTotal: DaywisePaymentReportTotal;
}

export class DDDaywisePaymentReport implements IDDDaywisePaymentReport {
    ddDaywisePaymentReportList!: DaywisePaymentReport[];
    ddDaywisePaymentReportTotal!: DaywisePaymentReportTotal;

    constructor(data?: IDDDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ddDaywisePaymentReportList"])) {
                this.ddDaywisePaymentReportList = [] as any;
                for (let item of _data["ddDaywisePaymentReportList"])
                    this.ddDaywisePaymentReportList!.push(DaywisePaymentReport.fromJS(item));
            }
            this.ddDaywisePaymentReportTotal = _data["ddDaywisePaymentReportTotal"] ? DaywisePaymentReportTotal.fromJS(_data["ddDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DDDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new DDDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ddDaywisePaymentReportList)) {
            data["ddDaywisePaymentReportList"] = [];
            for (let item of this.ddDaywisePaymentReportList)
                data["ddDaywisePaymentReportList"].push(item.toJSON());
        }
        data["ddDaywisePaymentReportTotal"] = this.ddDaywisePaymentReportTotal ? this.ddDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): DDDaywisePaymentReport {
        const json = this.toJSON();
        let result = new DDDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface IDDDaywisePaymentReport {
    ddDaywisePaymentReportList: DaywisePaymentReport[];
    ddDaywisePaymentReportTotal: DaywisePaymentReportTotal;
}

export class UpiPaymentDaywisePaymentReport implements IUpiPaymentDaywisePaymentReport {
    upiPaymentDaywisePaymentReportList!: DaywisePaymentReport[];
    upiPaymentDaywisePaymentReportTotal!: DaywisePaymentReportTotal;

    constructor(data?: IUpiPaymentDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upiPaymentDaywisePaymentReportList"])) {
                this.upiPaymentDaywisePaymentReportList = [] as any;
                for (let item of _data["upiPaymentDaywisePaymentReportList"])
                    this.upiPaymentDaywisePaymentReportList!.push(DaywisePaymentReport.fromJS(item));
            }
            this.upiPaymentDaywisePaymentReportTotal = _data["upiPaymentDaywisePaymentReportTotal"] ? DaywisePaymentReportTotal.fromJS(_data["upiPaymentDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpiPaymentDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new UpiPaymentDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upiPaymentDaywisePaymentReportList)) {
            data["upiPaymentDaywisePaymentReportList"] = [];
            for (let item of this.upiPaymentDaywisePaymentReportList)
                data["upiPaymentDaywisePaymentReportList"].push(item.toJSON());
        }
        data["upiPaymentDaywisePaymentReportTotal"] = this.upiPaymentDaywisePaymentReportTotal ? this.upiPaymentDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpiPaymentDaywisePaymentReport {
        const json = this.toJSON();
        let result = new UpiPaymentDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface IUpiPaymentDaywisePaymentReport {
    upiPaymentDaywisePaymentReportList: DaywisePaymentReport[];
    upiPaymentDaywisePaymentReportTotal: DaywisePaymentReportTotal;
}

export class NetBankingDaywisePaymentReport implements INetBankingDaywisePaymentReport {
    netBankingDaywisePaymentReportList!: DaywisePaymentReport[];
    netBankingDaywisePaymentReportTotal!: DaywisePaymentReportTotal;

    constructor(data?: INetBankingDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["netBankingDaywisePaymentReportList"])) {
                this.netBankingDaywisePaymentReportList = [] as any;
                for (let item of _data["netBankingDaywisePaymentReportList"])
                    this.netBankingDaywisePaymentReportList!.push(DaywisePaymentReport.fromJS(item));
            }
            this.netBankingDaywisePaymentReportTotal = _data["netBankingDaywisePaymentReportTotal"] ? DaywisePaymentReportTotal.fromJS(_data["netBankingDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NetBankingDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new NetBankingDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.netBankingDaywisePaymentReportList)) {
            data["netBankingDaywisePaymentReportList"] = [];
            for (let item of this.netBankingDaywisePaymentReportList)
                data["netBankingDaywisePaymentReportList"].push(item.toJSON());
        }
        data["netBankingDaywisePaymentReportTotal"] = this.netBankingDaywisePaymentReportTotal ? this.netBankingDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): NetBankingDaywisePaymentReport {
        const json = this.toJSON();
        let result = new NetBankingDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface INetBankingDaywisePaymentReport {
    netBankingDaywisePaymentReportList: DaywisePaymentReport[];
    netBankingDaywisePaymentReportTotal: DaywisePaymentReportTotal;
}

export class CardDaywisePaymentReport implements ICardDaywisePaymentReport {
    cardDaywisePaymentReportList!: DaywisePaymentReport[];
    cardDaywisePaymentReportTotal!: DaywisePaymentReportTotal;

    constructor(data?: ICardDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cardDaywisePaymentReportList"])) {
                this.cardDaywisePaymentReportList = [] as any;
                for (let item of _data["cardDaywisePaymentReportList"])
                    this.cardDaywisePaymentReportList!.push(DaywisePaymentReport.fromJS(item));
            }
            this.cardDaywisePaymentReportTotal = _data["cardDaywisePaymentReportTotal"] ? DaywisePaymentReportTotal.fromJS(_data["cardDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CardDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new CardDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cardDaywisePaymentReportList)) {
            data["cardDaywisePaymentReportList"] = [];
            for (let item of this.cardDaywisePaymentReportList)
                data["cardDaywisePaymentReportList"].push(item.toJSON());
        }
        data["cardDaywisePaymentReportTotal"] = this.cardDaywisePaymentReportTotal ? this.cardDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): CardDaywisePaymentReport {
        const json = this.toJSON();
        let result = new CardDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface ICardDaywisePaymentReport {
    cardDaywisePaymentReportList: DaywisePaymentReport[];
    cardDaywisePaymentReportTotal: DaywisePaymentReportTotal;
}

export class DaywisePaymentReportRequest implements IDaywisePaymentReportRequest {
    startDate!: SchoolNgbDateModel;
    endDate!: SchoolNgbDateModel;

    constructor(data?: IDaywisePaymentReportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? SchoolNgbDateModel.fromJS(_data["startDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? SchoolNgbDateModel.fromJS(_data["endDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DaywisePaymentReportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DaywisePaymentReportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>undefined;
        return data;
    }

    clone(): DaywisePaymentReportRequest {
        const json = this.toJSON();
        let result = new DaywisePaymentReportRequest();
        result.init(json);
        return result;
    }
}

export interface IDaywisePaymentReportRequest {
    startDate: SchoolNgbDateModel;
    endDate: SchoolNgbDateModel;
}

export class FeeStructureDto implements IFeeStructureDto {
    academicYearId!: number | undefined;
    gradeId!: number | undefined;
    classId!: number[];
    isPublish!: boolean;
    className!: string;
    feeParticulars!: FeeParticularsDto[] | undefined;
    divisionId!: number[] | undefined;
    feeParticularWaiverMappings!: FeeWaiverDto[] | undefined;
    gradeName!: string;
    divisionName!: string;
    installmentDetails!: FeeWaiverDto[] | undefined;

    constructor(data?: IFeeStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
            this.isPublish = _data["isPublish"];
            this.className = _data["className"];
            if (Array.isArray(_data["feeParticulars"])) {
                this.feeParticulars = [] as any;
                for (let item of _data["feeParticulars"])
                    this.feeParticulars!.push(FeeParticularsDto.fromJS(item));
            }
            if (Array.isArray(_data["divisionId"])) {
                this.divisionId = [] as any;
                for (let item of _data["divisionId"])
                    this.divisionId!.push(item);
            }
            if (Array.isArray(_data["feeParticularWaiverMappings"])) {
                this.feeParticularWaiverMappings = [] as any;
                for (let item of _data["feeParticularWaiverMappings"])
                    this.feeParticularWaiverMappings!.push(FeeWaiverDto.fromJS(item));
            }
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            if (Array.isArray(_data["installmentDetails"])) {
                this.installmentDetails = [] as any;
                for (let item of _data["installmentDetails"])
                    this.installmentDetails!.push(FeeWaiverDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeeStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        data["isPublish"] = this.isPublish;
        data["className"] = this.className;
        if (Array.isArray(this.feeParticulars)) {
            data["feeParticulars"] = [];
            for (let item of this.feeParticulars)
                data["feeParticulars"].push(item.toJSON());
        }
        if (Array.isArray(this.divisionId)) {
            data["divisionId"] = [];
            for (let item of this.divisionId)
                data["divisionId"].push(item);
        }
        if (Array.isArray(this.feeParticularWaiverMappings)) {
            data["feeParticularWaiverMappings"] = [];
            for (let item of this.feeParticularWaiverMappings)
                data["feeParticularWaiverMappings"].push(item.toJSON());
        }
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        if (Array.isArray(this.installmentDetails)) {
            data["installmentDetails"] = [];
            for (let item of this.installmentDetails)
                data["installmentDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): FeeStructureDto {
        const json = this.toJSON();
        let result = new FeeStructureDto();
        result.init(json);
        return result;
    }
}

export interface IFeeStructureDto {
    academicYearId: number | undefined;
    gradeId: number | undefined;
    classId: number[];
    isPublish: boolean;
    className: string;
    feeParticulars: FeeParticularsDto[] | undefined;
    divisionId: number[] | undefined;
    feeParticularWaiverMappings: FeeWaiverDto[] | undefined;
    gradeName: string;
    divisionName: string;
    installmentDetails: FeeWaiverDto[] | undefined;
}

export class FeeParticularsDto implements IFeeParticularsDto {
    feeParticularId!: number;
    amount!: number | undefined;
    classId!: number | undefined;
    isDiscountApplicable!: boolean | undefined;
    isRTEApplicable!: boolean | undefined;
    particularName!: string;
    isPublish!: boolean;
    sortBy!: number | undefined;
    isFeePaymentAlreadyDone!: boolean | undefined;

    constructor(data?: IFeeParticularsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularId = _data["feeParticularId"];
            this.amount = _data["amount"];
            this.classId = _data["classId"];
            this.isDiscountApplicable = _data["isDiscountApplicable"];
            this.isRTEApplicable = _data["isRTEApplicable"];
            this.particularName = _data["particularName"];
            this.isPublish = _data["isPublish"];
            this.sortBy = _data["sortBy"];
            this.isFeePaymentAlreadyDone = _data["isFeePaymentAlreadyDone"];
        }
    }

    static fromJS(data: any): FeeParticularsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeParticularsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularId"] = this.feeParticularId;
        data["amount"] = this.amount;
        data["classId"] = this.classId;
        data["isDiscountApplicable"] = this.isDiscountApplicable;
        data["isRTEApplicable"] = this.isRTEApplicable;
        data["particularName"] = this.particularName;
        data["isPublish"] = this.isPublish;
        data["sortBy"] = this.sortBy;
        data["isFeePaymentAlreadyDone"] = this.isFeePaymentAlreadyDone;
        return data;
    }

    clone(): FeeParticularsDto {
        const json = this.toJSON();
        let result = new FeeParticularsDto();
        result.init(json);
        return result;
    }
}

export interface IFeeParticularsDto {
    feeParticularId: number;
    amount: number | undefined;
    classId: number | undefined;
    isDiscountApplicable: boolean | undefined;
    isRTEApplicable: boolean | undefined;
    particularName: string;
    isPublish: boolean;
    sortBy: number | undefined;
    isFeePaymentAlreadyDone: boolean | undefined;
}

export class FeeWaiverResponseDto implements IFeeWaiverResponseDto {
    feeWaivers!: FeeWaiverDto[];
    installmentDetails!: FeeWaiverDto[];

    constructor(data?: IFeeWaiverResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["feeWaivers"])) {
                this.feeWaivers = [] as any;
                for (let item of _data["feeWaivers"])
                    this.feeWaivers!.push(FeeWaiverDto.fromJS(item));
            }
            if (Array.isArray(_data["installmentDetails"])) {
                this.installmentDetails = [] as any;
                for (let item of _data["installmentDetails"])
                    this.installmentDetails!.push(FeeWaiverDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeeWaiverResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeWaiverResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.feeWaivers)) {
            data["feeWaivers"] = [];
            for (let item of this.feeWaivers)
                data["feeWaivers"].push(item.toJSON());
        }
        if (Array.isArray(this.installmentDetails)) {
            data["installmentDetails"] = [];
            for (let item of this.installmentDetails)
                data["installmentDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): FeeWaiverResponseDto {
        const json = this.toJSON();
        let result = new FeeWaiverResponseDto();
        result.init(json);
        return result;
    }
}

export interface IFeeWaiverResponseDto {
    feeWaivers: FeeWaiverDto[];
    installmentDetails: FeeWaiverDto[];
}

export class PublishUnpublishParticularDto implements IPublishUnpublishParticularDto {
    gradeId!: number;
    divisionId!: number;
    academicYearId!: number;
    isPublish!: boolean;

    constructor(data?: IPublishUnpublishParticularDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.isPublish = _data["isPublish"];
        }
    }

    static fromJS(data: any): PublishUnpublishParticularDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishUnpublishParticularDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["isPublish"] = this.isPublish;
        return data;
    }

    clone(): PublishUnpublishParticularDto {
        const json = this.toJSON();
        let result = new PublishUnpublishParticularDto();
        result.init(json);
        return result;
    }
}

export interface IPublishUnpublishParticularDto {
    gradeId: number;
    divisionId: number;
    academicYearId: number;
    isPublish: boolean;
}

export class FeeParticularCloneDto implements IFeeParticularCloneDto {
    fromClassId!: number;
    fromClassName!: string;
    toClassId!: number[];
    academicYearId!: number;

    constructor(data?: IFeeParticularCloneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromClassId = _data["fromClassId"];
            this.fromClassName = _data["fromClassName"];
            if (Array.isArray(_data["toClassId"])) {
                this.toClassId = [] as any;
                for (let item of _data["toClassId"])
                    this.toClassId!.push(item);
            }
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): FeeParticularCloneDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeeParticularCloneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromClassId"] = this.fromClassId;
        data["fromClassName"] = this.fromClassName;
        if (Array.isArray(this.toClassId)) {
            data["toClassId"] = [];
            for (let item of this.toClassId)
                data["toClassId"].push(item);
        }
        data["academicYearId"] = this.academicYearId;
        return data;
    }

    clone(): FeeParticularCloneDto {
        const json = this.toJSON();
        let result = new FeeParticularCloneDto();
        result.init(json);
        return result;
    }
}

export interface IFeeParticularCloneDto {
    fromClassId: number;
    fromClassName: string;
    toClassId: number[];
    academicYearId: number;
}

export class StudentKitFeeStructureDto implements IStudentKitFeeStructureDto {
    academicYearId!: number | undefined;
    gradeId!: number | undefined;
    classId!: number[];
    isPublish!: boolean;
    className!: string;
    feeParticulars!: StudentKitFeeParticularsDto[] | undefined;
    divisionId!: number[] | undefined;
    gradeName!: string;
    divisionName!: string;

    constructor(data?: IStudentKitFeeStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
            this.isPublish = _data["isPublish"];
            this.className = _data["className"];
            if (Array.isArray(_data["feeParticulars"])) {
                this.feeParticulars = [] as any;
                for (let item of _data["feeParticulars"])
                    this.feeParticulars!.push(StudentKitFeeParticularsDto.fromJS(item));
            }
            if (Array.isArray(_data["divisionId"])) {
                this.divisionId = [] as any;
                for (let item of _data["divisionId"])
                    this.divisionId!.push(item);
            }
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
        }
    }

    static fromJS(data: any): StudentKitFeeStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeeStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        data["isPublish"] = this.isPublish;
        data["className"] = this.className;
        if (Array.isArray(this.feeParticulars)) {
            data["feeParticulars"] = [];
            for (let item of this.feeParticulars)
                data["feeParticulars"].push(item.toJSON());
        }
        if (Array.isArray(this.divisionId)) {
            data["divisionId"] = [];
            for (let item of this.divisionId)
                data["divisionId"].push(item);
        }
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        return data;
    }

    clone(): StudentKitFeeStructureDto {
        const json = this.toJSON();
        let result = new StudentKitFeeStructureDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeeStructureDto {
    academicYearId: number | undefined;
    gradeId: number | undefined;
    classId: number[];
    isPublish: boolean;
    className: string;
    feeParticulars: StudentKitFeeParticularsDto[] | undefined;
    divisionId: number[] | undefined;
    gradeName: string;
    divisionName: string;
}

export class StudentKitFeeParticularsDto implements IStudentKitFeeParticularsDto {
    feeParticularId!: number;
    amount!: number | undefined;
    classId!: number | undefined;
    particularName!: string;
    isPublish!: boolean;
    sortBy!: number | undefined;
    isFeePaymentAlreadyDone!: boolean | undefined;

    constructor(data?: IStudentKitFeeParticularsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feeParticularId = _data["feeParticularId"];
            this.amount = _data["amount"];
            this.classId = _data["classId"];
            this.particularName = _data["particularName"];
            this.isPublish = _data["isPublish"];
            this.sortBy = _data["sortBy"];
            this.isFeePaymentAlreadyDone = _data["isFeePaymentAlreadyDone"];
        }
    }

    static fromJS(data: any): StudentKitFeeParticularsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitFeeParticularsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feeParticularId"] = this.feeParticularId;
        data["amount"] = this.amount;
        data["classId"] = this.classId;
        data["particularName"] = this.particularName;
        data["isPublish"] = this.isPublish;
        data["sortBy"] = this.sortBy;
        data["isFeePaymentAlreadyDone"] = this.isFeePaymentAlreadyDone;
        return data;
    }

    clone(): StudentKitFeeParticularsDto {
        const json = this.toJSON();
        let result = new StudentKitFeeParticularsDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitFeeParticularsDto {
    feeParticularId: number;
    amount: number | undefined;
    classId: number | undefined;
    particularName: string;
    isPublish: boolean;
    sortBy: number | undefined;
    isFeePaymentAlreadyDone: boolean | undefined;
}

export class PaymentAnalyticsExportDto implements IPaymentAnalyticsExportDto {
    paymentAnalyticsExportSchool!: PaymentAnalyticsSchoolExportDto[];
    paymentAnalyticsExportGrade!: PaymentAnalyticsGradeExportDto[];
    paymentAnalyticsExportDivision!: PaymentAnalyticsDivisionExportDto[];

    constructor(data?: IPaymentAnalyticsExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paymentAnalyticsExportSchool"])) {
                this.paymentAnalyticsExportSchool = [] as any;
                for (let item of _data["paymentAnalyticsExportSchool"])
                    this.paymentAnalyticsExportSchool!.push(PaymentAnalyticsSchoolExportDto.fromJS(item));
            }
            if (Array.isArray(_data["paymentAnalyticsExportGrade"])) {
                this.paymentAnalyticsExportGrade = [] as any;
                for (let item of _data["paymentAnalyticsExportGrade"])
                    this.paymentAnalyticsExportGrade!.push(PaymentAnalyticsGradeExportDto.fromJS(item));
            }
            if (Array.isArray(_data["paymentAnalyticsExportDivision"])) {
                this.paymentAnalyticsExportDivision = [] as any;
                for (let item of _data["paymentAnalyticsExportDivision"])
                    this.paymentAnalyticsExportDivision!.push(PaymentAnalyticsDivisionExportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentAnalyticsExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paymentAnalyticsExportSchool)) {
            data["paymentAnalyticsExportSchool"] = [];
            for (let item of this.paymentAnalyticsExportSchool)
                data["paymentAnalyticsExportSchool"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentAnalyticsExportGrade)) {
            data["paymentAnalyticsExportGrade"] = [];
            for (let item of this.paymentAnalyticsExportGrade)
                data["paymentAnalyticsExportGrade"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentAnalyticsExportDivision)) {
            data["paymentAnalyticsExportDivision"] = [];
            for (let item of this.paymentAnalyticsExportDivision)
                data["paymentAnalyticsExportDivision"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaymentAnalyticsExportDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsExportDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsExportDto {
    paymentAnalyticsExportSchool: PaymentAnalyticsSchoolExportDto[];
    paymentAnalyticsExportGrade: PaymentAnalyticsGradeExportDto[];
    paymentAnalyticsExportDivision: PaymentAnalyticsDivisionExportDto[];
}

export class PaymentAnalyticsSchoolExportDto implements IPaymentAnalyticsSchoolExportDto {
    schoolName!: string | undefined;
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    isRTEStudent!: string | undefined;
    isNewStudent!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;
    contactNo!: string | undefined;

    constructor(data?: IPaymentAnalyticsSchoolExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isNewStudent = _data["isNewStudent"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): PaymentAnalyticsSchoolExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsSchoolExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isNewStudent"] = this.isNewStudent;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): PaymentAnalyticsSchoolExportDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsSchoolExportDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsSchoolExportDto {
    schoolName: string | undefined;
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    isRTEStudent: string | undefined;
    isNewStudent: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
    contactNo: string | undefined;
}

export class PaymentAnalyticsGradeExportDto implements IPaymentAnalyticsGradeExportDto {
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    isRTEStudent!: string | undefined;
    isNewStudent!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;
    contactNo!: string | undefined;

    constructor(data?: IPaymentAnalyticsGradeExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isNewStudent = _data["isNewStudent"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): PaymentAnalyticsGradeExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsGradeExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isNewStudent"] = this.isNewStudent;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): PaymentAnalyticsGradeExportDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsGradeExportDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsGradeExportDto {
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    isRTEStudent: string | undefined;
    isNewStudent: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
    contactNo: string | undefined;
}

export class PaymentAnalyticsDivisionExportDto implements IPaymentAnalyticsDivisionExportDto {
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    isRTEStudent!: string | undefined;
    isNewStudent!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    collectionInPercentage!: number;
    receivableFee!: number;
    contactNo!: string | undefined;

    constructor(data?: IPaymentAnalyticsDivisionExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isNewStudent = _data["isNewStudent"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.collectionInPercentage = _data["collectionInPercentage"];
            this.receivableFee = _data["receivableFee"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): PaymentAnalyticsDivisionExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAnalyticsDivisionExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isNewStudent"] = this.isNewStudent;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["collectionInPercentage"] = this.collectionInPercentage;
        data["receivableFee"] = this.receivableFee;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): PaymentAnalyticsDivisionExportDto {
        const json = this.toJSON();
        let result = new PaymentAnalyticsDivisionExportDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAnalyticsDivisionExportDto {
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    isRTEStudent: string | undefined;
    isNewStudent: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    collectionInPercentage: number;
    receivableFee: number;
    contactNo: string | undefined;
}

export class ResponseExportStudentDataDto implements IResponseExportStudentDataDto {
    students!: StudentExportDataDto[] | undefined;

    constructor(data?: IResponseExportStudentDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["students"])) {
                this.students = [] as any;
                for (let item of _data["students"])
                    this.students!.push(StudentExportDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseExportStudentDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseExportStudentDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.students)) {
            data["students"] = [];
            for (let item of this.students)
                data["students"].push(item.toJSON());
        }
        return data;
    }

    clone(): ResponseExportStudentDataDto {
        const json = this.toJSON();
        let result = new ResponseExportStudentDataDto();
        result.init(json);
        return result;
    }
}

export interface IResponseExportStudentDataDto {
    students: StudentExportDataDto[] | undefined;
}

export class StudentExportDataDto implements IStudentExportDataDto {
    firstName!: string;
    middleName!: string;
    lastName!: string;
    generalRegistrationNo!: string;
    admissionNo!: string;
    rollNumber!: string;
    gradeName!: string;
    divisionName!: string;
    dateOfAdmission!: string;
    cbscStudentId!: string;
    gender!: string;
    adharNo!: string;
    religion!: string;
    category!: string;
    cast!: string;
    subCast!: string;
    nationality!: string;
    motherTounge!: string;
    emergencyContactPersonName!: string;
    emergencyContactNumber!: string;
    familyDoctorName!: string;
    familyDoctorContactNumber!: string;
    birthPlace!: string;
    birthDate!: string;
    birthDateInWords!: string;
    birthCountryName!: string;
    birthStateName!: string;
    birthDistrictName!: string;
    birthTalukaName!: string;
    currentAddressLine1!: string;
    currentAddressLine2!: string;
    currentZipcode!: string;
    currentCountryName!: string;
    currentStateName!: string;
    currentDistrictName!: string;
    currentTalukaName!: string;
    bloodGroup!: string;
    height!: string;
    weight!: string;
    medicalHistory!: string;
    lastSchoolAttended!: string;
    lastSchoolStandard!: string;
    lastSchoolDivision!: string;
    progressNoteFromLastSchool!: string;
    conductNoteFromLastSchool!: string;
    reasonOfLeavingSchoolLastSchool!: string;
    dateOfLeavingLastSchool!: string;
    remarkFromLastSchool!: string;
    isNewStudent!: string;
    isArchive!: string;
    isRTEStudent!: string;
    isConsationApplicable!: string;
    consationAmount!: string;
    academicYearName!: string;
    previousAcademicYearPendingFeeAmount!: string;
    isAppAccess!: string;
    appAccessMobileNo!: string;
    fatherFirstName!: string;
    fatherMiddleName!: string;
    fatherLastName!: string;
    fatherGender!: string;
    fatherMobileNo!: string;
    fatherConactNo!: string;
    fatherEmailId!: string;
    fatherAddressLine1!: string;
    fatherAddressLine2!: string;
    fatherCountryName!: string;
    fatherStateName!: string;
    fatherDistrictName!: string;
    fatherTalukaName!: string;
    fatherPincode!: string;
    fatherAdharNumber!: string;
    fatherEducation!: string;
    fatherBirthDate!: string;
    fatherOccupation!: string;
    fatherAnnualIncome!: string;
    fatherBloodGroup!: string;
    motherFirstName!: string;
    motherMiddleName!: string;
    motherLastName!: string;
    motherGender!: string;
    motherMobileNo!: string;
    motherConactNo!: string;
    motherEmailId!: string;
    motherAddressLine1!: string;
    motherAddressLine2!: string;
    motherCountryName!: string;
    motherStateName!: string;
    motherDistrictName!: string;
    motherTalukaName!: string;
    motherPincode!: string;
    motherAdharNumber!: string;
    motherEducation!: string;
    motherBirthDate!: string;
    motherOccupation!: string;
    motherAnnualIncome!: string;
    motherBloodGroup!: string;
    guardianFirstName!: string;
    guardianMiddleName!: string;
    guardianLastName!: string;
    guardianGender!: string;
    guardianMobileNo!: string;
    guardianConactNo!: string;
    guardianEmailId!: string;
    guardianAddressLine1!: string;
    guardianAddressLine2!: string;
    guardianCountryName!: string;
    guardianStateName!: string;
    guardianDistrictName!: string;
    guardianTalukaName!: string;
    guardianPincode!: string;
    guardianAdharNumber!: string;
    guardianEducation!: string;
    guardianBirthDate!: string;
    guardianOccupation!: string;
    guardianAnnualIncome!: string;
    guardianBloodGroup!: string;

    constructor(data?: IStudentExportDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.admissionNo = _data["admissionNo"];
            this.rollNumber = _data["rollNumber"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.dateOfAdmission = _data["dateOfAdmission"];
            this.cbscStudentId = _data["cbscStudentId"];
            this.gender = _data["gender"];
            this.adharNo = _data["adharNo"];
            this.religion = _data["religion"];
            this.category = _data["category"];
            this.cast = _data["cast"];
            this.subCast = _data["subCast"];
            this.nationality = _data["nationality"];
            this.motherTounge = _data["motherTounge"];
            this.emergencyContactPersonName = _data["emergencyContactPersonName"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.familyDoctorName = _data["familyDoctorName"];
            this.familyDoctorContactNumber = _data["familyDoctorContactNumber"];
            this.birthPlace = _data["birthPlace"];
            this.birthDate = _data["birthDate"];
            this.birthDateInWords = _data["birthDateInWords"];
            this.birthCountryName = _data["birthCountryName"];
            this.birthStateName = _data["birthStateName"];
            this.birthDistrictName = _data["birthDistrictName"];
            this.birthTalukaName = _data["birthTalukaName"];
            this.currentAddressLine1 = _data["currentAddressLine1"];
            this.currentAddressLine2 = _data["currentAddressLine2"];
            this.currentZipcode = _data["currentZipcode"];
            this.currentCountryName = _data["currentCountryName"];
            this.currentStateName = _data["currentStateName"];
            this.currentDistrictName = _data["currentDistrictName"];
            this.currentTalukaName = _data["currentTalukaName"];
            this.bloodGroup = _data["bloodGroup"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.medicalHistory = _data["medicalHistory"];
            this.lastSchoolAttended = _data["lastSchoolAttended"];
            this.lastSchoolStandard = _data["lastSchoolStandard"];
            this.lastSchoolDivision = _data["lastSchoolDivision"];
            this.progressNoteFromLastSchool = _data["progressNoteFromLastSchool"];
            this.conductNoteFromLastSchool = _data["conductNoteFromLastSchool"];
            this.reasonOfLeavingSchoolLastSchool = _data["reasonOfLeavingSchoolLastSchool"];
            this.dateOfLeavingLastSchool = _data["dateOfLeavingLastSchool"];
            this.remarkFromLastSchool = _data["remarkFromLastSchool"];
            this.isNewStudent = _data["isNewStudent"];
            this.isArchive = _data["isArchive"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isConsationApplicable = _data["isConsationApplicable"];
            this.consationAmount = _data["consationAmount"];
            this.academicYearName = _data["academicYearName"];
            this.previousAcademicYearPendingFeeAmount = _data["previousAcademicYearPendingFeeAmount"];
            this.isAppAccess = _data["isAppAccess"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.fatherFirstName = _data["fatherFirstName"];
            this.fatherMiddleName = _data["fatherMiddleName"];
            this.fatherLastName = _data["fatherLastName"];
            this.fatherGender = _data["fatherGender"];
            this.fatherMobileNo = _data["fatherMobileNo"];
            this.fatherConactNo = _data["fatherConactNo"];
            this.fatherEmailId = _data["fatherEmailId"];
            this.fatherAddressLine1 = _data["fatherAddressLine1"];
            this.fatherAddressLine2 = _data["fatherAddressLine2"];
            this.fatherCountryName = _data["fatherCountryName"];
            this.fatherStateName = _data["fatherStateName"];
            this.fatherDistrictName = _data["fatherDistrictName"];
            this.fatherTalukaName = _data["fatherTalukaName"];
            this.fatherPincode = _data["fatherPincode"];
            this.fatherAdharNumber = _data["fatherAdharNumber"];
            this.fatherEducation = _data["fatherEducation"];
            this.fatherBirthDate = _data["fatherBirthDate"];
            this.fatherOccupation = _data["fatherOccupation"];
            this.fatherAnnualIncome = _data["fatherAnnualIncome"];
            this.fatherBloodGroup = _data["fatherBloodGroup"];
            this.motherFirstName = _data["motherFirstName"];
            this.motherMiddleName = _data["motherMiddleName"];
            this.motherLastName = _data["motherLastName"];
            this.motherGender = _data["motherGender"];
            this.motherMobileNo = _data["motherMobileNo"];
            this.motherConactNo = _data["motherConactNo"];
            this.motherEmailId = _data["motherEmailId"];
            this.motherAddressLine1 = _data["motherAddressLine1"];
            this.motherAddressLine2 = _data["motherAddressLine2"];
            this.motherCountryName = _data["motherCountryName"];
            this.motherStateName = _data["motherStateName"];
            this.motherDistrictName = _data["motherDistrictName"];
            this.motherTalukaName = _data["motherTalukaName"];
            this.motherPincode = _data["motherPincode"];
            this.motherAdharNumber = _data["motherAdharNumber"];
            this.motherEducation = _data["motherEducation"];
            this.motherBirthDate = _data["motherBirthDate"];
            this.motherOccupation = _data["motherOccupation"];
            this.motherAnnualIncome = _data["motherAnnualIncome"];
            this.motherBloodGroup = _data["motherBloodGroup"];
            this.guardianFirstName = _data["guardianFirstName"];
            this.guardianMiddleName = _data["guardianMiddleName"];
            this.guardianLastName = _data["guardianLastName"];
            this.guardianGender = _data["guardianGender"];
            this.guardianMobileNo = _data["guardianMobileNo"];
            this.guardianConactNo = _data["guardianConactNo"];
            this.guardianEmailId = _data["guardianEmailId"];
            this.guardianAddressLine1 = _data["guardianAddressLine1"];
            this.guardianAddressLine2 = _data["guardianAddressLine2"];
            this.guardianCountryName = _data["guardianCountryName"];
            this.guardianStateName = _data["guardianStateName"];
            this.guardianDistrictName = _data["guardianDistrictName"];
            this.guardianTalukaName = _data["guardianTalukaName"];
            this.guardianPincode = _data["guardianPincode"];
            this.guardianAdharNumber = _data["guardianAdharNumber"];
            this.guardianEducation = _data["guardianEducation"];
            this.guardianBirthDate = _data["guardianBirthDate"];
            this.guardianOccupation = _data["guardianOccupation"];
            this.guardianAnnualIncome = _data["guardianAnnualIncome"];
            this.guardianBloodGroup = _data["guardianBloodGroup"];
        }
    }

    static fromJS(data: any): StudentExportDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentExportDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["admissionNo"] = this.admissionNo;
        data["rollNumber"] = this.rollNumber;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["dateOfAdmission"] = this.dateOfAdmission;
        data["cbscStudentId"] = this.cbscStudentId;
        data["gender"] = this.gender;
        data["adharNo"] = this.adharNo;
        data["religion"] = this.religion;
        data["category"] = this.category;
        data["cast"] = this.cast;
        data["subCast"] = this.subCast;
        data["nationality"] = this.nationality;
        data["motherTounge"] = this.motherTounge;
        data["emergencyContactPersonName"] = this.emergencyContactPersonName;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["familyDoctorName"] = this.familyDoctorName;
        data["familyDoctorContactNumber"] = this.familyDoctorContactNumber;
        data["birthPlace"] = this.birthPlace;
        data["birthDate"] = this.birthDate;
        data["birthDateInWords"] = this.birthDateInWords;
        data["birthCountryName"] = this.birthCountryName;
        data["birthStateName"] = this.birthStateName;
        data["birthDistrictName"] = this.birthDistrictName;
        data["birthTalukaName"] = this.birthTalukaName;
        data["currentAddressLine1"] = this.currentAddressLine1;
        data["currentAddressLine2"] = this.currentAddressLine2;
        data["currentZipcode"] = this.currentZipcode;
        data["currentCountryName"] = this.currentCountryName;
        data["currentStateName"] = this.currentStateName;
        data["currentDistrictName"] = this.currentDistrictName;
        data["currentTalukaName"] = this.currentTalukaName;
        data["bloodGroup"] = this.bloodGroup;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["medicalHistory"] = this.medicalHistory;
        data["lastSchoolAttended"] = this.lastSchoolAttended;
        data["lastSchoolStandard"] = this.lastSchoolStandard;
        data["lastSchoolDivision"] = this.lastSchoolDivision;
        data["progressNoteFromLastSchool"] = this.progressNoteFromLastSchool;
        data["conductNoteFromLastSchool"] = this.conductNoteFromLastSchool;
        data["reasonOfLeavingSchoolLastSchool"] = this.reasonOfLeavingSchoolLastSchool;
        data["dateOfLeavingLastSchool"] = this.dateOfLeavingLastSchool;
        data["remarkFromLastSchool"] = this.remarkFromLastSchool;
        data["isNewStudent"] = this.isNewStudent;
        data["isArchive"] = this.isArchive;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isConsationApplicable"] = this.isConsationApplicable;
        data["consationAmount"] = this.consationAmount;
        data["academicYearName"] = this.academicYearName;
        data["previousAcademicYearPendingFeeAmount"] = this.previousAcademicYearPendingFeeAmount;
        data["isAppAccess"] = this.isAppAccess;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["fatherFirstName"] = this.fatherFirstName;
        data["fatherMiddleName"] = this.fatherMiddleName;
        data["fatherLastName"] = this.fatherLastName;
        data["fatherGender"] = this.fatherGender;
        data["fatherMobileNo"] = this.fatherMobileNo;
        data["fatherConactNo"] = this.fatherConactNo;
        data["fatherEmailId"] = this.fatherEmailId;
        data["fatherAddressLine1"] = this.fatherAddressLine1;
        data["fatherAddressLine2"] = this.fatherAddressLine2;
        data["fatherCountryName"] = this.fatherCountryName;
        data["fatherStateName"] = this.fatherStateName;
        data["fatherDistrictName"] = this.fatherDistrictName;
        data["fatherTalukaName"] = this.fatherTalukaName;
        data["fatherPincode"] = this.fatherPincode;
        data["fatherAdharNumber"] = this.fatherAdharNumber;
        data["fatherEducation"] = this.fatherEducation;
        data["fatherBirthDate"] = this.fatherBirthDate;
        data["fatherOccupation"] = this.fatherOccupation;
        data["fatherAnnualIncome"] = this.fatherAnnualIncome;
        data["fatherBloodGroup"] = this.fatherBloodGroup;
        data["motherFirstName"] = this.motherFirstName;
        data["motherMiddleName"] = this.motherMiddleName;
        data["motherLastName"] = this.motherLastName;
        data["motherGender"] = this.motherGender;
        data["motherMobileNo"] = this.motherMobileNo;
        data["motherConactNo"] = this.motherConactNo;
        data["motherEmailId"] = this.motherEmailId;
        data["motherAddressLine1"] = this.motherAddressLine1;
        data["motherAddressLine2"] = this.motherAddressLine2;
        data["motherCountryName"] = this.motherCountryName;
        data["motherStateName"] = this.motherStateName;
        data["motherDistrictName"] = this.motherDistrictName;
        data["motherTalukaName"] = this.motherTalukaName;
        data["motherPincode"] = this.motherPincode;
        data["motherAdharNumber"] = this.motherAdharNumber;
        data["motherEducation"] = this.motherEducation;
        data["motherBirthDate"] = this.motherBirthDate;
        data["motherOccupation"] = this.motherOccupation;
        data["motherAnnualIncome"] = this.motherAnnualIncome;
        data["motherBloodGroup"] = this.motherBloodGroup;
        data["guardianFirstName"] = this.guardianFirstName;
        data["guardianMiddleName"] = this.guardianMiddleName;
        data["guardianLastName"] = this.guardianLastName;
        data["guardianGender"] = this.guardianGender;
        data["guardianMobileNo"] = this.guardianMobileNo;
        data["guardianConactNo"] = this.guardianConactNo;
        data["guardianEmailId"] = this.guardianEmailId;
        data["guardianAddressLine1"] = this.guardianAddressLine1;
        data["guardianAddressLine2"] = this.guardianAddressLine2;
        data["guardianCountryName"] = this.guardianCountryName;
        data["guardianStateName"] = this.guardianStateName;
        data["guardianDistrictName"] = this.guardianDistrictName;
        data["guardianTalukaName"] = this.guardianTalukaName;
        data["guardianPincode"] = this.guardianPincode;
        data["guardianAdharNumber"] = this.guardianAdharNumber;
        data["guardianEducation"] = this.guardianEducation;
        data["guardianBirthDate"] = this.guardianBirthDate;
        data["guardianOccupation"] = this.guardianOccupation;
        data["guardianAnnualIncome"] = this.guardianAnnualIncome;
        data["guardianBloodGroup"] = this.guardianBloodGroup;
        return data;
    }

    clone(): StudentExportDataDto {
        const json = this.toJSON();
        let result = new StudentExportDataDto();
        result.init(json);
        return result;
    }
}

export interface IStudentExportDataDto {
    firstName: string;
    middleName: string;
    lastName: string;
    generalRegistrationNo: string;
    admissionNo: string;
    rollNumber: string;
    gradeName: string;
    divisionName: string;
    dateOfAdmission: string;
    cbscStudentId: string;
    gender: string;
    adharNo: string;
    religion: string;
    category: string;
    cast: string;
    subCast: string;
    nationality: string;
    motherTounge: string;
    emergencyContactPersonName: string;
    emergencyContactNumber: string;
    familyDoctorName: string;
    familyDoctorContactNumber: string;
    birthPlace: string;
    birthDate: string;
    birthDateInWords: string;
    birthCountryName: string;
    birthStateName: string;
    birthDistrictName: string;
    birthTalukaName: string;
    currentAddressLine1: string;
    currentAddressLine2: string;
    currentZipcode: string;
    currentCountryName: string;
    currentStateName: string;
    currentDistrictName: string;
    currentTalukaName: string;
    bloodGroup: string;
    height: string;
    weight: string;
    medicalHistory: string;
    lastSchoolAttended: string;
    lastSchoolStandard: string;
    lastSchoolDivision: string;
    progressNoteFromLastSchool: string;
    conductNoteFromLastSchool: string;
    reasonOfLeavingSchoolLastSchool: string;
    dateOfLeavingLastSchool: string;
    remarkFromLastSchool: string;
    isNewStudent: string;
    isArchive: string;
    isRTEStudent: string;
    isConsationApplicable: string;
    consationAmount: string;
    academicYearName: string;
    previousAcademicYearPendingFeeAmount: string;
    isAppAccess: string;
    appAccessMobileNo: string;
    fatherFirstName: string;
    fatherMiddleName: string;
    fatherLastName: string;
    fatherGender: string;
    fatherMobileNo: string;
    fatherConactNo: string;
    fatherEmailId: string;
    fatherAddressLine1: string;
    fatherAddressLine2: string;
    fatherCountryName: string;
    fatherStateName: string;
    fatherDistrictName: string;
    fatherTalukaName: string;
    fatherPincode: string;
    fatherAdharNumber: string;
    fatherEducation: string;
    fatherBirthDate: string;
    fatherOccupation: string;
    fatherAnnualIncome: string;
    fatherBloodGroup: string;
    motherFirstName: string;
    motherMiddleName: string;
    motherLastName: string;
    motherGender: string;
    motherMobileNo: string;
    motherConactNo: string;
    motherEmailId: string;
    motherAddressLine1: string;
    motherAddressLine2: string;
    motherCountryName: string;
    motherStateName: string;
    motherDistrictName: string;
    motherTalukaName: string;
    motherPincode: string;
    motherAdharNumber: string;
    motherEducation: string;
    motherBirthDate: string;
    motherOccupation: string;
    motherAnnualIncome: string;
    motherBloodGroup: string;
    guardianFirstName: string;
    guardianMiddleName: string;
    guardianLastName: string;
    guardianGender: string;
    guardianMobileNo: string;
    guardianConactNo: string;
    guardianEmailId: string;
    guardianAddressLine1: string;
    guardianAddressLine2: string;
    guardianCountryName: string;
    guardianStateName: string;
    guardianDistrictName: string;
    guardianTalukaName: string;
    guardianPincode: string;
    guardianAdharNumber: string;
    guardianEducation: string;
    guardianBirthDate: string;
    guardianOccupation: string;
    guardianAnnualIncome: string;
    guardianBloodGroup: string;
}

export class StudentKitPaymentAnalyticsExportDto implements IStudentKitPaymentAnalyticsExportDto {
    studentKitPaymentAnalyticsExportSchool!: StudentKitPaymentAnalyticsSchoolExportDto[];
    studentKitPaymentAnalyticsExportGrade!: StudentKitPaymentAnalyticsGradeExportDto[];
    studentKitPaymentAnalyticsExportDivision!: StudentKitPaymentAnalyticsDivisionExportDto[];

    constructor(data?: IStudentKitPaymentAnalyticsExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentKitPaymentAnalyticsExportSchool"])) {
                this.studentKitPaymentAnalyticsExportSchool = [] as any;
                for (let item of _data["studentKitPaymentAnalyticsExportSchool"])
                    this.studentKitPaymentAnalyticsExportSchool!.push(StudentKitPaymentAnalyticsSchoolExportDto.fromJS(item));
            }
            if (Array.isArray(_data["studentKitPaymentAnalyticsExportGrade"])) {
                this.studentKitPaymentAnalyticsExportGrade = [] as any;
                for (let item of _data["studentKitPaymentAnalyticsExportGrade"])
                    this.studentKitPaymentAnalyticsExportGrade!.push(StudentKitPaymentAnalyticsGradeExportDto.fromJS(item));
            }
            if (Array.isArray(_data["studentKitPaymentAnalyticsExportDivision"])) {
                this.studentKitPaymentAnalyticsExportDivision = [] as any;
                for (let item of _data["studentKitPaymentAnalyticsExportDivision"])
                    this.studentKitPaymentAnalyticsExportDivision!.push(StudentKitPaymentAnalyticsDivisionExportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentKitPaymentAnalyticsExportSchool)) {
            data["studentKitPaymentAnalyticsExportSchool"] = [];
            for (let item of this.studentKitPaymentAnalyticsExportSchool)
                data["studentKitPaymentAnalyticsExportSchool"].push(item.toJSON());
        }
        if (Array.isArray(this.studentKitPaymentAnalyticsExportGrade)) {
            data["studentKitPaymentAnalyticsExportGrade"] = [];
            for (let item of this.studentKitPaymentAnalyticsExportGrade)
                data["studentKitPaymentAnalyticsExportGrade"].push(item.toJSON());
        }
        if (Array.isArray(this.studentKitPaymentAnalyticsExportDivision)) {
            data["studentKitPaymentAnalyticsExportDivision"] = [];
            for (let item of this.studentKitPaymentAnalyticsExportDivision)
                data["studentKitPaymentAnalyticsExportDivision"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentKitPaymentAnalyticsExportDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsExportDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsExportDto {
    studentKitPaymentAnalyticsExportSchool: StudentKitPaymentAnalyticsSchoolExportDto[];
    studentKitPaymentAnalyticsExportGrade: StudentKitPaymentAnalyticsGradeExportDto[];
    studentKitPaymentAnalyticsExportDivision: StudentKitPaymentAnalyticsDivisionExportDto[];
}

export class StudentKitPaymentAnalyticsSchoolExportDto implements IStudentKitPaymentAnalyticsSchoolExportDto {
    schoolName!: string | undefined;
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    isRTEStudent!: string | undefined;
    isNewStudent!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;
    contactNo!: string | undefined;

    constructor(data?: IStudentKitPaymentAnalyticsSchoolExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isNewStudent = _data["isNewStudent"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsSchoolExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsSchoolExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isNewStudent"] = this.isNewStudent;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): StudentKitPaymentAnalyticsSchoolExportDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsSchoolExportDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsSchoolExportDto {
    schoolName: string | undefined;
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    isRTEStudent: string | undefined;
    isNewStudent: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
    contactNo: string | undefined;
}

export class StudentKitPaymentAnalyticsGradeExportDto implements IStudentKitPaymentAnalyticsGradeExportDto {
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    isRTEStudent!: string | undefined;
    isNewStudent!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    receivableFee!: number;
    collectionInPercentage!: number;
    contactNo!: string | undefined;

    constructor(data?: IStudentKitPaymentAnalyticsGradeExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isNewStudent = _data["isNewStudent"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.receivableFee = _data["receivableFee"];
            this.collectionInPercentage = _data["collectionInPercentage"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsGradeExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsGradeExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isNewStudent"] = this.isNewStudent;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["receivableFee"] = this.receivableFee;
        data["collectionInPercentage"] = this.collectionInPercentage;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): StudentKitPaymentAnalyticsGradeExportDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsGradeExportDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsGradeExportDto {
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    isRTEStudent: string | undefined;
    isNewStudent: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    receivableFee: number;
    collectionInPercentage: number;
    contactNo: string | undefined;
}

export class StudentKitPaymentAnalyticsDivisionExportDto implements IStudentKitPaymentAnalyticsDivisionExportDto {
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    isRTEStudent!: string | undefined;
    isNewStudent!: string | undefined;
    totalFee!: number;
    discountedFee!: number;
    effectiveFee!: number;
    collectionTillDate!: number;
    collectionInPercentage!: number;
    receivableFee!: number;
    contactNo!: string | undefined;

    constructor(data?: IStudentKitPaymentAnalyticsDivisionExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.isNewStudent = _data["isNewStudent"];
            this.totalFee = _data["totalFee"];
            this.discountedFee = _data["discountedFee"];
            this.effectiveFee = _data["effectiveFee"];
            this.collectionTillDate = _data["collectionTillDate"];
            this.collectionInPercentage = _data["collectionInPercentage"];
            this.receivableFee = _data["receivableFee"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): StudentKitPaymentAnalyticsDivisionExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentKitPaymentAnalyticsDivisionExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["isRTEStudent"] = this.isRTEStudent;
        data["isNewStudent"] = this.isNewStudent;
        data["totalFee"] = this.totalFee;
        data["discountedFee"] = this.discountedFee;
        data["effectiveFee"] = this.effectiveFee;
        data["collectionTillDate"] = this.collectionTillDate;
        data["collectionInPercentage"] = this.collectionInPercentage;
        data["receivableFee"] = this.receivableFee;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): StudentKitPaymentAnalyticsDivisionExportDto {
        const json = this.toJSON();
        let result = new StudentKitPaymentAnalyticsDivisionExportDto();
        result.init(json);
        return result;
    }
}

export interface IStudentKitPaymentAnalyticsDivisionExportDto {
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    isRTEStudent: string | undefined;
    isNewStudent: string | undefined;
    totalFee: number;
    discountedFee: number;
    effectiveFee: number;
    collectionTillDate: number;
    collectionInPercentage: number;
    receivableFee: number;
    contactNo: string | undefined;
}

export class ResponseExportTeacherDataDto implements IResponseExportTeacherDataDto {
    teachers!: TeacherExportDataDto[] | undefined;

    constructor(data?: IResponseExportTeacherDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["teachers"])) {
                this.teachers = [] as any;
                for (let item of _data["teachers"])
                    this.teachers!.push(TeacherExportDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseExportTeacherDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseExportTeacherDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.teachers)) {
            data["teachers"] = [];
            for (let item of this.teachers)
                data["teachers"].push(item.toJSON());
        }
        return data;
    }

    clone(): ResponseExportTeacherDataDto {
        const json = this.toJSON();
        let result = new ResponseExportTeacherDataDto();
        result.init(json);
        return result;
    }
}

export interface IResponseExportTeacherDataDto {
    teachers: TeacherExportDataDto[] | undefined;
}

export class TeacherExportDataDto implements ITeacherExportDataDto {
    firstName!: string;
    middleName!: string;
    lastName!: string;
    gender!: string;
    mobileNumber!: string;
    contactNumber!: string;
    emailId!: string;
    addressLine1!: string;
    addressLine2!: string;
    countryName!: string;
    stateName!: string;
    districtName!: string;
    talukaName!: string;
    pincode!: string;
    adharNumber!: string;
    education!: string;
    birthDate!: string;
    bloodGroup!: string;
    isAppAccess!: string;
    appAccessMobileNo!: string;

    constructor(data?: ITeacherExportDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.gender = _data["gender"];
            this.mobileNumber = _data["mobileNumber"];
            this.contactNumber = _data["contactNumber"];
            this.emailId = _data["emailId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.districtName = _data["districtName"];
            this.talukaName = _data["talukaName"];
            this.pincode = _data["pincode"];
            this.adharNumber = _data["adharNumber"];
            this.education = _data["education"];
            this.birthDate = _data["birthDate"];
            this.bloodGroup = _data["bloodGroup"];
            this.isAppAccess = _data["isAppAccess"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
        }
    }

    static fromJS(data: any): TeacherExportDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherExportDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["gender"] = this.gender;
        data["mobileNumber"] = this.mobileNumber;
        data["contactNumber"] = this.contactNumber;
        data["emailId"] = this.emailId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["districtName"] = this.districtName;
        data["talukaName"] = this.talukaName;
        data["pincode"] = this.pincode;
        data["adharNumber"] = this.adharNumber;
        data["education"] = this.education;
        data["birthDate"] = this.birthDate;
        data["bloodGroup"] = this.bloodGroup;
        data["isAppAccess"] = this.isAppAccess;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        return data;
    }

    clone(): TeacherExportDataDto {
        const json = this.toJSON();
        let result = new TeacherExportDataDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherExportDataDto {
    firstName: string;
    middleName: string;
    lastName: string;
    gender: string;
    mobileNumber: string;
    contactNumber: string;
    emailId: string;
    addressLine1: string;
    addressLine2: string;
    countryName: string;
    stateName: string;
    districtName: string;
    talukaName: string;
    pincode: string;
    adharNumber: string;
    education: string;
    birthDate: string;
    bloodGroup: string;
    isAppAccess: string;
    appAccessMobileNo: string;
}

export class TransportPaymentAnalyticsExportDto implements ITransportPaymentAnalyticsExportDto {
    transportPaymentAnalyticsExportSchool!: TransportPaymentAnalyticsSchoolExportDto[];
    transportPaymentAnalyticsExportGrade!: TransportPaymentAnalyticsGradeExportDto[];
    transportPaymentAnalyticsExportDivision!: TransportPaymentAnalyticsDivisionExportDto[];
    transportPaymentAnalyticsExportStaffList!: TransportPaymentAnalyticsStaffListExportDto[];

    constructor(data?: ITransportPaymentAnalyticsExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["transportPaymentAnalyticsExportSchool"])) {
                this.transportPaymentAnalyticsExportSchool = [] as any;
                for (let item of _data["transportPaymentAnalyticsExportSchool"])
                    this.transportPaymentAnalyticsExportSchool!.push(TransportPaymentAnalyticsSchoolExportDto.fromJS(item));
            }
            if (Array.isArray(_data["transportPaymentAnalyticsExportGrade"])) {
                this.transportPaymentAnalyticsExportGrade = [] as any;
                for (let item of _data["transportPaymentAnalyticsExportGrade"])
                    this.transportPaymentAnalyticsExportGrade!.push(TransportPaymentAnalyticsGradeExportDto.fromJS(item));
            }
            if (Array.isArray(_data["transportPaymentAnalyticsExportDivision"])) {
                this.transportPaymentAnalyticsExportDivision = [] as any;
                for (let item of _data["transportPaymentAnalyticsExportDivision"])
                    this.transportPaymentAnalyticsExportDivision!.push(TransportPaymentAnalyticsDivisionExportDto.fromJS(item));
            }
            if (Array.isArray(_data["transportPaymentAnalyticsExportStaffList"])) {
                this.transportPaymentAnalyticsExportStaffList = [] as any;
                for (let item of _data["transportPaymentAnalyticsExportStaffList"])
                    this.transportPaymentAnalyticsExportStaffList!.push(TransportPaymentAnalyticsStaffListExportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transportPaymentAnalyticsExportSchool)) {
            data["transportPaymentAnalyticsExportSchool"] = [];
            for (let item of this.transportPaymentAnalyticsExportSchool)
                data["transportPaymentAnalyticsExportSchool"].push(item.toJSON());
        }
        if (Array.isArray(this.transportPaymentAnalyticsExportGrade)) {
            data["transportPaymentAnalyticsExportGrade"] = [];
            for (let item of this.transportPaymentAnalyticsExportGrade)
                data["transportPaymentAnalyticsExportGrade"].push(item.toJSON());
        }
        if (Array.isArray(this.transportPaymentAnalyticsExportDivision)) {
            data["transportPaymentAnalyticsExportDivision"] = [];
            for (let item of this.transportPaymentAnalyticsExportDivision)
                data["transportPaymentAnalyticsExportDivision"].push(item.toJSON());
        }
        if (Array.isArray(this.transportPaymentAnalyticsExportStaffList)) {
            data["transportPaymentAnalyticsExportStaffList"] = [];
            for (let item of this.transportPaymentAnalyticsExportStaffList)
                data["transportPaymentAnalyticsExportStaffList"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportPaymentAnalyticsExportDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsExportDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsExportDto {
    transportPaymentAnalyticsExportSchool: TransportPaymentAnalyticsSchoolExportDto[];
    transportPaymentAnalyticsExportGrade: TransportPaymentAnalyticsGradeExportDto[];
    transportPaymentAnalyticsExportDivision: TransportPaymentAnalyticsDivisionExportDto[];
    transportPaymentAnalyticsExportStaffList: TransportPaymentAnalyticsStaffListExportDto[];
}

export class TransportPaymentAnalyticsSchoolExportDto implements ITransportPaymentAnalyticsSchoolExportDto {
    schoolName!: string | undefined;
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;
    contactNo!: string | undefined;

    constructor(data?: ITransportPaymentAnalyticsSchoolExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsSchoolExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsSchoolExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): TransportPaymentAnalyticsSchoolExportDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsSchoolExportDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsSchoolExportDto {
    schoolName: string | undefined;
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
    contactNo: string | undefined;
}

export class TransportPaymentAnalyticsGradeExportDto implements ITransportPaymentAnalyticsGradeExportDto {
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;
    contactNo!: string | undefined;

    constructor(data?: ITransportPaymentAnalyticsGradeExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsGradeExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsGradeExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): TransportPaymentAnalyticsGradeExportDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsGradeExportDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsGradeExportDto {
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
    contactNo: string | undefined;
}

export class TransportPaymentAnalyticsDivisionExportDto implements ITransportPaymentAnalyticsDivisionExportDto {
    gradeName!: string | undefined;
    divisionName!: string | undefined;
    rollNumber!: string | undefined;
    studentName!: string | undefined;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;
    contactNo!: string | undefined;

    constructor(data?: ITransportPaymentAnalyticsDivisionExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsDivisionExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsDivisionExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): TransportPaymentAnalyticsDivisionExportDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsDivisionExportDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsDivisionExportDto {
    gradeName: string | undefined;
    divisionName: string | undefined;
    rollNumber: string | undefined;
    studentName: string | undefined;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
    contactNo: string | undefined;
}

export class TransportPaymentAnalyticsStaffListExportDto implements ITransportPaymentAnalyticsStaffListExportDto {
    consumerName!: string | undefined;
    roleName!: string | undefined;
    academicYearName!: string | undefined;
    transportTotalFee!: number;
    transportDiscountedFee!: number;
    transportEffectiveFee!: number;
    transportCollectionTillDate!: number;
    transportReceivableFee!: number;
    transportCollectionInPercentage!: number;
    contactNo!: string | undefined;

    constructor(data?: ITransportPaymentAnalyticsStaffListExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerName = _data["consumerName"];
            this.roleName = _data["roleName"];
            this.academicYearName = _data["academicYearName"];
            this.transportTotalFee = _data["transportTotalFee"];
            this.transportDiscountedFee = _data["transportDiscountedFee"];
            this.transportEffectiveFee = _data["transportEffectiveFee"];
            this.transportCollectionTillDate = _data["transportCollectionTillDate"];
            this.transportReceivableFee = _data["transportReceivableFee"];
            this.transportCollectionInPercentage = _data["transportCollectionInPercentage"];
            this.contactNo = _data["contactNo"];
        }
    }

    static fromJS(data: any): TransportPaymentAnalyticsStaffListExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportPaymentAnalyticsStaffListExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerName"] = this.consumerName;
        data["roleName"] = this.roleName;
        data["academicYearName"] = this.academicYearName;
        data["transportTotalFee"] = this.transportTotalFee;
        data["transportDiscountedFee"] = this.transportDiscountedFee;
        data["transportEffectiveFee"] = this.transportEffectiveFee;
        data["transportCollectionTillDate"] = this.transportCollectionTillDate;
        data["transportReceivableFee"] = this.transportReceivableFee;
        data["transportCollectionInPercentage"] = this.transportCollectionInPercentage;
        data["contactNo"] = this.contactNo;
        return data;
    }

    clone(): TransportPaymentAnalyticsStaffListExportDto {
        const json = this.toJSON();
        let result = new TransportPaymentAnalyticsStaffListExportDto();
        result.init(json);
        return result;
    }
}

export interface ITransportPaymentAnalyticsStaffListExportDto {
    consumerName: string | undefined;
    roleName: string | undefined;
    academicYearName: string | undefined;
    transportTotalFee: number;
    transportDiscountedFee: number;
    transportEffectiveFee: number;
    transportCollectionTillDate: number;
    transportReceivableFee: number;
    transportCollectionInPercentage: number;
    contactNo: string | undefined;
}

export class DivisionDto implements IDivisionDto {
    divisionId!: number | undefined;
    divisionName!: string | undefined;

    constructor(data?: IDivisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
        }
    }

    static fromJS(data: any): DivisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DivisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        return data;
    }

    clone(): DivisionDto {
        const json = this.toJSON();
        let result = new DivisionDto();
        result.init(json);
        return result;
    }
}

export interface IDivisionDto {
    divisionId: number | undefined;
    divisionName: string | undefined;
}

export class DivisionUpdateleteRespose implements IDivisionUpdateleteRespose {
    exits!: number;

    constructor(data?: IDivisionUpdateleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exits = _data["exits"];
        }
    }

    static fromJS(data: any): DivisionUpdateleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new DivisionUpdateleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exits"] = this.exits;
        return data;
    }

    clone(): DivisionUpdateleteRespose {
        const json = this.toJSON();
        let result = new DivisionUpdateleteRespose();
        result.init(json);
        return result;
    }
}

export interface IDivisionUpdateleteRespose {
    exits: number;
}

export class DivisionDeleteRespose implements IDivisionDeleteRespose {
    affectedRows!: number;

    constructor(data?: IDivisionDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): DivisionDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new DivisionDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): DivisionDeleteRespose {
        const json = this.toJSON();
        let result = new DivisionDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IDivisionDeleteRespose {
    affectedRows: number;
}

export class DashboardCountDto implements IDashboardCountDto {
    studentCount!: number;
    teacherCount!: number;
    cabDriverCount!: number;
    staffCount!: number;

    constructor(data?: IDashboardCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentCount = _data["studentCount"];
            this.teacherCount = _data["teacherCount"];
            this.cabDriverCount = _data["cabDriverCount"];
            this.staffCount = _data["staffCount"];
        }
    }

    static fromJS(data: any): DashboardCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentCount"] = this.studentCount;
        data["teacherCount"] = this.teacherCount;
        data["cabDriverCount"] = this.cabDriverCount;
        data["staffCount"] = this.staffCount;
        return data;
    }

    clone(): DashboardCountDto {
        const json = this.toJSON();
        let result = new DashboardCountDto();
        result.init(json);
        return result;
    }
}

export interface IDashboardCountDto {
    studentCount: number;
    teacherCount: number;
    cabDriverCount: number;
    staffCount: number;
}

export class DashBoardStaffDetailsDto implements IDashBoardStaffDetailsDto {
    dashBoardStaffDetails!: DashBoardStaffDetails[];

    constructor(data?: IDashBoardStaffDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dashBoardStaffDetails"])) {
                this.dashBoardStaffDetails = [] as any;
                for (let item of _data["dashBoardStaffDetails"])
                    this.dashBoardStaffDetails!.push(DashBoardStaffDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashBoardStaffDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashBoardStaffDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dashBoardStaffDetails)) {
            data["dashBoardStaffDetails"] = [];
            for (let item of this.dashBoardStaffDetails)
                data["dashBoardStaffDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): DashBoardStaffDetailsDto {
        const json = this.toJSON();
        let result = new DashBoardStaffDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IDashBoardStaffDetailsDto {
    dashBoardStaffDetails: DashBoardStaffDetails[];
}

export class DashBoardStaffDetails implements IDashBoardStaffDetails {
    staffName!: string;
    role!: string;
    mobileNumber!: string;
    address!: string;
    email!: string;

    constructor(data?: IDashBoardStaffDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffName = _data["staffName"];
            this.role = _data["role"];
            this.mobileNumber = _data["mobileNumber"];
            this.address = _data["address"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): DashBoardStaffDetails {
        data = typeof data === 'object' ? data : {};
        let result = new DashBoardStaffDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffName"] = this.staffName;
        data["role"] = this.role;
        data["mobileNumber"] = this.mobileNumber;
        data["address"] = this.address;
        data["email"] = this.email;
        return data;
    }

    clone(): DashBoardStaffDetails {
        const json = this.toJSON();
        let result = new DashBoardStaffDetails();
        result.init(json);
        return result;
    }
}

export interface IDashBoardStaffDetails {
    staffName: string;
    role: string;
    mobileNumber: string;
    address: string;
    email: string;
}

export class GirlsBoysCountDto implements IGirlsBoysCountDto {
    girlsBoysCount!: GirlsBoysCount[];

    constructor(data?: IGirlsBoysCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["girlsBoysCount"])) {
                this.girlsBoysCount = [] as any;
                for (let item of _data["girlsBoysCount"])
                    this.girlsBoysCount!.push(GirlsBoysCount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GirlsBoysCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new GirlsBoysCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.girlsBoysCount)) {
            data["girlsBoysCount"] = [];
            for (let item of this.girlsBoysCount)
                data["girlsBoysCount"].push(item.toJSON());
        }
        return data;
    }

    clone(): GirlsBoysCountDto {
        const json = this.toJSON();
        let result = new GirlsBoysCountDto();
        result.init(json);
        return result;
    }
}

export interface IGirlsBoysCountDto {
    girlsBoysCount: GirlsBoysCount[];
}

export class GirlsBoysCount implements IGirlsBoysCount {
    totalCount!: number;
    girlsCount!: number;
    boysCount!: number;

    constructor(data?: IGirlsBoysCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.girlsCount = _data["girlsCount"];
            this.boysCount = _data["boysCount"];
        }
    }

    static fromJS(data: any): GirlsBoysCount {
        data = typeof data === 'object' ? data : {};
        let result = new GirlsBoysCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["girlsCount"] = this.girlsCount;
        data["boysCount"] = this.boysCount;
        return data;
    }

    clone(): GirlsBoysCount {
        const json = this.toJSON();
        let result = new GirlsBoysCount();
        result.init(json);
        return result;
    }
}

export interface IGirlsBoysCount {
    totalCount: number;
    girlsCount: number;
    boysCount: number;
}

export class AdminDashboardCountDto implements IAdminDashboardCountDto {
    addmissionCount!: AddmissionCount;
    attendancePercentage!: AttendancePercentage;
    girlsBoysCount!: GirlsBoysCount;
    feeCollectionPercentage!: FeeCollectionPercentage;

    constructor(data?: IAdminDashboardCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addmissionCount = _data["addmissionCount"] ? AddmissionCount.fromJS(_data["addmissionCount"]) : <any>undefined;
            this.attendancePercentage = _data["attendancePercentage"] ? AttendancePercentage.fromJS(_data["attendancePercentage"]) : <any>undefined;
            this.girlsBoysCount = _data["girlsBoysCount"] ? GirlsBoysCount.fromJS(_data["girlsBoysCount"]) : <any>undefined;
            this.feeCollectionPercentage = _data["feeCollectionPercentage"] ? FeeCollectionPercentage.fromJS(_data["feeCollectionPercentage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdminDashboardCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDashboardCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addmissionCount"] = this.addmissionCount ? this.addmissionCount.toJSON() : <any>undefined;
        data["attendancePercentage"] = this.attendancePercentage ? this.attendancePercentage.toJSON() : <any>undefined;
        data["girlsBoysCount"] = this.girlsBoysCount ? this.girlsBoysCount.toJSON() : <any>undefined;
        data["feeCollectionPercentage"] = this.feeCollectionPercentage ? this.feeCollectionPercentage.toJSON() : <any>undefined;
        return data;
    }

    clone(): AdminDashboardCountDto {
        const json = this.toJSON();
        let result = new AdminDashboardCountDto();
        result.init(json);
        return result;
    }
}

export interface IAdminDashboardCountDto {
    addmissionCount: AddmissionCount;
    attendancePercentage: AttendancePercentage;
    girlsBoysCount: GirlsBoysCount;
    feeCollectionPercentage: FeeCollectionPercentage;
}

export class AddmissionCount implements IAddmissionCount {
    todaysAddmissions!: number;
    monthlyAddmissions!: number;
    tillDateAddmissions!: number;

    constructor(data?: IAddmissionCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.todaysAddmissions = _data["todaysAddmissions"];
            this.monthlyAddmissions = _data["monthlyAddmissions"];
            this.tillDateAddmissions = _data["tillDateAddmissions"];
        }
    }

    static fromJS(data: any): AddmissionCount {
        data = typeof data === 'object' ? data : {};
        let result = new AddmissionCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["todaysAddmissions"] = this.todaysAddmissions;
        data["monthlyAddmissions"] = this.monthlyAddmissions;
        data["tillDateAddmissions"] = this.tillDateAddmissions;
        return data;
    }

    clone(): AddmissionCount {
        const json = this.toJSON();
        let result = new AddmissionCount();
        result.init(json);
        return result;
    }
}

export interface IAddmissionCount {
    todaysAddmissions: number;
    monthlyAddmissions: number;
    tillDateAddmissions: number;
}

export class AttendancePercentage implements IAttendancePercentage {
    todaysAttendance!: number;
    monthlyAttendance!: number;
    tillDateAttendance!: number;

    constructor(data?: IAttendancePercentage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.todaysAttendance = _data["todaysAttendance"];
            this.monthlyAttendance = _data["monthlyAttendance"];
            this.tillDateAttendance = _data["tillDateAttendance"];
        }
    }

    static fromJS(data: any): AttendancePercentage {
        data = typeof data === 'object' ? data : {};
        let result = new AttendancePercentage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["todaysAttendance"] = this.todaysAttendance;
        data["monthlyAttendance"] = this.monthlyAttendance;
        data["tillDateAttendance"] = this.tillDateAttendance;
        return data;
    }

    clone(): AttendancePercentage {
        const json = this.toJSON();
        let result = new AttendancePercentage();
        result.init(json);
        return result;
    }
}

export interface IAttendancePercentage {
    todaysAttendance: number;
    monthlyAttendance: number;
    tillDateAttendance: number;
}

export class FeeCollectionPercentage implements IFeeCollectionPercentage {
    todaysCollection!: number;
    monthlyCollection!: number;
    tillDateCollection!: number;

    constructor(data?: IFeeCollectionPercentage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.todaysCollection = _data["todaysCollection"];
            this.monthlyCollection = _data["monthlyCollection"];
            this.tillDateCollection = _data["tillDateCollection"];
        }
    }

    static fromJS(data: any): FeeCollectionPercentage {
        data = typeof data === 'object' ? data : {};
        let result = new FeeCollectionPercentage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["todaysCollection"] = this.todaysCollection;
        data["monthlyCollection"] = this.monthlyCollection;
        data["tillDateCollection"] = this.tillDateCollection;
        return data;
    }

    clone(): FeeCollectionPercentage {
        const json = this.toJSON();
        let result = new FeeCollectionPercentage();
        result.init(json);
        return result;
    }
}

export interface IFeeCollectionPercentage {
    todaysCollection: number;
    monthlyCollection: number;
    tillDateCollection: number;
}

export class IdealTeacherListResponseDto implements IIdealTeacherListResponseDto {
    schoolTimeSlotList!: IdealTeachersWithHrsAndMinsDto[] | undefined;

    constructor(data?: IIdealTeacherListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["schoolTimeSlotList"])) {
                this.schoolTimeSlotList = [] as any;
                for (let item of _data["schoolTimeSlotList"])
                    this.schoolTimeSlotList!.push(IdealTeachersWithHrsAndMinsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdealTeacherListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdealTeacherListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schoolTimeSlotList)) {
            data["schoolTimeSlotList"] = [];
            for (let item of this.schoolTimeSlotList)
                data["schoolTimeSlotList"].push(item.toJSON());
        }
        return data;
    }

    clone(): IdealTeacherListResponseDto {
        const json = this.toJSON();
        let result = new IdealTeacherListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IIdealTeacherListResponseDto {
    schoolTimeSlotList: IdealTeachersWithHrsAndMinsDto[] | undefined;
}

export class IdealTeachersWithHrsAndMinsDto implements IIdealTeachersWithHrsAndMinsDto {
    startingHour!: number | undefined;
    startingMinute!: number | undefined;
    endingHour!: number | undefined;
    endingMinute!: number | undefined;
    idealTeacherList!: IdealTeacher[] | undefined;

    constructor(data?: IIdealTeachersWithHrsAndMinsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startingHour = _data["startingHour"];
            this.startingMinute = _data["startingMinute"];
            this.endingHour = _data["endingHour"];
            this.endingMinute = _data["endingMinute"];
            if (Array.isArray(_data["idealTeacherList"])) {
                this.idealTeacherList = [] as any;
                for (let item of _data["idealTeacherList"])
                    this.idealTeacherList!.push(IdealTeacher.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdealTeachersWithHrsAndMinsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdealTeachersWithHrsAndMinsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startingHour"] = this.startingHour;
        data["startingMinute"] = this.startingMinute;
        data["endingHour"] = this.endingHour;
        data["endingMinute"] = this.endingMinute;
        if (Array.isArray(this.idealTeacherList)) {
            data["idealTeacherList"] = [];
            for (let item of this.idealTeacherList)
                data["idealTeacherList"].push(item.toJSON());
        }
        return data;
    }

    clone(): IdealTeachersWithHrsAndMinsDto {
        const json = this.toJSON();
        let result = new IdealTeachersWithHrsAndMinsDto();
        result.init(json);
        return result;
    }
}

export interface IIdealTeachersWithHrsAndMinsDto {
    startingHour: number | undefined;
    startingMinute: number | undefined;
    endingHour: number | undefined;
    endingMinute: number | undefined;
    idealTeacherList: IdealTeacher[] | undefined;
}

export class IdealTeacher implements IIdealTeacher {
    startingHour!: number | undefined;
    startingMinute!: number | undefined;
    endingHour!: number | undefined;
    endingMinute!: number | undefined;
    teacherId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    teacherName!: string;
    mobileNumber!: string;
    profileImageUrl!: string;
    subjectNames!: string;

    constructor(data?: IIdealTeacher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startingHour = _data["startingHour"];
            this.startingMinute = _data["startingMinute"];
            this.endingHour = _data["endingHour"];
            this.endingMinute = _data["endingMinute"];
            this.teacherId = _data["teacherId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.teacherName = _data["teacherName"];
            this.mobileNumber = _data["mobileNumber"];
            this.profileImageUrl = _data["profileImageUrl"];
            this.subjectNames = _data["subjectNames"];
        }
    }

    static fromJS(data: any): IdealTeacher {
        data = typeof data === 'object' ? data : {};
        let result = new IdealTeacher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startingHour"] = this.startingHour;
        data["startingMinute"] = this.startingMinute;
        data["endingHour"] = this.endingHour;
        data["endingMinute"] = this.endingMinute;
        data["teacherId"] = this.teacherId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["teacherName"] = this.teacherName;
        data["mobileNumber"] = this.mobileNumber;
        data["profileImageUrl"] = this.profileImageUrl;
        data["subjectNames"] = this.subjectNames;
        return data;
    }

    clone(): IdealTeacher {
        const json = this.toJSON();
        let result = new IdealTeacher();
        result.init(json);
        return result;
    }
}

export interface IIdealTeacher {
    startingHour: number | undefined;
    startingMinute: number | undefined;
    endingHour: number | undefined;
    endingMinute: number | undefined;
    teacherId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    teacherName: string;
    mobileNumber: string;
    profileImageUrl: string;
    subjectNames: string;
}

export class TeacherDashboardCountDto implements ITeacherDashboardCountDto {
    girlsBoysCount!: GirlsBoysCount;
    attendancePercentage!: AttendancePercentage;

    constructor(data?: ITeacherDashboardCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.girlsBoysCount = _data["girlsBoysCount"] ? GirlsBoysCount.fromJS(_data["girlsBoysCount"]) : <any>undefined;
            this.attendancePercentage = _data["attendancePercentage"] ? AttendancePercentage.fromJS(_data["attendancePercentage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeacherDashboardCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDashboardCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["girlsBoysCount"] = this.girlsBoysCount ? this.girlsBoysCount.toJSON() : <any>undefined;
        data["attendancePercentage"] = this.attendancePercentage ? this.attendancePercentage.toJSON() : <any>undefined;
        return data;
    }

    clone(): TeacherDashboardCountDto {
        const json = this.toJSON();
        let result = new TeacherDashboardCountDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherDashboardCountDto {
    girlsBoysCount: GirlsBoysCount;
    attendancePercentage: AttendancePercentage;
}

export class ClerkDto implements IClerkDto {
    clerkId!: number | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    fullName!: string | undefined;
    gender!: string | undefined;
    contactNumber!: string | undefined;
    mobileNumber!: string | undefined;
    emailId!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    talukaId!: number | undefined;
    districtId!: number | undefined;
    stateId!: number | undefined;
    talukaName!: string | undefined;
    districtName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    adharNumber!: string | undefined;
    countryId!: number | undefined;
    zipCode!: string | undefined;
    address!: string | undefined;
    education!: string | undefined;
    bloodGroup!: string | undefined;
    profileImageURL!: string | undefined;
    userId!: number | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthDate!: moment.Moment | undefined;
    profileBase64Image!: string | undefined;
    profileImageContentType!: string | undefined;
    isAppAccess!: boolean | undefined;
    appAccessMobileNo!: string | undefined;
    appAccessOneTimePassword!: string | undefined;

    constructor(data?: IClerkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clerkId = _data["clerkId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.contactNumber = _data["contactNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.emailId = _data["emailId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.talukaId = _data["talukaId"];
            this.districtId = _data["districtId"];
            this.stateId = _data["stateId"];
            this.talukaName = _data["talukaName"];
            this.districtName = _data["districtName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.adharNumber = _data["adharNumber"];
            this.countryId = _data["countryId"];
            this.zipCode = _data["zipCode"];
            this.address = _data["address"];
            this.education = _data["education"];
            this.bloodGroup = _data["bloodGroup"];
            this.profileImageURL = _data["profileImageURL"];
            this.userId = _data["userId"];
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.profileBase64Image = _data["profileBase64Image"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.isAppAccess = _data["isAppAccess"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.appAccessOneTimePassword = _data["appAccessOneTimePassword"];
        }
    }

    static fromJS(data: any): ClerkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClerkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clerkId"] = this.clerkId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["contactNumber"] = this.contactNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["emailId"] = this.emailId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["talukaId"] = this.talukaId;
        data["districtId"] = this.districtId;
        data["stateId"] = this.stateId;
        data["talukaName"] = this.talukaName;
        data["districtName"] = this.districtName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["adharNumber"] = this.adharNumber;
        data["countryId"] = this.countryId;
        data["zipCode"] = this.zipCode;
        data["address"] = this.address;
        data["education"] = this.education;
        data["bloodGroup"] = this.bloodGroup;
        data["profileImageURL"] = this.profileImageURL;
        data["userId"] = this.userId;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["profileBase64Image"] = this.profileBase64Image;
        data["profileImageContentType"] = this.profileImageContentType;
        data["isAppAccess"] = this.isAppAccess;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["appAccessOneTimePassword"] = this.appAccessOneTimePassword;
        return data;
    }

    clone(): ClerkDto {
        const json = this.toJSON();
        let result = new ClerkDto();
        result.init(json);
        return result;
    }
}

export interface IClerkDto {
    clerkId: number | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    gender: string | undefined;
    contactNumber: string | undefined;
    mobileNumber: string | undefined;
    emailId: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    talukaId: number | undefined;
    districtId: number | undefined;
    stateId: number | undefined;
    talukaName: string | undefined;
    districtName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    adharNumber: string | undefined;
    countryId: number | undefined;
    zipCode: string | undefined;
    address: string | undefined;
    education: string | undefined;
    bloodGroup: string | undefined;
    profileImageURL: string | undefined;
    userId: number | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthDate: moment.Moment | undefined;
    profileBase64Image: string | undefined;
    profileImageContentType: string | undefined;
    isAppAccess: boolean | undefined;
    appAccessMobileNo: string | undefined;
    appAccessOneTimePassword: string | undefined;
}

export class ClerkDeleteRespose implements IClerkDeleteRespose {
    affectedRows!: number;

    constructor(data?: IClerkDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): ClerkDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new ClerkDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): ClerkDeleteRespose {
        const json = this.toJSON();
        let result = new ClerkDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IClerkDeleteRespose {
    affectedRows: number;
}

export class ClassTeacherResponseDto implements IClassTeacherResponseDto {
    classTeacherList!: ClassTeacherDto[];

    constructor(data?: IClassTeacherResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["classTeacherList"])) {
                this.classTeacherList = [] as any;
                for (let item of _data["classTeacherList"])
                    this.classTeacherList!.push(ClassTeacherDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassTeacherResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTeacherResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.classTeacherList)) {
            data["classTeacherList"] = [];
            for (let item of this.classTeacherList)
                data["classTeacherList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClassTeacherResponseDto {
        const json = this.toJSON();
        let result = new ClassTeacherResponseDto();
        result.init(json);
        return result;
    }
}

export interface IClassTeacherResponseDto {
    classTeacherList: ClassTeacherDto[];
}

export class ClassTeacherDto implements IClassTeacherDto {
    academicYearId!: number | undefined;
    id!: number | undefined;
    className!: string;
    classTeacherName!: string;

    constructor(data?: IClassTeacherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.id = _data["id"];
            this.className = _data["className"];
            this.classTeacherName = _data["classTeacherName"];
        }
    }

    static fromJS(data: any): ClassTeacherDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTeacherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["id"] = this.id;
        data["className"] = this.className;
        data["classTeacherName"] = this.classTeacherName;
        return data;
    }

    clone(): ClassTeacherDto {
        const json = this.toJSON();
        let result = new ClassTeacherDto();
        result.init(json);
        return result;
    }
}

export interface IClassTeacherDto {
    academicYearId: number | undefined;
    id: number | undefined;
    className: string;
    classTeacherName: string;
}

export class ClassWiseStudentResponseDto implements IClassWiseStudentResponseDto {
    classWiseStudentList!: ClassWiseStudentDto[];

    constructor(data?: IClassWiseStudentResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["classWiseStudentList"])) {
                this.classWiseStudentList = [] as any;
                for (let item of _data["classWiseStudentList"])
                    this.classWiseStudentList!.push(ClassWiseStudentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassWiseStudentResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassWiseStudentResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.classWiseStudentList)) {
            data["classWiseStudentList"] = [];
            for (let item of this.classWiseStudentList)
                data["classWiseStudentList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClassWiseStudentResponseDto {
        const json = this.toJSON();
        let result = new ClassWiseStudentResponseDto();
        result.init(json);
        return result;
    }
}

export interface IClassWiseStudentResponseDto {
    classWiseStudentList: ClassWiseStudentDto[];
}

export class ClassWiseStudentDto implements IClassWiseStudentDto {
    academicYearId!: number | undefined;
    classTeacherId!: number | undefined;
    studentId!: number | undefined;
    className!: string;
    fullName!: string;

    constructor(data?: IClassWiseStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.classTeacherId = _data["classTeacherId"];
            this.studentId = _data["studentId"];
            this.className = _data["className"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ClassWiseStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassWiseStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["classTeacherId"] = this.classTeacherId;
        data["studentId"] = this.studentId;
        data["className"] = this.className;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): ClassWiseStudentDto {
        const json = this.toJSON();
        let result = new ClassWiseStudentDto();
        result.init(json);
        return result;
    }
}

export interface IClassWiseStudentDto {
    academicYearId: number | undefined;
    classTeacherId: number | undefined;
    studentId: number | undefined;
    className: string;
    fullName: string;
}

export class ClassTimeTableSelectResponseDto implements IClassTimeTableSelectResponseDto {
    classId!: number | undefined;
    className!: string;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    gradeName!: string;
    divisionName!: string;
    classTimeTable!: ClassTimeTableDto[];

    constructor(data?: IClassTimeTableSelectResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.className = _data["className"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            if (Array.isArray(_data["classTimeTable"])) {
                this.classTimeTable = [] as any;
                for (let item of _data["classTimeTable"])
                    this.classTimeTable!.push(ClassTimeTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassTimeTableSelectResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTimeTableSelectResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["className"] = this.className;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        if (Array.isArray(this.classTimeTable)) {
            data["classTimeTable"] = [];
            for (let item of this.classTimeTable)
                data["classTimeTable"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClassTimeTableSelectResponseDto {
        const json = this.toJSON();
        let result = new ClassTimeTableSelectResponseDto();
        result.init(json);
        return result;
    }
}

export interface IClassTimeTableSelectResponseDto {
    classId: number | undefined;
    className: string;
    gradeId: number | undefined;
    divisionId: number | undefined;
    gradeName: string;
    divisionName: string;
    classTimeTable: ClassTimeTableDto[];
}

export class ClassTimeTableDto implements IClassTimeTableDto {
    classTimeTableId!: number;
    classId!: number;
    className!: string;
    classTimeTableName!: string;
    userId!: number;
    academicYearId!: number;
    isSkipTimeTableValidation!: boolean;
    lstClassTimeTableRow!: ClassTimeTableRowDetailDto[];
    isActive!: boolean;

    constructor(data?: IClassTimeTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classTimeTableId = _data["classTimeTableId"];
            this.classId = _data["classId"];
            this.className = _data["className"];
            this.classTimeTableName = _data["classTimeTableName"];
            this.userId = _data["userId"];
            this.academicYearId = _data["academicYearId"];
            this.isSkipTimeTableValidation = _data["isSkipTimeTableValidation"];
            if (Array.isArray(_data["lstClassTimeTableRow"])) {
                this.lstClassTimeTableRow = [] as any;
                for (let item of _data["lstClassTimeTableRow"])
                    this.lstClassTimeTableRow!.push(ClassTimeTableRowDetailDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ClassTimeTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTimeTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classTimeTableId"] = this.classTimeTableId;
        data["classId"] = this.classId;
        data["className"] = this.className;
        data["classTimeTableName"] = this.classTimeTableName;
        data["userId"] = this.userId;
        data["academicYearId"] = this.academicYearId;
        data["isSkipTimeTableValidation"] = this.isSkipTimeTableValidation;
        if (Array.isArray(this.lstClassTimeTableRow)) {
            data["lstClassTimeTableRow"] = [];
            for (let item of this.lstClassTimeTableRow)
                data["lstClassTimeTableRow"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ClassTimeTableDto {
        const json = this.toJSON();
        let result = new ClassTimeTableDto();
        result.init(json);
        return result;
    }
}

export interface IClassTimeTableDto {
    classTimeTableId: number;
    classId: number;
    className: string;
    classTimeTableName: string;
    userId: number;
    academicYearId: number;
    isSkipTimeTableValidation: boolean;
    lstClassTimeTableRow: ClassTimeTableRowDetailDto[];
    isActive: boolean;
}

export class ClassTimeTableRowDetailDto implements IClassTimeTableRowDetailDto {
    classTimeTableId!: number;
    periodTypeId!: number;
    startingHour!: number;
    startingMinute!: number;
    endingHour!: number;
    endingMinute!: number;
    sequenceId!: number;
    lstClassTimeTableColumn!: ClassTimeTableColumnDetailDto[];

    constructor(data?: IClassTimeTableRowDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classTimeTableId = _data["classTimeTableId"];
            this.periodTypeId = _data["periodTypeId"];
            this.startingHour = _data["startingHour"];
            this.startingMinute = _data["startingMinute"];
            this.endingHour = _data["endingHour"];
            this.endingMinute = _data["endingMinute"];
            this.sequenceId = _data["sequenceId"];
            if (Array.isArray(_data["lstClassTimeTableColumn"])) {
                this.lstClassTimeTableColumn = [] as any;
                for (let item of _data["lstClassTimeTableColumn"])
                    this.lstClassTimeTableColumn!.push(ClassTimeTableColumnDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassTimeTableRowDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTimeTableRowDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classTimeTableId"] = this.classTimeTableId;
        data["periodTypeId"] = this.periodTypeId;
        data["startingHour"] = this.startingHour;
        data["startingMinute"] = this.startingMinute;
        data["endingHour"] = this.endingHour;
        data["endingMinute"] = this.endingMinute;
        data["sequenceId"] = this.sequenceId;
        if (Array.isArray(this.lstClassTimeTableColumn)) {
            data["lstClassTimeTableColumn"] = [];
            for (let item of this.lstClassTimeTableColumn)
                data["lstClassTimeTableColumn"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClassTimeTableRowDetailDto {
        const json = this.toJSON();
        let result = new ClassTimeTableRowDetailDto();
        result.init(json);
        return result;
    }
}

export interface IClassTimeTableRowDetailDto {
    classTimeTableId: number;
    periodTypeId: number;
    startingHour: number;
    startingMinute: number;
    endingHour: number;
    endingMinute: number;
    sequenceId: number;
    lstClassTimeTableColumn: ClassTimeTableColumnDetailDto[];
}

export class ClassTimeTableColumnDetailDto implements IClassTimeTableColumnDetailDto {
    classTimeTableId!: number;
    day!: number;
    dayName!: string;
    subjectId!: number | undefined;
    subjectName!: string;
    teacherName!: string;
    teacherId!: number | undefined;
    sequenceId!: number;
    className!: string;

    constructor(data?: IClassTimeTableColumnDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classTimeTableId = _data["classTimeTableId"];
            this.day = _data["day"];
            this.dayName = _data["dayName"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.teacherName = _data["teacherName"];
            this.teacherId = _data["teacherId"];
            this.sequenceId = _data["sequenceId"];
            this.className = _data["className"];
        }
    }

    static fromJS(data: any): ClassTimeTableColumnDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTimeTableColumnDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classTimeTableId"] = this.classTimeTableId;
        data["day"] = this.day;
        data["dayName"] = this.dayName;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["teacherName"] = this.teacherName;
        data["teacherId"] = this.teacherId;
        data["sequenceId"] = this.sequenceId;
        data["className"] = this.className;
        return data;
    }

    clone(): ClassTimeTableColumnDetailDto {
        const json = this.toJSON();
        let result = new ClassTimeTableColumnDetailDto();
        result.init(json);
        return result;
    }
}

export interface IClassTimeTableColumnDetailDto {
    classTimeTableId: number;
    day: number;
    dayName: string;
    subjectId: number | undefined;
    subjectName: string;
    teacherName: string;
    teacherId: number | undefined;
    sequenceId: number;
    className: string;
}

export class CreateTimeTableResponse implements ICreateTimeTableResponse {
    isSuccess!: boolean;
    lstOverlapPeriod!: TeacherOverlapComparisonErrorDto[];

    constructor(data?: ICreateTimeTableResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["lstOverlapPeriod"])) {
                this.lstOverlapPeriod = [] as any;
                for (let item of _data["lstOverlapPeriod"])
                    this.lstOverlapPeriod!.push(TeacherOverlapComparisonErrorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateTimeTableResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTimeTableResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.lstOverlapPeriod)) {
            data["lstOverlapPeriod"] = [];
            for (let item of this.lstOverlapPeriod)
                data["lstOverlapPeriod"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateTimeTableResponse {
        const json = this.toJSON();
        let result = new CreateTimeTableResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateTimeTableResponse {
    isSuccess: boolean;
    lstOverlapPeriod: TeacherOverlapComparisonErrorDto[];
}

export class TeacherOverlapComparisonErrorDto implements ITeacherOverlapComparisonErrorDto {
    teacherId!: number | undefined;
    teacherName!: string;
    day!: number;
    dayName!: string;
    subjectIdToSave!: number;
    subjectNameToSave!: string;
    existingSubjectId!: number;
    existingSubjectName!: string;
    startingHour!: number;
    startingMinute!: number;
    endingHour!: number;
    endingMinute!: number;
    className!: string;

    constructor(data?: ITeacherOverlapComparisonErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            this.teacherName = _data["teacherName"];
            this.day = _data["day"];
            this.dayName = _data["dayName"];
            this.subjectIdToSave = _data["subjectIdToSave"];
            this.subjectNameToSave = _data["subjectNameToSave"];
            this.existingSubjectId = _data["existingSubjectId"];
            this.existingSubjectName = _data["existingSubjectName"];
            this.startingHour = _data["startingHour"];
            this.startingMinute = _data["startingMinute"];
            this.endingHour = _data["endingHour"];
            this.endingMinute = _data["endingMinute"];
            this.className = _data["className"];
        }
    }

    static fromJS(data: any): TeacherOverlapComparisonErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherOverlapComparisonErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        data["teacherName"] = this.teacherName;
        data["day"] = this.day;
        data["dayName"] = this.dayName;
        data["subjectIdToSave"] = this.subjectIdToSave;
        data["subjectNameToSave"] = this.subjectNameToSave;
        data["existingSubjectId"] = this.existingSubjectId;
        data["existingSubjectName"] = this.existingSubjectName;
        data["startingHour"] = this.startingHour;
        data["startingMinute"] = this.startingMinute;
        data["endingHour"] = this.endingHour;
        data["endingMinute"] = this.endingMinute;
        data["className"] = this.className;
        return data;
    }

    clone(): TeacherOverlapComparisonErrorDto {
        const json = this.toJSON();
        let result = new TeacherOverlapComparisonErrorDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherOverlapComparisonErrorDto {
    teacherId: number | undefined;
    teacherName: string;
    day: number;
    dayName: string;
    subjectIdToSave: number;
    subjectNameToSave: string;
    existingSubjectId: number;
    existingSubjectName: string;
    startingHour: number;
    startingMinute: number;
    endingHour: number;
    endingMinute: number;
    className: string;
}

export class TeacherClassTimeTableRequestDto implements ITeacherClassTimeTableRequestDto {
    teacherId!: number;
    classId!: number[];
    academicYearId!: number;

    constructor(data?: ITeacherClassTimeTableRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): TeacherClassTimeTableRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherClassTimeTableRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        data["academicYearId"] = this.academicYearId;
        return data;
    }

    clone(): TeacherClassTimeTableRequestDto {
        const json = this.toJSON();
        let result = new TeacherClassTimeTableRequestDto();
        result.init(json);
        return result;
    }
}

export interface ITeacherClassTimeTableRequestDto {
    teacherId: number;
    classId: number[];
    academicYearId: number;
}

export class StudentClassTimeTableRequestDto implements IStudentClassTimeTableRequestDto {
    classId!: number;
    academicYearId!: number;

    constructor(data?: IStudentClassTimeTableRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): StudentClassTimeTableRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentClassTimeTableRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["academicYearId"] = this.academicYearId;
        return data;
    }

    clone(): StudentClassTimeTableRequestDto {
        const json = this.toJSON();
        let result = new StudentClassTimeTableRequestDto();
        result.init(json);
        return result;
    }
}

export interface IStudentClassTimeTableRequestDto {
    classId: number;
    academicYearId: number;
}

export class MarkTimeTableActiveRequestModel implements IMarkTimeTableActiveRequestModel {
    lstActiveTimeTableId!: MarkTimeTableActiveSelectModel[];

    constructor(data?: IMarkTimeTableActiveRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstActiveTimeTableId"])) {
                this.lstActiveTimeTableId = [] as any;
                for (let item of _data["lstActiveTimeTableId"])
                    this.lstActiveTimeTableId!.push(MarkTimeTableActiveSelectModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MarkTimeTableActiveRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MarkTimeTableActiveRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstActiveTimeTableId)) {
            data["lstActiveTimeTableId"] = [];
            for (let item of this.lstActiveTimeTableId)
                data["lstActiveTimeTableId"].push(item.toJSON());
        }
        return data;
    }

    clone(): MarkTimeTableActiveRequestModel {
        const json = this.toJSON();
        let result = new MarkTimeTableActiveRequestModel();
        result.init(json);
        return result;
    }
}

export interface IMarkTimeTableActiveRequestModel {
    lstActiveTimeTableId: MarkTimeTableActiveSelectModel[];
}

export class MarkTimeTableActiveSelectModel implements IMarkTimeTableActiveSelectModel {
    classTimeTableId!: number;
    isActive!: boolean;

    constructor(data?: IMarkTimeTableActiveSelectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classTimeTableId = _data["classTimeTableId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): MarkTimeTableActiveSelectModel {
        data = typeof data === 'object' ? data : {};
        let result = new MarkTimeTableActiveSelectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classTimeTableId"] = this.classTimeTableId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): MarkTimeTableActiveSelectModel {
        const json = this.toJSON();
        let result = new MarkTimeTableActiveSelectModel();
        result.init(json);
        return result;
    }
}

export interface IMarkTimeTableActiveSelectModel {
    classTimeTableId: number;
    isActive: boolean;
}

export class ClassTeacherDataDto implements IClassTeacherDataDto {
    getGradeDivisionList!: ClassTeacherListDto[] | undefined;

    constructor(data?: IClassTeacherDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getGradeDivisionList"])) {
                this.getGradeDivisionList = [] as any;
                for (let item of _data["getGradeDivisionList"])
                    this.getGradeDivisionList!.push(ClassTeacherListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassTeacherDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTeacherDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getGradeDivisionList)) {
            data["getGradeDivisionList"] = [];
            for (let item of this.getGradeDivisionList)
                data["getGradeDivisionList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClassTeacherDataDto {
        const json = this.toJSON();
        let result = new ClassTeacherDataDto();
        result.init(json);
        return result;
    }
}

export interface IClassTeacherDataDto {
    getGradeDivisionList: ClassTeacherListDto[] | undefined;
}

export class ClassTeacherListDto implements IClassTeacherListDto {
    gradeId!: number;
    divisionId!: number;

    constructor(data?: IClassTeacherListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
        }
    }

    static fromJS(data: any): ClassTeacherListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTeacherListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        return data;
    }

    clone(): ClassTeacherListDto {
        const json = this.toJSON();
        let result = new ClassTeacherListDto();
        result.init(json);
        return result;
    }
}

export interface IClassTeacherListDto {
    gradeId: number;
    divisionId: number;
}

export class CertificateDto implements ICertificateDto {
    bonafiedDetails!: BonafiedDto;
    leavingCertificateDetails!: LeavingCertificateDto;
    characterCertificateDetails!: CharacterCertificateDto;
    idCardDetails!: IdCardDto;
    certificateAuditDetails!: CertificateAuditDto;
    certificateIdModelResponse!: CertificateIdModelResponse;

    constructor(data?: ICertificateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bonafiedDetails = _data["bonafiedDetails"] ? BonafiedDto.fromJS(_data["bonafiedDetails"]) : <any>undefined;
            this.leavingCertificateDetails = _data["leavingCertificateDetails"] ? LeavingCertificateDto.fromJS(_data["leavingCertificateDetails"]) : <any>undefined;
            this.characterCertificateDetails = _data["characterCertificateDetails"] ? CharacterCertificateDto.fromJS(_data["characterCertificateDetails"]) : <any>undefined;
            this.idCardDetails = _data["idCardDetails"] ? IdCardDto.fromJS(_data["idCardDetails"]) : <any>undefined;
            this.certificateAuditDetails = _data["certificateAuditDetails"] ? CertificateAuditDto.fromJS(_data["certificateAuditDetails"]) : <any>undefined;
            this.certificateIdModelResponse = _data["certificateIdModelResponse"] ? CertificateIdModelResponse.fromJS(_data["certificateIdModelResponse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CertificateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bonafiedDetails"] = this.bonafiedDetails ? this.bonafiedDetails.toJSON() : <any>undefined;
        data["leavingCertificateDetails"] = this.leavingCertificateDetails ? this.leavingCertificateDetails.toJSON() : <any>undefined;
        data["characterCertificateDetails"] = this.characterCertificateDetails ? this.characterCertificateDetails.toJSON() : <any>undefined;
        data["idCardDetails"] = this.idCardDetails ? this.idCardDetails.toJSON() : <any>undefined;
        data["certificateAuditDetails"] = this.certificateAuditDetails ? this.certificateAuditDetails.toJSON() : <any>undefined;
        data["certificateIdModelResponse"] = this.certificateIdModelResponse ? this.certificateIdModelResponse.toJSON() : <any>undefined;
        return data;
    }

    clone(): CertificateDto {
        const json = this.toJSON();
        let result = new CertificateDto();
        result.init(json);
        return result;
    }
}

export interface ICertificateDto {
    bonafiedDetails: BonafiedDto;
    leavingCertificateDetails: LeavingCertificateDto;
    characterCertificateDetails: CharacterCertificateDto;
    idCardDetails: IdCardDto;
    certificateAuditDetails: CertificateAuditDto;
    certificateIdModelResponse: CertificateIdModelResponse;
}

export class BonafiedDto implements IBonafiedDto {
    schoolName!: string;
    schoolContactNo1!: string;
    schoolEmail!: string;
    affiliationNumber!: string;
    schoolPermission!: string;
    registrationNumber!: string;
    section!: string;
    schoolType!: string;
    logoUrl!: string;
    schoolLogoUrl!: string;
    studentLogoUrl!: string;
    schoolMediumId!: number;
    name!: string;
    divisionName!: string;
    gradeName!: string;
    category!: string;
    cast!: string;
    subCast!: string;
    gender!: string;
    birthDate!: moment.Moment;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthTalukaName!: string;
    birthPlace!: string;
    birthDistrictName!: string;
    birthStateName!: string;
    generalRegistrationNo!: string;
    schoolProfileImage!: string;
    schoolProfileImageContentType!: string;
    profileImage!: string;
    profileImageUrl!: string;
    profileImageContentType!: string;
    academicYearKey!: string;

    constructor(data?: IBonafiedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.schoolContactNo1 = _data["schoolContactNo1"];
            this.schoolEmail = _data["schoolEmail"];
            this.affiliationNumber = _data["affiliationNumber"];
            this.schoolPermission = _data["schoolPermission"];
            this.registrationNumber = _data["registrationNumber"];
            this.section = _data["section"];
            this.schoolType = _data["schoolType"];
            this.logoUrl = _data["logoUrl"];
            this.schoolLogoUrl = _data["schoolLogoUrl"];
            this.studentLogoUrl = _data["studentLogoUrl"];
            this.schoolMediumId = _data["schoolMediumId"];
            this.name = _data["name"];
            this.divisionName = _data["divisionName"];
            this.gradeName = _data["gradeName"];
            this.category = _data["category"];
            this.cast = _data["cast"];
            this.subCast = _data["subCast"];
            this.gender = _data["gender"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthTalukaName = _data["birthTalukaName"];
            this.birthPlace = _data["birthPlace"];
            this.birthDistrictName = _data["birthDistrictName"];
            this.birthStateName = _data["birthStateName"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.schoolProfileImage = _data["schoolProfileImage"];
            this.schoolProfileImageContentType = _data["schoolProfileImageContentType"];
            this.profileImage = _data["profileImage"];
            this.profileImageUrl = _data["profileImageUrl"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.academicYearKey = _data["academicYearKey"];
        }
    }

    static fromJS(data: any): BonafiedDto {
        data = typeof data === 'object' ? data : {};
        let result = new BonafiedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["schoolContactNo1"] = this.schoolContactNo1;
        data["schoolEmail"] = this.schoolEmail;
        data["affiliationNumber"] = this.affiliationNumber;
        data["schoolPermission"] = this.schoolPermission;
        data["registrationNumber"] = this.registrationNumber;
        data["section"] = this.section;
        data["schoolType"] = this.schoolType;
        data["logoUrl"] = this.logoUrl;
        data["schoolLogoUrl"] = this.schoolLogoUrl;
        data["studentLogoUrl"] = this.studentLogoUrl;
        data["schoolMediumId"] = this.schoolMediumId;
        data["name"] = this.name;
        data["divisionName"] = this.divisionName;
        data["gradeName"] = this.gradeName;
        data["category"] = this.category;
        data["cast"] = this.cast;
        data["subCast"] = this.subCast;
        data["gender"] = this.gender;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthTalukaName"] = this.birthTalukaName;
        data["birthPlace"] = this.birthPlace;
        data["birthDistrictName"] = this.birthDistrictName;
        data["birthStateName"] = this.birthStateName;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["schoolProfileImage"] = this.schoolProfileImage;
        data["schoolProfileImageContentType"] = this.schoolProfileImageContentType;
        data["profileImage"] = this.profileImage;
        data["profileImageUrl"] = this.profileImageUrl;
        data["profileImageContentType"] = this.profileImageContentType;
        data["academicYearKey"] = this.academicYearKey;
        return data;
    }

    clone(): BonafiedDto {
        const json = this.toJSON();
        let result = new BonafiedDto();
        result.init(json);
        return result;
    }
}

export interface IBonafiedDto {
    schoolName: string;
    schoolContactNo1: string;
    schoolEmail: string;
    affiliationNumber: string;
    schoolPermission: string;
    registrationNumber: string;
    section: string;
    schoolType: string;
    logoUrl: string;
    schoolLogoUrl: string;
    studentLogoUrl: string;
    schoolMediumId: number;
    name: string;
    divisionName: string;
    gradeName: string;
    category: string;
    cast: string;
    subCast: string;
    gender: string;
    birthDate: moment.Moment;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthTalukaName: string;
    birthPlace: string;
    birthDistrictName: string;
    birthStateName: string;
    generalRegistrationNo: string;
    schoolProfileImage: string;
    schoolProfileImageContentType: string;
    profileImage: string;
    profileImageUrl: string;
    profileImageContentType: string;
    academicYearKey: string;
}

export class LeavingCertificateDto implements ILeavingCertificateDto {
    schoolName!: string;
    schoolContactNo1!: string;
    schoolEmail!: string;
    affiliationNumber!: string;
    schoolPermission!: string;
    registrationNumber!: string;
    cbscStudentId!: string;
    udiseNumber!: string;
    section!: string;
    logoUrl!: string;
    schoolLogoUrl!: string;
    studentLogoUrl!: string;
    authorisedBy!: string;
    logoImage!: string;
    logoImageContentType!: string;
    board!: string;
    cast!: string;
    subCast!: string;
    generalRegistrationNo!: string;
    studentId!: number;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    adharNo!: string;
    hscOrSSCIndexNo!: string;
    schoolMediumTypeName!: string;
    motherName!: string;
    nationality!: string;
    religion!: string;
    birthDate!: moment.Moment | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthTalukaName!: string;
    birthPlace!: string;
    birthDistrictName!: string;
    birthStateName!: string;
    birthDateInWords!: string;
    birthCountryName!: string;
    lastSchoolAttended!: string;
    lastSchoolStandard!: string;
    dateOfAdmission!: moment.Moment | undefined;
    ngbDateOfAdmission!: SchoolNgbDateModel | undefined;
    gradeName!: string;
    gradeNameAdmission!: string;
    reasonOfLeavingLastSchool!: string;
    motherTounge!: string;
    dateOfLeavingLastSchool!: moment.Moment | undefined;
    ngbDateOfLeavingLastSchool!: SchoolNgbDateModel | undefined;
    serialNumber!: number | undefined;
    ngbDateOfLeavingSchoolCurrent!: SchoolNgbDateModel | undefined;
    dateOfLeavingSchoolCurrent!: moment.Moment | undefined;
    ngbDateSignCurrent!: SchoolNgbDateModel | undefined;
    dateSignCurrent!: moment.Moment | undefined;
    conductCurrent!: string;
    progressCurrent!: string;
    standardInWhichStudyingCurrent!: string;
    reasonOfLeavingSchoolCurrent!: string;
    remarkCurrent!: string;
    gradeId!: number;
    divisionId!: number;
    statusId!: number | undefined;
    leavingCertificateAuditsId!: number | undefined;

    constructor(data?: ILeavingCertificateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.schoolContactNo1 = _data["schoolContactNo1"];
            this.schoolEmail = _data["schoolEmail"];
            this.affiliationNumber = _data["affiliationNumber"];
            this.schoolPermission = _data["schoolPermission"];
            this.registrationNumber = _data["registrationNumber"];
            this.cbscStudentId = _data["cbscStudentId"];
            this.udiseNumber = _data["udiseNumber"];
            this.section = _data["section"];
            this.logoUrl = _data["logoUrl"];
            this.schoolLogoUrl = _data["schoolLogoUrl"];
            this.studentLogoUrl = _data["studentLogoUrl"];
            this.authorisedBy = _data["authorisedBy"];
            this.logoImage = _data["logoImage"];
            this.logoImageContentType = _data["logoImageContentType"];
            this.board = _data["board"];
            this.cast = _data["cast"];
            this.subCast = _data["subCast"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.studentId = _data["studentId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.adharNo = _data["adharNo"];
            this.hscOrSSCIndexNo = _data["hscOrSSCIndexNo"];
            this.schoolMediumTypeName = _data["schoolMediumTypeName"];
            this.motherName = _data["motherName"];
            this.nationality = _data["nationality"];
            this.religion = _data["religion"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthTalukaName = _data["birthTalukaName"];
            this.birthPlace = _data["birthPlace"];
            this.birthDistrictName = _data["birthDistrictName"];
            this.birthStateName = _data["birthStateName"];
            this.birthDateInWords = _data["birthDateInWords"];
            this.birthCountryName = _data["birthCountryName"];
            this.lastSchoolAttended = _data["lastSchoolAttended"];
            this.lastSchoolStandard = _data["lastSchoolStandard"];
            this.dateOfAdmission = _data["dateOfAdmission"] ? moment(_data["dateOfAdmission"].toString()) : <any>undefined;
            this.ngbDateOfAdmission = _data["ngbDateOfAdmission"] ? SchoolNgbDateModel.fromJS(_data["ngbDateOfAdmission"]) : <any>undefined;
            this.gradeName = _data["gradeName"];
            this.gradeNameAdmission = _data["gradeNameAdmission"];
            this.reasonOfLeavingLastSchool = _data["reasonOfLeavingLastSchool"];
            this.motherTounge = _data["motherTounge"];
            this.dateOfLeavingLastSchool = _data["dateOfLeavingLastSchool"] ? moment(_data["dateOfLeavingLastSchool"].toString()) : <any>undefined;
            this.ngbDateOfLeavingLastSchool = _data["ngbDateOfLeavingLastSchool"] ? SchoolNgbDateModel.fromJS(_data["ngbDateOfLeavingLastSchool"]) : <any>undefined;
            this.serialNumber = _data["serialNumber"];
            this.ngbDateOfLeavingSchoolCurrent = _data["ngbDateOfLeavingSchoolCurrent"] ? SchoolNgbDateModel.fromJS(_data["ngbDateOfLeavingSchoolCurrent"]) : <any>undefined;
            this.dateOfLeavingSchoolCurrent = _data["dateOfLeavingSchoolCurrent"] ? moment(_data["dateOfLeavingSchoolCurrent"].toString()) : <any>undefined;
            this.ngbDateSignCurrent = _data["ngbDateSignCurrent"] ? SchoolNgbDateModel.fromJS(_data["ngbDateSignCurrent"]) : <any>undefined;
            this.dateSignCurrent = _data["dateSignCurrent"] ? moment(_data["dateSignCurrent"].toString()) : <any>undefined;
            this.conductCurrent = _data["conductCurrent"];
            this.progressCurrent = _data["progressCurrent"];
            this.standardInWhichStudyingCurrent = _data["standardInWhichStudyingCurrent"];
            this.reasonOfLeavingSchoolCurrent = _data["reasonOfLeavingSchoolCurrent"];
            this.remarkCurrent = _data["remarkCurrent"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.statusId = _data["statusId"];
            this.leavingCertificateAuditsId = _data["leavingCertificateAuditsId"];
        }
    }

    static fromJS(data: any): LeavingCertificateDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeavingCertificateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["schoolContactNo1"] = this.schoolContactNo1;
        data["schoolEmail"] = this.schoolEmail;
        data["affiliationNumber"] = this.affiliationNumber;
        data["schoolPermission"] = this.schoolPermission;
        data["registrationNumber"] = this.registrationNumber;
        data["cbscStudentId"] = this.cbscStudentId;
        data["udiseNumber"] = this.udiseNumber;
        data["section"] = this.section;
        data["logoUrl"] = this.logoUrl;
        data["schoolLogoUrl"] = this.schoolLogoUrl;
        data["studentLogoUrl"] = this.studentLogoUrl;
        data["authorisedBy"] = this.authorisedBy;
        data["logoImage"] = this.logoImage;
        data["logoImageContentType"] = this.logoImageContentType;
        data["board"] = this.board;
        data["cast"] = this.cast;
        data["subCast"] = this.subCast;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["studentId"] = this.studentId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["adharNo"] = this.adharNo;
        data["hscOrSSCIndexNo"] = this.hscOrSSCIndexNo;
        data["schoolMediumTypeName"] = this.schoolMediumTypeName;
        data["motherName"] = this.motherName;
        data["nationality"] = this.nationality;
        data["religion"] = this.religion;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthTalukaName"] = this.birthTalukaName;
        data["birthPlace"] = this.birthPlace;
        data["birthDistrictName"] = this.birthDistrictName;
        data["birthStateName"] = this.birthStateName;
        data["birthDateInWords"] = this.birthDateInWords;
        data["birthCountryName"] = this.birthCountryName;
        data["lastSchoolAttended"] = this.lastSchoolAttended;
        data["lastSchoolStandard"] = this.lastSchoolStandard;
        data["dateOfAdmission"] = this.dateOfAdmission ? this.dateOfAdmission.toISOString() : <any>undefined;
        data["ngbDateOfAdmission"] = this.ngbDateOfAdmission ? this.ngbDateOfAdmission.toJSON() : <any>undefined;
        data["gradeName"] = this.gradeName;
        data["gradeNameAdmission"] = this.gradeNameAdmission;
        data["reasonOfLeavingLastSchool"] = this.reasonOfLeavingLastSchool;
        data["motherTounge"] = this.motherTounge;
        data["dateOfLeavingLastSchool"] = this.dateOfLeavingLastSchool ? this.dateOfLeavingLastSchool.toISOString() : <any>undefined;
        data["ngbDateOfLeavingLastSchool"] = this.ngbDateOfLeavingLastSchool ? this.ngbDateOfLeavingLastSchool.toJSON() : <any>undefined;
        data["serialNumber"] = this.serialNumber;
        data["ngbDateOfLeavingSchoolCurrent"] = this.ngbDateOfLeavingSchoolCurrent ? this.ngbDateOfLeavingSchoolCurrent.toJSON() : <any>undefined;
        data["dateOfLeavingSchoolCurrent"] = this.dateOfLeavingSchoolCurrent ? this.dateOfLeavingSchoolCurrent.toISOString() : <any>undefined;
        data["ngbDateSignCurrent"] = this.ngbDateSignCurrent ? this.ngbDateSignCurrent.toJSON() : <any>undefined;
        data["dateSignCurrent"] = this.dateSignCurrent ? this.dateSignCurrent.toISOString() : <any>undefined;
        data["conductCurrent"] = this.conductCurrent;
        data["progressCurrent"] = this.progressCurrent;
        data["standardInWhichStudyingCurrent"] = this.standardInWhichStudyingCurrent;
        data["reasonOfLeavingSchoolCurrent"] = this.reasonOfLeavingSchoolCurrent;
        data["remarkCurrent"] = this.remarkCurrent;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["statusId"] = this.statusId;
        data["leavingCertificateAuditsId"] = this.leavingCertificateAuditsId;
        return data;
    }

    clone(): LeavingCertificateDto {
        const json = this.toJSON();
        let result = new LeavingCertificateDto();
        result.init(json);
        return result;
    }
}

export interface ILeavingCertificateDto {
    schoolName: string;
    schoolContactNo1: string;
    schoolEmail: string;
    affiliationNumber: string;
    schoolPermission: string;
    registrationNumber: string;
    cbscStudentId: string;
    udiseNumber: string;
    section: string;
    logoUrl: string;
    schoolLogoUrl: string;
    studentLogoUrl: string;
    authorisedBy: string;
    logoImage: string;
    logoImageContentType: string;
    board: string;
    cast: string;
    subCast: string;
    generalRegistrationNo: string;
    studentId: number;
    firstName: string;
    middleName: string;
    lastName: string;
    adharNo: string;
    hscOrSSCIndexNo: string;
    schoolMediumTypeName: string;
    motherName: string;
    nationality: string;
    religion: string;
    birthDate: moment.Moment | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthTalukaName: string;
    birthPlace: string;
    birthDistrictName: string;
    birthStateName: string;
    birthDateInWords: string;
    birthCountryName: string;
    lastSchoolAttended: string;
    lastSchoolStandard: string;
    dateOfAdmission: moment.Moment | undefined;
    ngbDateOfAdmission: SchoolNgbDateModel | undefined;
    gradeName: string;
    gradeNameAdmission: string;
    reasonOfLeavingLastSchool: string;
    motherTounge: string;
    dateOfLeavingLastSchool: moment.Moment | undefined;
    ngbDateOfLeavingLastSchool: SchoolNgbDateModel | undefined;
    serialNumber: number | undefined;
    ngbDateOfLeavingSchoolCurrent: SchoolNgbDateModel | undefined;
    dateOfLeavingSchoolCurrent: moment.Moment | undefined;
    ngbDateSignCurrent: SchoolNgbDateModel | undefined;
    dateSignCurrent: moment.Moment | undefined;
    conductCurrent: string;
    progressCurrent: string;
    standardInWhichStudyingCurrent: string;
    reasonOfLeavingSchoolCurrent: string;
    remarkCurrent: string;
    gradeId: number;
    divisionId: number;
    statusId: number | undefined;
    leavingCertificateAuditsId: number | undefined;
}

export class CharacterCertificateDto implements ICharacterCertificateDto {
    studentId!: number;
    schoolName!: string;
    studentName!: string;
    gender!: string;
    parentName!: string;
    place!: string;
    schoolLogoUrl!: string;
    studentLogoUrl!: string;
    totalDayCount!: string;
    studentAddress!: string;

    constructor(data?: ICharacterCertificateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.schoolName = _data["schoolName"];
            this.studentName = _data["studentName"];
            this.gender = _data["gender"];
            this.parentName = _data["parentName"];
            this.place = _data["place"];
            this.schoolLogoUrl = _data["schoolLogoUrl"];
            this.studentLogoUrl = _data["studentLogoUrl"];
            this.totalDayCount = _data["totalDayCount"];
            this.studentAddress = _data["studentAddress"];
        }
    }

    static fromJS(data: any): CharacterCertificateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterCertificateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["schoolName"] = this.schoolName;
        data["studentName"] = this.studentName;
        data["gender"] = this.gender;
        data["parentName"] = this.parentName;
        data["place"] = this.place;
        data["schoolLogoUrl"] = this.schoolLogoUrl;
        data["studentLogoUrl"] = this.studentLogoUrl;
        data["totalDayCount"] = this.totalDayCount;
        data["studentAddress"] = this.studentAddress;
        return data;
    }

    clone(): CharacterCertificateDto {
        const json = this.toJSON();
        let result = new CharacterCertificateDto();
        result.init(json);
        return result;
    }
}

export interface ICharacterCertificateDto {
    studentId: number;
    schoolName: string;
    studentName: string;
    gender: string;
    parentName: string;
    place: string;
    schoolLogoUrl: string;
    studentLogoUrl: string;
    totalDayCount: string;
    studentAddress: string;
}

export class IdCardDto implements IIdCardDto {
    schoolName!: string;
    academicYearName!: string;
    name!: string;
    birthDate!: moment.Moment;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    bloodGroup!: string;
    address!: string;
    divisionName!: string;
    gradeName!: string;
    emergencyContactNumber!: string;
    profileImageUrl!: string;
    logoUrl!: string;
    schoolLogoUrl!: string;
    studentLogoUrl!: string;
    profileImage!: string;
    logoImage!: string;
    profileImageContentType!: string;
    logoImageContentType!: string;

    constructor(data?: IIdCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.academicYearName = _data["academicYearName"];
            this.name = _data["name"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.bloodGroup = _data["bloodGroup"];
            this.address = _data["address"];
            this.divisionName = _data["divisionName"];
            this.gradeName = _data["gradeName"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.profileImageUrl = _data["profileImageUrl"];
            this.logoUrl = _data["logoUrl"];
            this.schoolLogoUrl = _data["schoolLogoUrl"];
            this.studentLogoUrl = _data["studentLogoUrl"];
            this.profileImage = _data["profileImage"];
            this.logoImage = _data["logoImage"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.logoImageContentType = _data["logoImageContentType"];
        }
    }

    static fromJS(data: any): IdCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["academicYearName"] = this.academicYearName;
        data["name"] = this.name;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["bloodGroup"] = this.bloodGroup;
        data["address"] = this.address;
        data["divisionName"] = this.divisionName;
        data["gradeName"] = this.gradeName;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["profileImageUrl"] = this.profileImageUrl;
        data["logoUrl"] = this.logoUrl;
        data["schoolLogoUrl"] = this.schoolLogoUrl;
        data["studentLogoUrl"] = this.studentLogoUrl;
        data["profileImage"] = this.profileImage;
        data["logoImage"] = this.logoImage;
        data["profileImageContentType"] = this.profileImageContentType;
        data["logoImageContentType"] = this.logoImageContentType;
        return data;
    }

    clone(): IdCardDto {
        const json = this.toJSON();
        let result = new IdCardDto();
        result.init(json);
        return result;
    }
}

export interface IIdCardDto {
    schoolName: string;
    academicYearName: string;
    name: string;
    birthDate: moment.Moment;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    bloodGroup: string;
    address: string;
    divisionName: string;
    gradeName: string;
    emergencyContactNumber: string;
    profileImageUrl: string;
    logoUrl: string;
    schoolLogoUrl: string;
    studentLogoUrl: string;
    profileImage: string;
    logoImage: string;
    profileImageContentType: string;
    logoImageContentType: string;
}

export class CertificateAuditDto implements ICertificateAuditDto {
    certificateAuditsId!: number | undefined;
    certificateTemplateId!: number | undefined;
    studentId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    academicYearId!: number | undefined;
    isPublished!: boolean | undefined;
    remark!: string | undefined;

    constructor(data?: ICertificateAuditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificateAuditsId = _data["certificateAuditsId"];
            this.certificateTemplateId = _data["certificateTemplateId"];
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.isPublished = _data["isPublished"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): CertificateAuditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateAuditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificateAuditsId"] = this.certificateAuditsId;
        data["certificateTemplateId"] = this.certificateTemplateId;
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["isPublished"] = this.isPublished;
        data["remark"] = this.remark;
        return data;
    }

    clone(): CertificateAuditDto {
        const json = this.toJSON();
        let result = new CertificateAuditDto();
        result.init(json);
        return result;
    }
}

export interface ICertificateAuditDto {
    certificateAuditsId: number | undefined;
    certificateTemplateId: number | undefined;
    studentId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    academicYearId: number | undefined;
    isPublished: boolean | undefined;
    remark: string | undefined;
}

export class CertificateIdModelResponse implements ICertificateIdModelResponse {
    certificateAuditsId!: number | undefined;
    studentId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;

    constructor(data?: ICertificateIdModelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificateAuditsId = _data["certificateAuditsId"];
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
        }
    }

    static fromJS(data: any): CertificateIdModelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateIdModelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificateAuditsId"] = this.certificateAuditsId;
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        return data;
    }

    clone(): CertificateIdModelResponse {
        const json = this.toJSON();
        let result = new CertificateIdModelResponse();
        result.init(json);
        return result;
    }
}

export interface ICertificateIdModelResponse {
    certificateAuditsId: number | undefined;
    studentId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
}

export class StudentNameModelResponse implements IStudentNameModelResponse {
    studentNames!: StudentNameDto[];

    constructor(data?: IStudentNameModelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentNames"])) {
                this.studentNames = [] as any;
                for (let item of _data["studentNames"])
                    this.studentNames!.push(StudentNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentNameModelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StudentNameModelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentNames)) {
            data["studentNames"] = [];
            for (let item of this.studentNames)
                data["studentNames"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentNameModelResponse {
        const json = this.toJSON();
        let result = new StudentNameModelResponse();
        result.init(json);
        return result;
    }
}

export interface IStudentNameModelResponse {
    studentNames: StudentNameDto[];
}

export class StudentNameDto implements IStudentNameDto {
    studentId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    academicYearId!: number | undefined;
    fullName!: string | undefined;

    constructor(data?: IStudentNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.academicYearId = _data["academicYearId"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): StudentNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["academicYearId"] = this.academicYearId;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): StudentNameDto {
        const json = this.toJSON();
        let result = new StudentNameDto();
        result.init(json);
        return result;
    }
}

export interface IStudentNameDto {
    studentId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    academicYearId: number | undefined;
    fullName: string | undefined;
}

export class LeavingCertificateHistory implements ILeavingCertificateHistory {
    leavingCertificateList!: LeavingCertificateGridDto[];

    constructor(data?: ILeavingCertificateHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["leavingCertificateList"])) {
                this.leavingCertificateList = [] as any;
                for (let item of _data["leavingCertificateList"])
                    this.leavingCertificateList!.push(LeavingCertificateGridDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeavingCertificateHistory {
        data = typeof data === 'object' ? data : {};
        let result = new LeavingCertificateHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.leavingCertificateList)) {
            data["leavingCertificateList"] = [];
            for (let item of this.leavingCertificateList)
                data["leavingCertificateList"].push(item.toJSON());
        }
        return data;
    }

    clone(): LeavingCertificateHistory {
        const json = this.toJSON();
        let result = new LeavingCertificateHistory();
        result.init(json);
        return result;
    }
}

export interface ILeavingCertificateHistory {
    leavingCertificateList: LeavingCertificateGridDto[];
}

export class LeavingCertificateGridDto implements ILeavingCertificateGridDto {
    leavingCertificateAuditsId!: number | undefined;
    statusId!: number;
    serialNumber!: number;
    studentName!: string;
    createdDate!: moment.Moment | undefined;
    generalRegistrationNo!: string | undefined;

    constructor(data?: ILeavingCertificateGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leavingCertificateAuditsId = _data["leavingCertificateAuditsId"];
            this.statusId = _data["statusId"];
            this.serialNumber = _data["serialNumber"];
            this.studentName = _data["studentName"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.generalRegistrationNo = _data["generalRegistrationNo"];
        }
    }

    static fromJS(data: any): LeavingCertificateGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeavingCertificateGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leavingCertificateAuditsId"] = this.leavingCertificateAuditsId;
        data["statusId"] = this.statusId;
        data["serialNumber"] = this.serialNumber;
        data["studentName"] = this.studentName;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        return data;
    }

    clone(): LeavingCertificateGridDto {
        const json = this.toJSON();
        let result = new LeavingCertificateGridDto();
        result.init(json);
        return result;
    }
}

export interface ILeavingCertificateGridDto {
    leavingCertificateAuditsId: number | undefined;
    statusId: number;
    serialNumber: number;
    studentName: string;
    createdDate: moment.Moment | undefined;
    generalRegistrationNo: string | undefined;
}

export class CBSE_ExamResultDto implements ICBSE_ExamResultDto {
    academicYearId!: number | undefined;
    gradeId!: number | undefined;
    gradeName!: string;
    divisionId!: number | undefined;
    divisionName!: string | undefined;
    percentage!: number | undefined;
    className!: string;
    examName!: string;
    subjectName!: string;
    subjectMasterId!: number;
    examMasterId!: number;
    userId!: number;
    studentList!: CBSE_ExamResultStudentDto[];
    headerObjectList!: CBSE_ExamResultObjectDto[];
    cbsE_ExamResultList!: CBSE_ExamResultUpsertListDto[];

    constructor(data?: ICBSE_ExamResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.percentage = _data["percentage"];
            this.className = _data["className"];
            this.examName = _data["examName"];
            this.subjectName = _data["subjectName"];
            this.subjectMasterId = _data["subjectMasterId"];
            this.examMasterId = _data["examMasterId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["studentList"])) {
                this.studentList = [] as any;
                for (let item of _data["studentList"])
                    this.studentList!.push(CBSE_ExamResultStudentDto.fromJS(item));
            }
            if (Array.isArray(_data["headerObjectList"])) {
                this.headerObjectList = [] as any;
                for (let item of _data["headerObjectList"])
                    this.headerObjectList!.push(CBSE_ExamResultObjectDto.fromJS(item));
            }
            if (Array.isArray(_data["cbsE_ExamResultList"])) {
                this.cbsE_ExamResultList = [] as any;
                for (let item of _data["cbsE_ExamResultList"])
                    this.cbsE_ExamResultList!.push(CBSE_ExamResultUpsertListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CBSE_ExamResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["percentage"] = this.percentage;
        data["className"] = this.className;
        data["examName"] = this.examName;
        data["subjectName"] = this.subjectName;
        data["subjectMasterId"] = this.subjectMasterId;
        data["examMasterId"] = this.examMasterId;
        data["userId"] = this.userId;
        if (Array.isArray(this.studentList)) {
            data["studentList"] = [];
            for (let item of this.studentList)
                data["studentList"].push(item.toJSON());
        }
        if (Array.isArray(this.headerObjectList)) {
            data["headerObjectList"] = [];
            for (let item of this.headerObjectList)
                data["headerObjectList"].push(item.toJSON());
        }
        if (Array.isArray(this.cbsE_ExamResultList)) {
            data["cbsE_ExamResultList"] = [];
            for (let item of this.cbsE_ExamResultList)
                data["cbsE_ExamResultList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CBSE_ExamResultDto {
        const json = this.toJSON();
        let result = new CBSE_ExamResultDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamResultDto {
    academicYearId: number | undefined;
    gradeId: number | undefined;
    gradeName: string;
    divisionId: number | undefined;
    divisionName: string | undefined;
    percentage: number | undefined;
    className: string;
    examName: string;
    subjectName: string;
    subjectMasterId: number;
    examMasterId: number;
    userId: number;
    studentList: CBSE_ExamResultStudentDto[];
    headerObjectList: CBSE_ExamResultObjectDto[];
    cbsE_ExamResultList: CBSE_ExamResultUpsertListDto[];
}

export class CBSE_ExamResultStudentDto implements ICBSE_ExamResultStudentDto {
    studentName!: string;
    rollNumber!: string;
    studentId!: number;
    objectList!: CBSE_ExamResultObjectDto[];

    constructor(data?: ICBSE_ExamResultStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentName = _data["studentName"];
            this.rollNumber = _data["rollNumber"];
            this.studentId = _data["studentId"];
            if (Array.isArray(_data["objectList"])) {
                this.objectList = [] as any;
                for (let item of _data["objectList"])
                    this.objectList!.push(CBSE_ExamResultObjectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CBSE_ExamResultStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamResultStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["rollNumber"] = this.rollNumber;
        data["studentId"] = this.studentId;
        if (Array.isArray(this.objectList)) {
            data["objectList"] = [];
            for (let item of this.objectList)
                data["objectList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CBSE_ExamResultStudentDto {
        const json = this.toJSON();
        let result = new CBSE_ExamResultStudentDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamResultStudentDto {
    studentName: string;
    rollNumber: string;
    studentId: number;
    objectList: CBSE_ExamResultObjectDto[];
}

export class CBSE_ExamResultObjectDto implements ICBSE_ExamResultObjectDto {
    studentId!: number;
    objectName!: string;
    examObjectId!: number;
    outOfMarks!: number;
    actualMarks!: number | undefined;
    totalMarks!: number | undefined;
    percentage!: number | undefined;
    grade!: string;

    constructor(data?: ICBSE_ExamResultObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.objectName = _data["objectName"];
            this.examObjectId = _data["examObjectId"];
            this.outOfMarks = _data["outOfMarks"];
            this.actualMarks = _data["actualMarks"];
            this.totalMarks = _data["totalMarks"];
            this.percentage = _data["percentage"];
            this.grade = _data["grade"];
        }
    }

    static fromJS(data: any): CBSE_ExamResultObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamResultObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["objectName"] = this.objectName;
        data["examObjectId"] = this.examObjectId;
        data["outOfMarks"] = this.outOfMarks;
        data["actualMarks"] = this.actualMarks;
        data["totalMarks"] = this.totalMarks;
        data["percentage"] = this.percentage;
        data["grade"] = this.grade;
        return data;
    }

    clone(): CBSE_ExamResultObjectDto {
        const json = this.toJSON();
        let result = new CBSE_ExamResultObjectDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamResultObjectDto {
    studentId: number;
    objectName: string;
    examObjectId: number;
    outOfMarks: number;
    actualMarks: number | undefined;
    totalMarks: number | undefined;
    percentage: number | undefined;
    grade: string;
}

export class CBSE_ExamResultUpsertListDto implements ICBSE_ExamResultUpsertListDto {
    studentId!: number;
    examObjectId!: number;
    outOfMarks!: number;
    actualMarks!: number | undefined;
    totalMarks!: number | undefined;
    percentage!: number | undefined;
    grade!: string;

    constructor(data?: ICBSE_ExamResultUpsertListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.examObjectId = _data["examObjectId"];
            this.outOfMarks = _data["outOfMarks"];
            this.actualMarks = _data["actualMarks"];
            this.totalMarks = _data["totalMarks"];
            this.percentage = _data["percentage"];
            this.grade = _data["grade"];
        }
    }

    static fromJS(data: any): CBSE_ExamResultUpsertListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamResultUpsertListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["examObjectId"] = this.examObjectId;
        data["outOfMarks"] = this.outOfMarks;
        data["actualMarks"] = this.actualMarks;
        data["totalMarks"] = this.totalMarks;
        data["percentage"] = this.percentage;
        data["grade"] = this.grade;
        return data;
    }

    clone(): CBSE_ExamResultUpsertListDto {
        const json = this.toJSON();
        let result = new CBSE_ExamResultUpsertListDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamResultUpsertListDto {
    studentId: number;
    examObjectId: number;
    outOfMarks: number;
    actualMarks: number | undefined;
    totalMarks: number | undefined;
    percentage: number | undefined;
    grade: string;
}

export class CBSE_ExamResultRequestDto implements ICBSE_ExamResultRequestDto {
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    examMasterId!: number;
    subjectMasterId!: number;

    constructor(data?: ICBSE_ExamResultRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.examMasterId = _data["examMasterId"];
            this.subjectMasterId = _data["subjectMasterId"];
        }
    }

    static fromJS(data: any): CBSE_ExamResultRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamResultRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["examMasterId"] = this.examMasterId;
        data["subjectMasterId"] = this.subjectMasterId;
        return data;
    }

    clone(): CBSE_ExamResultRequestDto {
        const json = this.toJSON();
        let result = new CBSE_ExamResultRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamResultRequestDto {
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    examMasterId: number;
    subjectMasterId: number;
}

export class ExamResultResponseDto implements IExamResultResponseDto {
    examNameList!: ExamNameDto[];
    subjectNameList!: SubjectNameDto[];
    markGradeList!: MarkGradeDto[];

    constructor(data?: IExamResultResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["examNameList"])) {
                this.examNameList = [] as any;
                for (let item of _data["examNameList"])
                    this.examNameList!.push(ExamNameDto.fromJS(item));
            }
            if (Array.isArray(_data["subjectNameList"])) {
                this.subjectNameList = [] as any;
                for (let item of _data["subjectNameList"])
                    this.subjectNameList!.push(SubjectNameDto.fromJS(item));
            }
            if (Array.isArray(_data["markGradeList"])) {
                this.markGradeList = [] as any;
                for (let item of _data["markGradeList"])
                    this.markGradeList!.push(MarkGradeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExamResultResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamResultResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.examNameList)) {
            data["examNameList"] = [];
            for (let item of this.examNameList)
                data["examNameList"].push(item.toJSON());
        }
        if (Array.isArray(this.subjectNameList)) {
            data["subjectNameList"] = [];
            for (let item of this.subjectNameList)
                data["subjectNameList"].push(item.toJSON());
        }
        if (Array.isArray(this.markGradeList)) {
            data["markGradeList"] = [];
            for (let item of this.markGradeList)
                data["markGradeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExamResultResponseDto {
        const json = this.toJSON();
        let result = new ExamResultResponseDto();
        result.init(json);
        return result;
    }
}

export interface IExamResultResponseDto {
    examNameList: ExamNameDto[];
    subjectNameList: SubjectNameDto[];
    markGradeList: MarkGradeDto[];
}

export class ExamNameDto implements IExamNameDto {
    examMasterId!: number;
    classExamMappingId!: number;
    examName!: string;

    constructor(data?: IExamNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examMasterId = _data["examMasterId"];
            this.classExamMappingId = _data["classExamMappingId"];
            this.examName = _data["examName"];
        }
    }

    static fromJS(data: any): ExamNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examMasterId"] = this.examMasterId;
        data["classExamMappingId"] = this.classExamMappingId;
        data["examName"] = this.examName;
        return data;
    }

    clone(): ExamNameDto {
        const json = this.toJSON();
        let result = new ExamNameDto();
        result.init(json);
        return result;
    }
}

export interface IExamNameDto {
    examMasterId: number;
    classExamMappingId: number;
    examName: string;
}

export class SubjectNameDto implements ISubjectNameDto {
    subjectMasterId!: number;
    subjectName!: string;

    constructor(data?: ISubjectNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectMasterId = _data["subjectMasterId"];
            this.subjectName = _data["subjectName"];
        }
    }

    static fromJS(data: any): SubjectNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectMasterId"] = this.subjectMasterId;
        data["subjectName"] = this.subjectName;
        return data;
    }

    clone(): SubjectNameDto {
        const json = this.toJSON();
        let result = new SubjectNameDto();
        result.init(json);
        return result;
    }
}

export interface ISubjectNameDto {
    subjectMasterId: number;
    subjectName: string;
}

export class MarkGradeDto implements IMarkGradeDto {
    minMark!: number;
    maxMark!: number;
    grade!: string;

    constructor(data?: IMarkGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minMark = _data["minMark"];
            this.maxMark = _data["maxMark"];
            this.grade = _data["grade"];
        }
    }

    static fromJS(data: any): MarkGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MarkGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minMark"] = this.minMark;
        data["maxMark"] = this.maxMark;
        data["grade"] = this.grade;
        return data;
    }

    clone(): MarkGradeDto {
        const json = this.toJSON();
        let result = new MarkGradeDto();
        result.init(json);
        return result;
    }
}

export interface IMarkGradeDto {
    minMark: number;
    maxMark: number;
    grade: string;
}

export class CBSE_ExamNameResponseDto implements ICBSE_ExamNameResponseDto {
    examNameList!: CBSE_ExamNameSelectDto[];

    constructor(data?: ICBSE_ExamNameResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["examNameList"])) {
                this.examNameList = [] as any;
                for (let item of _data["examNameList"])
                    this.examNameList!.push(CBSE_ExamNameSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CBSE_ExamNameResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamNameResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.examNameList)) {
            data["examNameList"] = [];
            for (let item of this.examNameList)
                data["examNameList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CBSE_ExamNameResponseDto {
        const json = this.toJSON();
        let result = new CBSE_ExamNameResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamNameResponseDto {
    examNameList: CBSE_ExamNameSelectDto[];
}

export class CBSE_ExamNameSelectDto implements ICBSE_ExamNameSelectDto {
    examMasterId!: number;
    examName!: string;
    examTypeName!: string;
    termId!: number;

    constructor(data?: ICBSE_ExamNameSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examMasterId = _data["examMasterId"];
            this.examName = _data["examName"];
            this.examTypeName = _data["examTypeName"];
            this.termId = _data["termId"];
        }
    }

    static fromJS(data: any): CBSE_ExamNameSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamNameSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examMasterId"] = this.examMasterId;
        data["examName"] = this.examName;
        data["examTypeName"] = this.examTypeName;
        data["termId"] = this.termId;
        return data;
    }

    clone(): CBSE_ExamNameSelectDto {
        const json = this.toJSON();
        let result = new CBSE_ExamNameSelectDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamNameSelectDto {
    examMasterId: number;
    examName: string;
    examTypeName: string;
    termId: number;
}

export class ExamNameRequestDto implements IExamNameRequestDto {
    academicYearId!: number;
    classId!: number[];

    constructor(data?: IExamNameRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
        }
    }

    static fromJS(data: any): ExamNameRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamNameRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        return data;
    }

    clone(): ExamNameRequestDto {
        const json = this.toJSON();
        let result = new ExamNameRequestDto();
        result.init(json);
        return result;
    }
}

export interface IExamNameRequestDto {
    academicYearId: number;
    classId: number[];
}

export class CBSE_ExamReportCardNameDto implements ICBSE_ExamReportCardNameDto {
    examReportCardNameId!: number;
    reportCardName!: string;
    academicYearId!: number;
    description!: string;
    isTwoDifferentExamSection!: boolean | undefined;
    examNames!: string;
    classIds!: string;
    examIds!: string;
    classNames!: string;
    termId!: number;
    createdDate!: moment.Moment | undefined;

    constructor(data?: ICBSE_ExamReportCardNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examReportCardNameId = _data["examReportCardNameId"];
            this.reportCardName = _data["reportCardName"];
            this.academicYearId = _data["academicYearId"];
            this.description = _data["description"];
            this.isTwoDifferentExamSection = _data["isTwoDifferentExamSection"];
            this.examNames = _data["examNames"];
            this.classIds = _data["classIds"];
            this.examIds = _data["examIds"];
            this.classNames = _data["classNames"];
            this.termId = _data["termId"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CBSE_ExamReportCardNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamReportCardNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examReportCardNameId"] = this.examReportCardNameId;
        data["reportCardName"] = this.reportCardName;
        data["academicYearId"] = this.academicYearId;
        data["description"] = this.description;
        data["isTwoDifferentExamSection"] = this.isTwoDifferentExamSection;
        data["examNames"] = this.examNames;
        data["classIds"] = this.classIds;
        data["examIds"] = this.examIds;
        data["classNames"] = this.classNames;
        data["termId"] = this.termId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): CBSE_ExamReportCardNameDto {
        const json = this.toJSON();
        let result = new CBSE_ExamReportCardNameDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamReportCardNameDto {
    examReportCardNameId: number;
    reportCardName: string;
    academicYearId: number;
    description: string;
    isTwoDifferentExamSection: boolean | undefined;
    examNames: string;
    classIds: string;
    examIds: string;
    classNames: string;
    termId: number;
    createdDate: moment.Moment | undefined;
}

export class ExamReportCardUpsertDto implements IExamReportCardUpsertDto {
    examReportCardNameId!: number;
    reportCardName!: string;
    description!: string;
    isTwoDifferentExamSection!: boolean | undefined;
    classId!: number[];
    examMasterId!: number[];

    constructor(data?: IExamReportCardUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examReportCardNameId = _data["examReportCardNameId"];
            this.reportCardName = _data["reportCardName"];
            this.description = _data["description"];
            this.isTwoDifferentExamSection = _data["isTwoDifferentExamSection"];
            if (Array.isArray(_data["classId"])) {
                this.classId = [] as any;
                for (let item of _data["classId"])
                    this.classId!.push(item);
            }
            if (Array.isArray(_data["examMasterId"])) {
                this.examMasterId = [] as any;
                for (let item of _data["examMasterId"])
                    this.examMasterId!.push(item);
            }
        }
    }

    static fromJS(data: any): ExamReportCardUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamReportCardUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examReportCardNameId"] = this.examReportCardNameId;
        data["reportCardName"] = this.reportCardName;
        data["description"] = this.description;
        data["isTwoDifferentExamSection"] = this.isTwoDifferentExamSection;
        if (Array.isArray(this.classId)) {
            data["classId"] = [];
            for (let item of this.classId)
                data["classId"].push(item);
        }
        if (Array.isArray(this.examMasterId)) {
            data["examMasterId"] = [];
            for (let item of this.examMasterId)
                data["examMasterId"].push(item);
        }
        return data;
    }

    clone(): ExamReportCardUpsertDto {
        const json = this.toJSON();
        let result = new ExamReportCardUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IExamReportCardUpsertDto {
    examReportCardNameId: number;
    reportCardName: string;
    description: string;
    isTwoDifferentExamSection: boolean | undefined;
    classId: number[];
    examMasterId: number[];
}

export class CBSE_ExamMasterDto implements ICBSE_ExamMasterDto {
    examMasterId!: number;
    academicYearId!: number | undefined;
    examName!: string;
    examTypeId!: number;
    examTypeName!: string;
    termId!: number;
    termName!: string;
    userId!: number | undefined;
    createdDate!: moment.Moment | undefined;
    ngbCalendarDate!: SchoolNgbDateModel | undefined;

    constructor(data?: ICBSE_ExamMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examMasterId = _data["examMasterId"];
            this.academicYearId = _data["academicYearId"];
            this.examName = _data["examName"];
            this.examTypeId = _data["examTypeId"];
            this.examTypeName = _data["examTypeName"];
            this.termId = _data["termId"];
            this.termName = _data["termName"];
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.ngbCalendarDate = _data["ngbCalendarDate"] ? SchoolNgbDateModel.fromJS(_data["ngbCalendarDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CBSE_ExamMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examMasterId"] = this.examMasterId;
        data["academicYearId"] = this.academicYearId;
        data["examName"] = this.examName;
        data["examTypeId"] = this.examTypeId;
        data["examTypeName"] = this.examTypeName;
        data["termId"] = this.termId;
        data["termName"] = this.termName;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["ngbCalendarDate"] = this.ngbCalendarDate ? this.ngbCalendarDate.toJSON() : <any>undefined;
        return data;
    }

    clone(): CBSE_ExamMasterDto {
        const json = this.toJSON();
        let result = new CBSE_ExamMasterDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamMasterDto {
    examMasterId: number;
    academicYearId: number | undefined;
    examName: string;
    examTypeId: number;
    examTypeName: string;
    termId: number;
    termName: string;
    userId: number | undefined;
    createdDate: moment.Moment | undefined;
    ngbCalendarDate: SchoolNgbDateModel | undefined;
}

export class ExamMasterDeleteResponceDto implements IExamMasterDeleteResponceDto {
    affectedRows!: number;
    examMappingCount!: number;
    examObjectCount!: number;

    constructor(data?: IExamMasterDeleteResponceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
            this.examMappingCount = _data["examMappingCount"];
            this.examObjectCount = _data["examObjectCount"];
        }
    }

    static fromJS(data: any): ExamMasterDeleteResponceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamMasterDeleteResponceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        data["examMappingCount"] = this.examMappingCount;
        data["examObjectCount"] = this.examObjectCount;
        return data;
    }

    clone(): ExamMasterDeleteResponceDto {
        const json = this.toJSON();
        let result = new ExamMasterDeleteResponceDto();
        result.init(json);
        return result;
    }
}

export interface IExamMasterDeleteResponceDto {
    affectedRows: number;
    examMappingCount: number;
    examObjectCount: number;
}

export class CBSE_ExamObjectDto implements ICBSE_ExamObjectDto {
    examObjectId!: number;
    examMasterId!: number;
    subjectMasterId!: number;
    academicYearId!: number | undefined;
    subjectName!: string;
    name!: string;
    objectName!: string;
    outOfMarks!: string;
    status!: string;
    userId!: number | undefined;
    objectNameDetailsList!: ExamObjectTypeDetailsDto[] | undefined;

    constructor(data?: ICBSE_ExamObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examObjectId = _data["examObjectId"];
            this.examMasterId = _data["examMasterId"];
            this.subjectMasterId = _data["subjectMasterId"];
            this.academicYearId = _data["academicYearId"];
            this.subjectName = _data["subjectName"];
            this.name = _data["name"];
            this.objectName = _data["objectName"];
            this.outOfMarks = _data["outOfMarks"];
            this.status = _data["status"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["objectNameDetailsList"])) {
                this.objectNameDetailsList = [] as any;
                for (let item of _data["objectNameDetailsList"])
                    this.objectNameDetailsList!.push(ExamObjectTypeDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CBSE_ExamObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examObjectId"] = this.examObjectId;
        data["examMasterId"] = this.examMasterId;
        data["subjectMasterId"] = this.subjectMasterId;
        data["academicYearId"] = this.academicYearId;
        data["subjectName"] = this.subjectName;
        data["name"] = this.name;
        data["objectName"] = this.objectName;
        data["outOfMarks"] = this.outOfMarks;
        data["status"] = this.status;
        data["userId"] = this.userId;
        if (Array.isArray(this.objectNameDetailsList)) {
            data["objectNameDetailsList"] = [];
            for (let item of this.objectNameDetailsList)
                data["objectNameDetailsList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CBSE_ExamObjectDto {
        const json = this.toJSON();
        let result = new CBSE_ExamObjectDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamObjectDto {
    examObjectId: number;
    examMasterId: number;
    subjectMasterId: number;
    academicYearId: number | undefined;
    subjectName: string;
    name: string;
    objectName: string;
    outOfMarks: string;
    status: string;
    userId: number | undefined;
    objectNameDetailsList: ExamObjectTypeDetailsDto[] | undefined;
}

export class ExamObjectTypeDetailsDto implements IExamObjectTypeDetailsDto {
    examObjectId!: number;
    objectName!: string;
    outOfMarks!: string;

    constructor(data?: IExamObjectTypeDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examObjectId = _data["examObjectId"];
            this.objectName = _data["objectName"];
            this.outOfMarks = _data["outOfMarks"];
        }
    }

    static fromJS(data: any): ExamObjectTypeDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamObjectTypeDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examObjectId"] = this.examObjectId;
        data["objectName"] = this.objectName;
        data["outOfMarks"] = this.outOfMarks;
        return data;
    }

    clone(): ExamObjectTypeDetailsDto {
        const json = this.toJSON();
        let result = new ExamObjectTypeDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IExamObjectTypeDetailsDto {
    examObjectId: number;
    objectName: string;
    outOfMarks: string;
}

export class PublishUnpublishExamObjectDto implements IPublishUnpublishExamObjectDto {
    examObjectId!: number;
    isPublished!: boolean;
    classId!: number | undefined;

    constructor(data?: IPublishUnpublishExamObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examObjectId = _data["examObjectId"];
            this.isPublished = _data["isPublished"];
            this.classId = _data["classId"];
        }
    }

    static fromJS(data: any): PublishUnpublishExamObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishUnpublishExamObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examObjectId"] = this.examObjectId;
        data["isPublished"] = this.isPublished;
        data["classId"] = this.classId;
        return data;
    }

    clone(): PublishUnpublishExamObjectDto {
        const json = this.toJSON();
        let result = new PublishUnpublishExamObjectDto();
        result.init(json);
        return result;
    }
}

export interface IPublishUnpublishExamObjectDto {
    examObjectId: number;
    isPublished: boolean;
    classId: number | undefined;
}

export class ExamObjectDeleteRespose implements IExamObjectDeleteRespose {
    affectedRows!: number;

    constructor(data?: IExamObjectDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): ExamObjectDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new ExamObjectDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): ExamObjectDeleteRespose {
        const json = this.toJSON();
        let result = new ExamObjectDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IExamObjectDeleteRespose {
    affectedRows: number;
}

export class ExamObjectExistResponseDto implements IExamObjectExistResponseDto {
    objectExist!: number;
    objectNames!: string;
    dublicateObjects!: ExamObjectTypeDetailsDto[];

    constructor(data?: IExamObjectExistResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectExist = _data["objectExist"];
            this.objectNames = _data["objectNames"];
            if (Array.isArray(_data["dublicateObjects"])) {
                this.dublicateObjects = [] as any;
                for (let item of _data["dublicateObjects"])
                    this.dublicateObjects!.push(ExamObjectTypeDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExamObjectExistResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamObjectExistResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectExist"] = this.objectExist;
        data["objectNames"] = this.objectNames;
        if (Array.isArray(this.dublicateObjects)) {
            data["dublicateObjects"] = [];
            for (let item of this.dublicateObjects)
                data["dublicateObjects"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExamObjectExistResponseDto {
        const json = this.toJSON();
        let result = new ExamObjectExistResponseDto();
        result.init(json);
        return result;
    }
}

export interface IExamObjectExistResponseDto {
    objectExist: number;
    objectNames: string;
    dublicateObjects: ExamObjectTypeDetailsDto[];
}

export class CBSE_ResponseDto implements ICBSE_ResponseDto {
    termList!: CBSE_TermDto[];
    examTypeList!: CBSE_ExamTypeDto[];

    constructor(data?: ICBSE_ResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["termList"])) {
                this.termList = [] as any;
                for (let item of _data["termList"])
                    this.termList!.push(CBSE_TermDto.fromJS(item));
            }
            if (Array.isArray(_data["examTypeList"])) {
                this.examTypeList = [] as any;
                for (let item of _data["examTypeList"])
                    this.examTypeList!.push(CBSE_ExamTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CBSE_ResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.termList)) {
            data["termList"] = [];
            for (let item of this.termList)
                data["termList"].push(item.toJSON());
        }
        if (Array.isArray(this.examTypeList)) {
            data["examTypeList"] = [];
            for (let item of this.examTypeList)
                data["examTypeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CBSE_ResponseDto {
        const json = this.toJSON();
        let result = new CBSE_ResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ResponseDto {
    termList: CBSE_TermDto[];
    examTypeList: CBSE_ExamTypeDto[];
}

export class CBSE_TermDto implements ICBSE_TermDto {
    termId!: number;
    termName!: string;

    constructor(data?: ICBSE_TermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.termId = _data["termId"];
            this.termName = _data["termName"];
        }
    }

    static fromJS(data: any): CBSE_TermDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_TermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["termId"] = this.termId;
        data["termName"] = this.termName;
        return data;
    }

    clone(): CBSE_TermDto {
        const json = this.toJSON();
        let result = new CBSE_TermDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_TermDto {
    termId: number;
    termName: string;
}

export class CBSE_ExamTypeDto implements ICBSE_ExamTypeDto {
    examTypeId!: number;
    examTypeName!: string;

    constructor(data?: ICBSE_ExamTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examTypeId = _data["examTypeId"];
            this.examTypeName = _data["examTypeName"];
        }
    }

    static fromJS(data: any): CBSE_ExamTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ExamTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examTypeId"] = this.examTypeId;
        data["examTypeName"] = this.examTypeName;
        return data;
    }

    clone(): CBSE_ExamTypeDto {
        const json = this.toJSON();
        let result = new CBSE_ExamTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ExamTypeDto {
    examTypeId: number;
    examTypeName: string;
}

export class CBSE_ClassExamMappingDto implements ICBSE_ClassExamMappingDto {
    classExamMappingId!: number;
    examMasterId!: number;
    examName!: string | undefined;
    examTypeId!: number | undefined;
    examTypeName!: string | undefined;
    termId!: number | undefined;
    termName!: string | undefined;
    academicYearId!: number | undefined;
    classIds!: string;
    classList!: number[];
    className!: string;
    userId!: number | undefined;
    classId!: string | undefined;

    constructor(data?: ICBSE_ClassExamMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classExamMappingId = _data["classExamMappingId"];
            this.examMasterId = _data["examMasterId"];
            this.examName = _data["examName"];
            this.examTypeId = _data["examTypeId"];
            this.examTypeName = _data["examTypeName"];
            this.termId = _data["termId"];
            this.termName = _data["termName"];
            this.academicYearId = _data["academicYearId"];
            this.classIds = _data["classIds"];
            if (Array.isArray(_data["classList"])) {
                this.classList = [] as any;
                for (let item of _data["classList"])
                    this.classList!.push(item);
            }
            this.className = _data["className"];
            this.userId = _data["userId"];
            this.classId = _data["classId"];
        }
    }

    static fromJS(data: any): CBSE_ClassExamMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_ClassExamMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classExamMappingId"] = this.classExamMappingId;
        data["examMasterId"] = this.examMasterId;
        data["examName"] = this.examName;
        data["examTypeId"] = this.examTypeId;
        data["examTypeName"] = this.examTypeName;
        data["termId"] = this.termId;
        data["termName"] = this.termName;
        data["academicYearId"] = this.academicYearId;
        data["classIds"] = this.classIds;
        if (Array.isArray(this.classList)) {
            data["classList"] = [];
            for (let item of this.classList)
                data["classList"].push(item);
        }
        data["className"] = this.className;
        data["userId"] = this.userId;
        data["classId"] = this.classId;
        return data;
    }

    clone(): CBSE_ClassExamMappingDto {
        const json = this.toJSON();
        let result = new CBSE_ClassExamMappingDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_ClassExamMappingDto {
    classExamMappingId: number;
    examMasterId: number;
    examName: string | undefined;
    examTypeId: number | undefined;
    examTypeName: string | undefined;
    termId: number | undefined;
    termName: string | undefined;
    academicYearId: number | undefined;
    classIds: string;
    classList: number[];
    className: string;
    userId: number | undefined;
    classId: string | undefined;
}

export class CBSE_MarksGradeRelationDto implements ICBSE_MarksGradeRelationDto {
    marksGradeRelationId!: number;
    academicYearId!: number | undefined;
    minMark!: number;
    maxMark!: number;
    grade!: string;
    userId!: number | undefined;

    constructor(data?: ICBSE_MarksGradeRelationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.marksGradeRelationId = _data["marksGradeRelationId"];
            this.academicYearId = _data["academicYearId"];
            this.minMark = _data["minMark"];
            this.maxMark = _data["maxMark"];
            this.grade = _data["grade"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CBSE_MarksGradeRelationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_MarksGradeRelationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["marksGradeRelationId"] = this.marksGradeRelationId;
        data["academicYearId"] = this.academicYearId;
        data["minMark"] = this.minMark;
        data["maxMark"] = this.maxMark;
        data["grade"] = this.grade;
        data["userId"] = this.userId;
        return data;
    }

    clone(): CBSE_MarksGradeRelationDto {
        const json = this.toJSON();
        let result = new CBSE_MarksGradeRelationDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_MarksGradeRelationDto {
    marksGradeRelationId: number;
    academicYearId: number | undefined;
    minMark: number;
    maxMark: number;
    grade: string;
    userId: number | undefined;
}

export class MarksGradeRelationDeleteRespose implements IMarksGradeRelationDeleteRespose {
    affectedRows!: number;

    constructor(data?: IMarksGradeRelationDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): MarksGradeRelationDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new MarksGradeRelationDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): MarksGradeRelationDeleteRespose {
        const json = this.toJSON();
        let result = new MarksGradeRelationDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IMarksGradeRelationDeleteRespose {
    affectedRows: number;
}

export class ExamObjectDeleteResponseDto implements IExamObjectDeleteResponseDto {
    operationStatus!: number;

    constructor(data?: IExamObjectDeleteResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationStatus = _data["operationStatus"];
        }
    }

    static fromJS(data: any): ExamObjectDeleteResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamObjectDeleteResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationStatus"] = this.operationStatus;
        return data;
    }

    clone(): ExamObjectDeleteResponseDto {
        const json = this.toJSON();
        let result = new ExamObjectDeleteResponseDto();
        result.init(json);
        return result;
    }
}

export interface IExamObjectDeleteResponseDto {
    operationStatus: number;
}

export class ExamObjectDeleteRequestDto implements IExamObjectDeleteRequestDto {
    examObjectId!: number;
    examMasterId!: number;
    subjectMasterId!: number;
    academicYearId!: number;

    constructor(data?: IExamObjectDeleteRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examObjectId = _data["examObjectId"];
            this.examMasterId = _data["examMasterId"];
            this.subjectMasterId = _data["subjectMasterId"];
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): ExamObjectDeleteRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamObjectDeleteRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examObjectId"] = this.examObjectId;
        data["examMasterId"] = this.examMasterId;
        data["subjectMasterId"] = this.subjectMasterId;
        data["academicYearId"] = this.academicYearId;
        return data;
    }

    clone(): ExamObjectDeleteRequestDto {
        const json = this.toJSON();
        let result = new ExamObjectDeleteRequestDto();
        result.init(json);
        return result;
    }
}

export interface IExamObjectDeleteRequestDto {
    examObjectId: number;
    examMasterId: number;
    subjectMasterId: number;
    academicYearId: number;
}

export class CBSE_AcademicAssessmentReportDto implements ICBSE_AcademicAssessmentReportDto {
    schoolName!: string;
    schoolContactNumber1!: number;
    schoolEmail!: string;
    affiliationNumber!: string;
    schoolPermission!: string;
    registrationNumber!: string;
    section!: string;
    schoolType!: string;
    logoUrl!: string;
    mediumTypeName!: string;
    studentName!: string;
    divisionName!: string;
    gradeName!: string;
    motherTounge!: string;
    birthDate!: moment.Moment | undefined;
    currentAddressLine1!: string;
    currentAddressLine2!: string;
    emergencyContactNumber!: string;
    weight!: string;
    height!: string;
    bloodGroup!: string;
    gender!: string;
    rollNo!: number;
    fatherName!: string;
    motherName!: string;
    contactNo!: string;
    generalRegistrationNo!: string;
    fatherOccupation!: string;
    motherOccupation!: string;

    constructor(data?: ICBSE_AcademicAssessmentReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.schoolContactNumber1 = _data["schoolContactNumber1"];
            this.schoolEmail = _data["schoolEmail"];
            this.affiliationNumber = _data["affiliationNumber"];
            this.schoolPermission = _data["schoolPermission"];
            this.registrationNumber = _data["registrationNumber"];
            this.section = _data["section"];
            this.schoolType = _data["schoolType"];
            this.logoUrl = _data["logoUrl"];
            this.mediumTypeName = _data["mediumTypeName"];
            this.studentName = _data["studentName"];
            this.divisionName = _data["divisionName"];
            this.gradeName = _data["gradeName"];
            this.motherTounge = _data["motherTounge"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.currentAddressLine1 = _data["currentAddressLine1"];
            this.currentAddressLine2 = _data["currentAddressLine2"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.weight = _data["weight"];
            this.height = _data["height"];
            this.bloodGroup = _data["bloodGroup"];
            this.gender = _data["gender"];
            this.rollNo = _data["rollNo"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.contactNo = _data["contactNo"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.fatherOccupation = _data["fatherOccupation"];
            this.motherOccupation = _data["motherOccupation"];
        }
    }

    static fromJS(data: any): CBSE_AcademicAssessmentReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CBSE_AcademicAssessmentReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["schoolContactNumber1"] = this.schoolContactNumber1;
        data["schoolEmail"] = this.schoolEmail;
        data["affiliationNumber"] = this.affiliationNumber;
        data["schoolPermission"] = this.schoolPermission;
        data["registrationNumber"] = this.registrationNumber;
        data["section"] = this.section;
        data["schoolType"] = this.schoolType;
        data["logoUrl"] = this.logoUrl;
        data["mediumTypeName"] = this.mediumTypeName;
        data["studentName"] = this.studentName;
        data["divisionName"] = this.divisionName;
        data["gradeName"] = this.gradeName;
        data["motherTounge"] = this.motherTounge;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["currentAddressLine1"] = this.currentAddressLine1;
        data["currentAddressLine2"] = this.currentAddressLine2;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["weight"] = this.weight;
        data["height"] = this.height;
        data["bloodGroup"] = this.bloodGroup;
        data["gender"] = this.gender;
        data["rollNo"] = this.rollNo;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["contactNo"] = this.contactNo;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["fatherOccupation"] = this.fatherOccupation;
        data["motherOccupation"] = this.motherOccupation;
        return data;
    }

    clone(): CBSE_AcademicAssessmentReportDto {
        const json = this.toJSON();
        let result = new CBSE_AcademicAssessmentReportDto();
        result.init(json);
        return result;
    }
}

export interface ICBSE_AcademicAssessmentReportDto {
    schoolName: string;
    schoolContactNumber1: number;
    schoolEmail: string;
    affiliationNumber: string;
    schoolPermission: string;
    registrationNumber: string;
    section: string;
    schoolType: string;
    logoUrl: string;
    mediumTypeName: string;
    studentName: string;
    divisionName: string;
    gradeName: string;
    motherTounge: string;
    birthDate: moment.Moment | undefined;
    currentAddressLine1: string;
    currentAddressLine2: string;
    emergencyContactNumber: string;
    weight: string;
    height: string;
    bloodGroup: string;
    gender: string;
    rollNo: number;
    fatherName: string;
    motherName: string;
    contactNo: string;
    generalRegistrationNo: string;
    fatherOccupation: string;
    motherOccupation: string;
}

export class ResultTempleteReportSearchResponseDto implements IResultTempleteReportSearchResponseDto {
    examResultListTerm1!: ResultTempleteReportSearchDto[];
    examResultListTerm2!: ResultTempleteReportSearchDto[];

    constructor(data?: IResultTempleteReportSearchResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["examResultListTerm1"])) {
                this.examResultListTerm1 = [] as any;
                for (let item of _data["examResultListTerm1"])
                    this.examResultListTerm1!.push(ResultTempleteReportSearchDto.fromJS(item));
            }
            if (Array.isArray(_data["examResultListTerm2"])) {
                this.examResultListTerm2 = [] as any;
                for (let item of _data["examResultListTerm2"])
                    this.examResultListTerm2!.push(ResultTempleteReportSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultTempleteReportSearchResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultTempleteReportSearchResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.examResultListTerm1)) {
            data["examResultListTerm1"] = [];
            for (let item of this.examResultListTerm1)
                data["examResultListTerm1"].push(item.toJSON());
        }
        if (Array.isArray(this.examResultListTerm2)) {
            data["examResultListTerm2"] = [];
            for (let item of this.examResultListTerm2)
                data["examResultListTerm2"].push(item.toJSON());
        }
        return data;
    }

    clone(): ResultTempleteReportSearchResponseDto {
        const json = this.toJSON();
        let result = new ResultTempleteReportSearchResponseDto();
        result.init(json);
        return result;
    }
}

export interface IResultTempleteReportSearchResponseDto {
    examResultListTerm1: ResultTempleteReportSearchDto[];
    examResultListTerm2: ResultTempleteReportSearchDto[];
}

export class ResultTempleteReportSearchDto implements IResultTempleteReportSearchDto {
    reportCardName!: string;
    examTypeName!: string;
    examName!: string;
    subjectName!: string;
    objectName!: string;
    outOfMarks!: number;
    actualMarks!: number;
    totalMarks!: number;
    grade!: string;
    termId!: number;
    termName!: string;
    indexNumber!: number;
    isTwoDifferentExamSection!: number;

    constructor(data?: IResultTempleteReportSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportCardName = _data["reportCardName"];
            this.examTypeName = _data["examTypeName"];
            this.examName = _data["examName"];
            this.subjectName = _data["subjectName"];
            this.objectName = _data["objectName"];
            this.outOfMarks = _data["outOfMarks"];
            this.actualMarks = _data["actualMarks"];
            this.totalMarks = _data["totalMarks"];
            this.grade = _data["grade"];
            this.termId = _data["termId"];
            this.termName = _data["termName"];
            this.indexNumber = _data["indexNumber"];
            this.isTwoDifferentExamSection = _data["isTwoDifferentExamSection"];
        }
    }

    static fromJS(data: any): ResultTempleteReportSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultTempleteReportSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportCardName"] = this.reportCardName;
        data["examTypeName"] = this.examTypeName;
        data["examName"] = this.examName;
        data["subjectName"] = this.subjectName;
        data["objectName"] = this.objectName;
        data["outOfMarks"] = this.outOfMarks;
        data["actualMarks"] = this.actualMarks;
        data["totalMarks"] = this.totalMarks;
        data["grade"] = this.grade;
        data["termId"] = this.termId;
        data["termName"] = this.termName;
        data["indexNumber"] = this.indexNumber;
        data["isTwoDifferentExamSection"] = this.isTwoDifferentExamSection;
        return data;
    }

    clone(): ResultTempleteReportSearchDto {
        const json = this.toJSON();
        let result = new ResultTempleteReportSearchDto();
        result.init(json);
        return result;
    }
}

export interface IResultTempleteReportSearchDto {
    reportCardName: string;
    examTypeName: string;
    examName: string;
    subjectName: string;
    objectName: string;
    outOfMarks: number;
    actualMarks: number;
    totalMarks: number;
    grade: string;
    termId: number;
    termName: string;
    indexNumber: number;
    isTwoDifferentExamSection: number;
}

export class ReportCardTempleteDropdownResponceDto implements IReportCardTempleteDropdownResponceDto {
    reportCardTemplateDropdownList!: ReportCardTemplateDropdownDto[];

    constructor(data?: IReportCardTempleteDropdownResponceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportCardTemplateDropdownList"])) {
                this.reportCardTemplateDropdownList = [] as any;
                for (let item of _data["reportCardTemplateDropdownList"])
                    this.reportCardTemplateDropdownList!.push(ReportCardTemplateDropdownDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportCardTempleteDropdownResponceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportCardTempleteDropdownResponceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportCardTemplateDropdownList)) {
            data["reportCardTemplateDropdownList"] = [];
            for (let item of this.reportCardTemplateDropdownList)
                data["reportCardTemplateDropdownList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReportCardTempleteDropdownResponceDto {
        const json = this.toJSON();
        let result = new ReportCardTempleteDropdownResponceDto();
        result.init(json);
        return result;
    }
}

export interface IReportCardTempleteDropdownResponceDto {
    reportCardTemplateDropdownList: ReportCardTemplateDropdownDto[];
}

export class ReportCardTemplateDropdownDto implements IReportCardTemplateDropdownDto {
    examReportCardNameId!: number;
    reportCardName!: string;

    constructor(data?: IReportCardTemplateDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.examReportCardNameId = _data["examReportCardNameId"];
            this.reportCardName = _data["reportCardName"];
        }
    }

    static fromJS(data: any): ReportCardTemplateDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportCardTemplateDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examReportCardNameId"] = this.examReportCardNameId;
        data["reportCardName"] = this.reportCardName;
        return data;
    }

    clone(): ReportCardTemplateDropdownDto {
        const json = this.toJSON();
        let result = new ReportCardTemplateDropdownDto();
        result.init(json);
        return result;
    }
}

export interface IReportCardTemplateDropdownDto {
    examReportCardNameId: number;
    reportCardName: string;
}

export class StudentMonthlyAttendanceResponceDto implements IStudentMonthlyAttendanceResponceDto {
    studentMonthlyAttendanceList!: StudentMonthlyAttendanceDto[];

    constructor(data?: IStudentMonthlyAttendanceResponceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["studentMonthlyAttendanceList"])) {
                this.studentMonthlyAttendanceList = [] as any;
                for (let item of _data["studentMonthlyAttendanceList"])
                    this.studentMonthlyAttendanceList!.push(StudentMonthlyAttendanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentMonthlyAttendanceResponceDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentMonthlyAttendanceResponceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.studentMonthlyAttendanceList)) {
            data["studentMonthlyAttendanceList"] = [];
            for (let item of this.studentMonthlyAttendanceList)
                data["studentMonthlyAttendanceList"].push(item.toJSON());
        }
        return data;
    }

    clone(): StudentMonthlyAttendanceResponceDto {
        const json = this.toJSON();
        let result = new StudentMonthlyAttendanceResponceDto();
        result.init(json);
        return result;
    }
}

export interface IStudentMonthlyAttendanceResponceDto {
    studentMonthlyAttendanceList: StudentMonthlyAttendanceDto[];
}

export class StudentMonthlyAttendanceDto implements IStudentMonthlyAttendanceDto {
    studentId!: number;
    monthNumber!: number;
    monthName!: string;
    presentDays!: number;
    totalWorkingDays!: number;

    constructor(data?: IStudentMonthlyAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.monthNumber = _data["monthNumber"];
            this.monthName = _data["monthName"];
            this.presentDays = _data["presentDays"];
            this.totalWorkingDays = _data["totalWorkingDays"];
        }
    }

    static fromJS(data: any): StudentMonthlyAttendanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentMonthlyAttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["monthNumber"] = this.monthNumber;
        data["monthName"] = this.monthName;
        data["presentDays"] = this.presentDays;
        data["totalWorkingDays"] = this.totalWorkingDays;
        return data;
    }

    clone(): StudentMonthlyAttendanceDto {
        const json = this.toJSON();
        let result = new StudentMonthlyAttendanceDto();
        result.init(json);
        return result;
    }
}

export interface IStudentMonthlyAttendanceDto {
    studentId: number;
    monthNumber: number;
    monthName: string;
    presentDays: number;
    totalWorkingDays: number;
}

export class CabDriverDto implements ICabDriverDto {
    cabDriverId!: number | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    fullName!: string | undefined;
    address!: string | undefined;
    gender!: string | undefined;
    contactNumber!: string | undefined;
    mobileNumber!: string | undefined;
    emailId!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    talukaId!: number | undefined;
    districtId!: number | undefined;
    stateId!: number | undefined;
    talukaName!: string | undefined;
    districtName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    adharNumber!: string | undefined;
    countryId!: number | undefined;
    zipCode!: string | undefined;
    drivingLicenceNumber!: string | undefined;
    education!: string | undefined;
    bloodGroup!: string | undefined;
    profileImageURL!: string | undefined;
    userId!: number | undefined;
    ngbValidTill!: SchoolNgbDateModel | undefined;
    validTill!: moment.Moment | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthDate!: moment.Moment | undefined;
    profileBase64Image!: string | undefined;
    profileImageContentType!: string | undefined;
    isAppAccess!: boolean | undefined;
    appAccessMobileNo!: string | undefined;
    appAccessOneTimePassword!: string | undefined;
    schoolId!: number | undefined;

    constructor(data?: ICabDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cabDriverId = _data["cabDriverId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.address = _data["address"];
            this.gender = _data["gender"];
            this.contactNumber = _data["contactNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.emailId = _data["emailId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.talukaId = _data["talukaId"];
            this.districtId = _data["districtId"];
            this.stateId = _data["stateId"];
            this.talukaName = _data["talukaName"];
            this.districtName = _data["districtName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.adharNumber = _data["adharNumber"];
            this.countryId = _data["countryId"];
            this.zipCode = _data["zipCode"];
            this.drivingLicenceNumber = _data["drivingLicenceNumber"];
            this.education = _data["education"];
            this.bloodGroup = _data["bloodGroup"];
            this.profileImageURL = _data["profileImageURL"];
            this.userId = _data["userId"];
            this.ngbValidTill = _data["ngbValidTill"] ? SchoolNgbDateModel.fromJS(_data["ngbValidTill"]) : <any>undefined;
            this.validTill = _data["validTill"] ? moment(_data["validTill"].toString()) : <any>undefined;
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.profileBase64Image = _data["profileBase64Image"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.isAppAccess = _data["isAppAccess"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.appAccessOneTimePassword = _data["appAccessOneTimePassword"];
            this.schoolId = _data["schoolId"];
        }
    }

    static fromJS(data: any): CabDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cabDriverId"] = this.cabDriverId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["address"] = this.address;
        data["gender"] = this.gender;
        data["contactNumber"] = this.contactNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["emailId"] = this.emailId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["talukaId"] = this.talukaId;
        data["districtId"] = this.districtId;
        data["stateId"] = this.stateId;
        data["talukaName"] = this.talukaName;
        data["districtName"] = this.districtName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["adharNumber"] = this.adharNumber;
        data["countryId"] = this.countryId;
        data["zipCode"] = this.zipCode;
        data["drivingLicenceNumber"] = this.drivingLicenceNumber;
        data["education"] = this.education;
        data["bloodGroup"] = this.bloodGroup;
        data["profileImageURL"] = this.profileImageURL;
        data["userId"] = this.userId;
        data["ngbValidTill"] = this.ngbValidTill ? this.ngbValidTill.toJSON() : <any>undefined;
        data["validTill"] = this.validTill ? this.validTill.toISOString() : <any>undefined;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["profileBase64Image"] = this.profileBase64Image;
        data["profileImageContentType"] = this.profileImageContentType;
        data["isAppAccess"] = this.isAppAccess;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["appAccessOneTimePassword"] = this.appAccessOneTimePassword;
        data["schoolId"] = this.schoolId;
        return data;
    }

    clone(): CabDriverDto {
        const json = this.toJSON();
        let result = new CabDriverDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverDto {
    cabDriverId: number | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    address: string | undefined;
    gender: string | undefined;
    contactNumber: string | undefined;
    mobileNumber: string | undefined;
    emailId: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    talukaId: number | undefined;
    districtId: number | undefined;
    stateId: number | undefined;
    talukaName: string | undefined;
    districtName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    adharNumber: string | undefined;
    countryId: number | undefined;
    zipCode: string | undefined;
    drivingLicenceNumber: string | undefined;
    education: string | undefined;
    bloodGroup: string | undefined;
    profileImageURL: string | undefined;
    userId: number | undefined;
    ngbValidTill: SchoolNgbDateModel | undefined;
    validTill: moment.Moment | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthDate: moment.Moment | undefined;
    profileBase64Image: string | undefined;
    profileImageContentType: string | undefined;
    isAppAccess: boolean | undefined;
    appAccessMobileNo: string | undefined;
    appAccessOneTimePassword: string | undefined;
    schoolId: number | undefined;
}

export class CabDriverDeleteRespose implements ICabDriverDeleteRespose {
    affectedRows!: number;

    constructor(data?: ICabDriverDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): CabDriverDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): CabDriverDeleteRespose {
        const json = this.toJSON();
        let result = new CabDriverDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface ICabDriverDeleteRespose {
    affectedRows: number;
}

export class CabDriverProfileAppDto implements ICabDriverProfileAppDto {
    cabDriverId!: number | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    mobileNumber!: string | undefined;
    cabDriverFullName!: string | undefined;
    emailId!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    talukaId!: number | undefined;
    districtId!: number | undefined;
    stateId!: number | undefined;
    talukaName!: string | undefined;
    districtName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    countryId!: number | undefined;
    zipCode!: string | undefined;
    education!: string | undefined;
    bloodGroup!: string | undefined;
    userId!: number | undefined;
    profileImageURL!: string | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthDate!: moment.Moment | undefined;
    profileBase64Image!: string | undefined;
    profileImageContentType!: string | undefined;

    constructor(data?: ICabDriverProfileAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cabDriverId = _data["cabDriverId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.mobileNumber = _data["mobileNumber"];
            this.cabDriverFullName = _data["cabDriverFullName"];
            this.emailId = _data["emailId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.talukaId = _data["talukaId"];
            this.districtId = _data["districtId"];
            this.stateId = _data["stateId"];
            this.talukaName = _data["talukaName"];
            this.districtName = _data["districtName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.countryId = _data["countryId"];
            this.zipCode = _data["zipCode"];
            this.education = _data["education"];
            this.bloodGroup = _data["bloodGroup"];
            this.userId = _data["userId"];
            this.profileImageURL = _data["profileImageURL"];
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.profileBase64Image = _data["profileBase64Image"];
            this.profileImageContentType = _data["profileImageContentType"];
        }
    }

    static fromJS(data: any): CabDriverProfileAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverProfileAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cabDriverId"] = this.cabDriverId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["mobileNumber"] = this.mobileNumber;
        data["cabDriverFullName"] = this.cabDriverFullName;
        data["emailId"] = this.emailId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["talukaId"] = this.talukaId;
        data["districtId"] = this.districtId;
        data["stateId"] = this.stateId;
        data["talukaName"] = this.talukaName;
        data["districtName"] = this.districtName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["countryId"] = this.countryId;
        data["zipCode"] = this.zipCode;
        data["education"] = this.education;
        data["bloodGroup"] = this.bloodGroup;
        data["userId"] = this.userId;
        data["profileImageURL"] = this.profileImageURL;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["profileBase64Image"] = this.profileBase64Image;
        data["profileImageContentType"] = this.profileImageContentType;
        return data;
    }

    clone(): CabDriverProfileAppDto {
        const json = this.toJSON();
        let result = new CabDriverProfileAppDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverProfileAppDto {
    cabDriverId: number | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    mobileNumber: string | undefined;
    cabDriverFullName: string | undefined;
    emailId: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    talukaId: number | undefined;
    districtId: number | undefined;
    stateId: number | undefined;
    talukaName: string | undefined;
    districtName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    countryId: number | undefined;
    zipCode: string | undefined;
    education: string | undefined;
    bloodGroup: string | undefined;
    userId: number | undefined;
    profileImageURL: string | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthDate: moment.Moment | undefined;
    profileBase64Image: string | undefined;
    profileImageContentType: string | undefined;
}

export class CabDriverRouteListDto implements ICabDriverRouteListDto {
    cabDriverRouteList!: CabDriverAppRouteDto[] | undefined;

    constructor(data?: ICabDriverRouteListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cabDriverRouteList"])) {
                this.cabDriverRouteList = [] as any;
                for (let item of _data["cabDriverRouteList"])
                    this.cabDriverRouteList!.push(CabDriverAppRouteDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CabDriverRouteListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverRouteListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cabDriverRouteList)) {
            data["cabDriverRouteList"] = [];
            for (let item of this.cabDriverRouteList)
                data["cabDriverRouteList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CabDriverRouteListDto {
        const json = this.toJSON();
        let result = new CabDriverRouteListDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverRouteListDto {
    cabDriverRouteList: CabDriverAppRouteDto[] | undefined;
}

export class CabDriverAppRouteDto implements ICabDriverAppRouteDto {
    routeId!: number | undefined;
    routeName!: string | undefined;
    cabDriverId!: number;
    schoolCode!: string | undefined;

    constructor(data?: ICabDriverAppRouteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeId = _data["routeId"];
            this.routeName = _data["routeName"];
            this.cabDriverId = _data["cabDriverId"];
            this.schoolCode = _data["schoolCode"];
        }
    }

    static fromJS(data: any): CabDriverAppRouteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverAppRouteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeId"] = this.routeId;
        data["routeName"] = this.routeName;
        data["cabDriverId"] = this.cabDriverId;
        data["schoolCode"] = this.schoolCode;
        return data;
    }

    clone(): CabDriverAppRouteDto {
        const json = this.toJSON();
        let result = new CabDriverAppRouteDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverAppRouteDto {
    routeId: number | undefined;
    routeName: string | undefined;
    cabDriverId: number;
    schoolCode: string | undefined;
}

export class CabdriverAppStoppageStudentDto implements ICabdriverAppStoppageStudentDto {
    tripId!: number | undefined;
    cabDriverStoppageList!: CabdriverAppStoppageDto[] | undefined;
    cabDriverStudentList!: CabdriverAppStudentDto[] | undefined;

    constructor(data?: ICabdriverAppStoppageStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tripId = _data["tripId"];
            if (Array.isArray(_data["cabDriverStoppageList"])) {
                this.cabDriverStoppageList = [] as any;
                for (let item of _data["cabDriverStoppageList"])
                    this.cabDriverStoppageList!.push(CabdriverAppStoppageDto.fromJS(item));
            }
            if (Array.isArray(_data["cabDriverStudentList"])) {
                this.cabDriverStudentList = [] as any;
                for (let item of _data["cabDriverStudentList"])
                    this.cabDriverStudentList!.push(CabdriverAppStudentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CabdriverAppStoppageStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabdriverAppStoppageStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripId"] = this.tripId;
        if (Array.isArray(this.cabDriverStoppageList)) {
            data["cabDriverStoppageList"] = [];
            for (let item of this.cabDriverStoppageList)
                data["cabDriverStoppageList"].push(item.toJSON());
        }
        if (Array.isArray(this.cabDriverStudentList)) {
            data["cabDriverStudentList"] = [];
            for (let item of this.cabDriverStudentList)
                data["cabDriverStudentList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CabdriverAppStoppageStudentDto {
        const json = this.toJSON();
        let result = new CabdriverAppStoppageStudentDto();
        result.init(json);
        return result;
    }
}

export interface ICabdriverAppStoppageStudentDto {
    tripId: number | undefined;
    cabDriverStoppageList: CabdriverAppStoppageDto[] | undefined;
    cabDriverStudentList: CabdriverAppStudentDto[] | undefined;
}

export class CabdriverAppStoppageDto implements ICabdriverAppStoppageDto {
    tripId!: number | undefined;
    routeId!: number | undefined;
    stoppageName!: string | undefined;
    stoppageId!: number | undefined;
    orderNo!: number;
    totalStudent!: number;

    constructor(data?: ICabdriverAppStoppageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tripId = _data["tripId"];
            this.routeId = _data["routeId"];
            this.stoppageName = _data["stoppageName"];
            this.stoppageId = _data["stoppageId"];
            this.orderNo = _data["orderNo"];
            this.totalStudent = _data["totalStudent"];
        }
    }

    static fromJS(data: any): CabdriverAppStoppageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabdriverAppStoppageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripId"] = this.tripId;
        data["routeId"] = this.routeId;
        data["stoppageName"] = this.stoppageName;
        data["stoppageId"] = this.stoppageId;
        data["orderNo"] = this.orderNo;
        data["totalStudent"] = this.totalStudent;
        return data;
    }

    clone(): CabdriverAppStoppageDto {
        const json = this.toJSON();
        let result = new CabdriverAppStoppageDto();
        result.init(json);
        return result;
    }
}

export interface ICabdriverAppStoppageDto {
    tripId: number | undefined;
    routeId: number | undefined;
    stoppageName: string | undefined;
    stoppageId: number | undefined;
    orderNo: number;
    totalStudent: number;
}

export class CabdriverAppStudentDto implements ICabdriverAppStudentDto {
    routeId!: number | undefined;
    studentName!: string | undefined;
    className!: string;
    emergencyContactNumber!: string;
    gender!: string | undefined;
    contactNumber!: number | undefined;
    stoppageName!: string | undefined;
    profileImageURL!: string | undefined;
    stoppageId!: number | undefined;
    consumerId!: number | undefined;
    roleId!: number | undefined;
    studentId!: number | undefined;
    isAlreadyPickedDropped!: boolean;

    constructor(data?: ICabdriverAppStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeId = _data["routeId"];
            this.studentName = _data["studentName"];
            this.className = _data["className"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.gender = _data["gender"];
            this.contactNumber = _data["contactNumber"];
            this.stoppageName = _data["stoppageName"];
            this.profileImageURL = _data["profileImageURL"];
            this.stoppageId = _data["stoppageId"];
            this.consumerId = _data["consumerId"];
            this.roleId = _data["roleId"];
            this.studentId = _data["studentId"];
            this.isAlreadyPickedDropped = _data["isAlreadyPickedDropped"];
        }
    }

    static fromJS(data: any): CabdriverAppStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabdriverAppStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeId"] = this.routeId;
        data["studentName"] = this.studentName;
        data["className"] = this.className;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["gender"] = this.gender;
        data["contactNumber"] = this.contactNumber;
        data["stoppageName"] = this.stoppageName;
        data["profileImageURL"] = this.profileImageURL;
        data["stoppageId"] = this.stoppageId;
        data["consumerId"] = this.consumerId;
        data["roleId"] = this.roleId;
        data["studentId"] = this.studentId;
        data["isAlreadyPickedDropped"] = this.isAlreadyPickedDropped;
        return data;
    }

    clone(): CabdriverAppStudentDto {
        const json = this.toJSON();
        let result = new CabdriverAppStudentDto();
        result.init(json);
        return result;
    }
}

export interface ICabdriverAppStudentDto {
    routeId: number | undefined;
    studentName: string | undefined;
    className: string;
    emergencyContactNumber: string;
    gender: string | undefined;
    contactNumber: number | undefined;
    stoppageName: string | undefined;
    profileImageURL: string | undefined;
    stoppageId: number | undefined;
    consumerId: number | undefined;
    roleId: number | undefined;
    studentId: number | undefined;
    isAlreadyPickedDropped: boolean;
}

export class CabDriverTripDto implements ICabDriverTripDto {
    routeId!: number | undefined;
    tripId!: number;
    tripType!: string | undefined;
    isTripEnd!: boolean;
    studentId!: number | undefined;

    constructor(data?: ICabDriverTripDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeId = _data["routeId"];
            this.tripId = _data["tripId"];
            this.tripType = _data["tripType"];
            this.isTripEnd = _data["isTripEnd"];
            this.studentId = _data["studentId"];
        }
    }

    static fromJS(data: any): CabDriverTripDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverTripDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeId"] = this.routeId;
        data["tripId"] = this.tripId;
        data["tripType"] = this.tripType;
        data["isTripEnd"] = this.isTripEnd;
        data["studentId"] = this.studentId;
        return data;
    }

    clone(): CabDriverTripDto {
        const json = this.toJSON();
        let result = new CabDriverTripDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverTripDto {
    routeId: number | undefined;
    tripId: number;
    tripType: string | undefined;
    isTripEnd: boolean;
    studentId: number | undefined;
}

export class CabDriverAppTripDetailsDto implements ICabDriverAppTripDetailsDto {
    tripDetailId!: number;
    tripId!: number;
    studentId!: number;
    pickUpDateTime!: moment.Moment;
    dropOffDateTime!: moment.Moment;
    tripType!: string;

    constructor(data?: ICabDriverAppTripDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tripDetailId = _data["tripDetailId"];
            this.tripId = _data["tripId"];
            this.studentId = _data["studentId"];
            this.pickUpDateTime = _data["pickUpDateTime"] ? moment(_data["pickUpDateTime"].toString()) : <any>undefined;
            this.dropOffDateTime = _data["dropOffDateTime"] ? moment(_data["dropOffDateTime"].toString()) : <any>undefined;
            this.tripType = _data["tripType"];
        }
    }

    static fromJS(data: any): CabDriverAppTripDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverAppTripDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripDetailId"] = this.tripDetailId;
        data["tripId"] = this.tripId;
        data["studentId"] = this.studentId;
        data["pickUpDateTime"] = this.pickUpDateTime ? this.pickUpDateTime.toISOString() : <any>undefined;
        data["dropOffDateTime"] = this.dropOffDateTime ? this.dropOffDateTime.toISOString() : <any>undefined;
        data["tripType"] = this.tripType;
        return data;
    }

    clone(): CabDriverAppTripDetailsDto {
        const json = this.toJSON();
        let result = new CabDriverAppTripDetailsDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverAppTripDetailsDto {
    tripDetailId: number;
    tripId: number;
    studentId: number;
    pickUpDateTime: moment.Moment;
    dropOffDateTime: moment.Moment;
    tripType: string;
}

export class StudentInformationDto implements IStudentInformationDto {
    studentId!: number;
    studentName!: string;
    gender!: string;
    className!: string;
    emergencyContactNumber!: string;

    constructor(data?: IStudentInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
            this.gender = _data["gender"];
            this.className = _data["className"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
        }
    }

    static fromJS(data: any): StudentInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        data["gender"] = this.gender;
        data["className"] = this.className;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        return data;
    }

    clone(): StudentInformationDto {
        const json = this.toJSON();
        let result = new StudentInformationDto();
        result.init(json);
        return result;
    }
}

export interface IStudentInformationDto {
    studentId: number;
    studentName: string;
    gender: string;
    className: string;
    emergencyContactNumber: string;
}

export class CabDriverLocationDto implements ICabDriverLocationDto {
    tripId!: number;
    lat!: number | undefined;
    long!: number | undefined;

    constructor(data?: ICabDriverLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tripId = _data["tripId"];
            this.lat = _data["lat"];
            this.long = _data["long"];
        }
    }

    static fromJS(data: any): CabDriverLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripId"] = this.tripId;
        data["lat"] = this.lat;
        data["long"] = this.long;
        return data;
    }

    clone(): CabDriverLocationDto {
        const json = this.toJSON();
        let result = new CabDriverLocationDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverLocationDto {
    tripId: number;
    lat: number | undefined;
    long: number | undefined;
}

export class CabDriverTripNotificationResponceDto implements ICabDriverTripNotificationResponceDto {
    notificationStudentList!: CabDriverTripNotificationDto[] | undefined;

    constructor(data?: ICabDriverTripNotificationResponceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notificationStudentList"])) {
                this.notificationStudentList = [] as any;
                for (let item of _data["notificationStudentList"])
                    this.notificationStudentList!.push(CabDriverTripNotificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CabDriverTripNotificationResponceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverTripNotificationResponceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notificationStudentList)) {
            data["notificationStudentList"] = [];
            for (let item of this.notificationStudentList)
                data["notificationStudentList"].push(item.toJSON());
        }
        return data;
    }

    clone(): CabDriverTripNotificationResponceDto {
        const json = this.toJSON();
        let result = new CabDriverTripNotificationResponceDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverTripNotificationResponceDto {
    notificationStudentList: CabDriverTripNotificationDto[] | undefined;
}

export class CabDriverTripNotificationDto implements ICabDriverTripNotificationDto {
    studentId!: number | undefined;
    studentName!: string;

    constructor(data?: ICabDriverTripNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
        }
    }

    static fromJS(data: any): CabDriverTripNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverTripNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        return data;
    }

    clone(): CabDriverTripNotificationDto {
        const json = this.toJSON();
        let result = new CabDriverTripNotificationDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverTripNotificationDto {
    studentId: number | undefined;
    studentName: string;
}

export class CabDriverActiveTripDto implements ICabDriverActiveTripDto {
    tripId!: number;
    tripType!: string;
    tripStatus!: string;
    routeId!: number;

    constructor(data?: ICabDriverActiveTripDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tripId = _data["tripId"];
            this.tripType = _data["tripType"];
            this.tripStatus = _data["tripStatus"];
            this.routeId = _data["routeId"];
        }
    }

    static fromJS(data: any): CabDriverActiveTripDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverActiveTripDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripId"] = this.tripId;
        data["tripType"] = this.tripType;
        data["tripStatus"] = this.tripStatus;
        data["routeId"] = this.routeId;
        return data;
    }

    clone(): CabDriverActiveTripDto {
        const json = this.toJSON();
        let result = new CabDriverActiveTripDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverActiveTripDto {
    tripId: number;
    tripType: string;
    tripStatus: string;
    routeId: number;
}

export class CabDriverActiveTripRequestDto implements ICabDriverActiveTripRequestDto {
    userId!: number;
    routeId!: number;
    tripType!: string;

    constructor(data?: ICabDriverActiveTripRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.routeId = _data["routeId"];
            this.tripType = _data["tripType"];
        }
    }

    static fromJS(data: any): CabDriverActiveTripRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CabDriverActiveTripRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["routeId"] = this.routeId;
        data["tripType"] = this.tripType;
        return data;
    }

    clone(): CabDriverActiveTripRequestDto {
        const json = this.toJSON();
        let result = new CabDriverActiveTripRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICabDriverActiveTripRequestDto {
    userId: number;
    routeId: number;
    tripType: string;
}

export class BulkSelectResponseDto implements IBulkSelectResponseDto {
    headerAttendanceStatusList!: StudentAttendanceStatusUpdateDTO[];
    bulkStudentList!: BulkAttentanceStudentDto[];
    bulkList!: StudentAttendanceStatusUpdateDTO[];

    constructor(data?: IBulkSelectResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["headerAttendanceStatusList"])) {
                this.headerAttendanceStatusList = [] as any;
                for (let item of _data["headerAttendanceStatusList"])
                    this.headerAttendanceStatusList!.push(StudentAttendanceStatusUpdateDTO.fromJS(item));
            }
            if (Array.isArray(_data["bulkStudentList"])) {
                this.bulkStudentList = [] as any;
                for (let item of _data["bulkStudentList"])
                    this.bulkStudentList!.push(BulkAttentanceStudentDto.fromJS(item));
            }
            if (Array.isArray(_data["bulkList"])) {
                this.bulkList = [] as any;
                for (let item of _data["bulkList"])
                    this.bulkList!.push(StudentAttendanceStatusUpdateDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkSelectResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkSelectResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.headerAttendanceStatusList)) {
            data["headerAttendanceStatusList"] = [];
            for (let item of this.headerAttendanceStatusList)
                data["headerAttendanceStatusList"].push(item.toJSON());
        }
        if (Array.isArray(this.bulkStudentList)) {
            data["bulkStudentList"] = [];
            for (let item of this.bulkStudentList)
                data["bulkStudentList"].push(item.toJSON());
        }
        if (Array.isArray(this.bulkList)) {
            data["bulkList"] = [];
            for (let item of this.bulkList)
                data["bulkList"].push(item.toJSON());
        }
        return data;
    }

    clone(): BulkSelectResponseDto {
        const json = this.toJSON();
        let result = new BulkSelectResponseDto();
        result.init(json);
        return result;
    }
}

export interface IBulkSelectResponseDto {
    headerAttendanceStatusList: StudentAttendanceStatusUpdateDTO[];
    bulkStudentList: BulkAttentanceStudentDto[];
    bulkList: StudentAttendanceStatusUpdateDTO[];
}

export class StudentAttendanceStatusUpdateDTO implements IStudentAttendanceStatusUpdateDTO {
    studentId!: number;
    studentName!: string;
    statusId!: number | undefined;
    attendanceDateTime!: moment.Moment | undefined;
    ngbAttendanceDateTime!: SchoolNgbDateModel | undefined;
    month!: string;
    className!: string;
    rollNumber!: string;

    constructor(data?: IStudentAttendanceStatusUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
            this.statusId = _data["statusId"];
            this.attendanceDateTime = _data["attendanceDateTime"] ? moment(_data["attendanceDateTime"].toString()) : <any>undefined;
            this.ngbAttendanceDateTime = _data["ngbAttendanceDateTime"] ? SchoolNgbDateModel.fromJS(_data["ngbAttendanceDateTime"]) : <any>undefined;
            this.month = _data["month"];
            this.className = _data["className"];
            this.rollNumber = _data["rollNumber"];
        }
    }

    static fromJS(data: any): StudentAttendanceStatusUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceStatusUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        data["statusId"] = this.statusId;
        data["attendanceDateTime"] = this.attendanceDateTime ? this.attendanceDateTime.toISOString() : <any>undefined;
        data["ngbAttendanceDateTime"] = this.ngbAttendanceDateTime ? this.ngbAttendanceDateTime.toJSON() : <any>undefined;
        data["month"] = this.month;
        data["className"] = this.className;
        data["rollNumber"] = this.rollNumber;
        return data;
    }

    clone(): StudentAttendanceStatusUpdateDTO {
        const json = this.toJSON();
        let result = new StudentAttendanceStatusUpdateDTO();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceStatusUpdateDTO {
    studentId: number;
    studentName: string;
    statusId: number | undefined;
    attendanceDateTime: moment.Moment | undefined;
    ngbAttendanceDateTime: SchoolNgbDateModel | undefined;
    month: string;
    className: string;
    rollNumber: string;
}

export class BulkAttentanceStudentDto implements IBulkAttentanceStudentDto {
    studentId!: number;
    studentName!: string;
    rollNumber!: string;

    constructor(data?: IBulkAttentanceStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
            this.rollNumber = _data["rollNumber"];
        }
    }

    static fromJS(data: any): BulkAttentanceStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAttentanceStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        data["rollNumber"] = this.rollNumber;
        return data;
    }

    clone(): BulkAttentanceStudentDto {
        const json = this.toJSON();
        let result = new BulkAttentanceStudentDto();
        result.init(json);
        return result;
    }
}

export interface IBulkAttentanceStudentDto {
    studentId: number;
    studentName: string;
    rollNumber: string;
}

export class StudentAttendanceUpdateRequestDto implements IStudentAttendanceUpdateRequestDto {
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    monthId!: number | undefined;
    yearId!: number | undefined;

    constructor(data?: IStudentAttendanceUpdateRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.monthId = _data["monthId"];
            this.yearId = _data["yearId"];
        }
    }

    static fromJS(data: any): StudentAttendanceUpdateRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceUpdateRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["monthId"] = this.monthId;
        data["yearId"] = this.yearId;
        return data;
    }

    clone(): StudentAttendanceUpdateRequestDto {
        const json = this.toJSON();
        let result = new StudentAttendanceUpdateRequestDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceUpdateRequestDto {
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    monthId: number | undefined;
    yearId: number | undefined;
}

export class BulkAttendanceUpdateDto implements IBulkAttendanceUpdateDto {
    academicYearId!: number | undefined;
    academicYearStartMonth!: moment.Moment | undefined;
    gradeId!: number | undefined;
    gradeName!: string;
    status!: string;
    divisionId!: number | undefined;
    divisionName!: string;
    className!: string;
    monthId!: number | undefined;
    year!: number | undefined;
    yearId!: number | undefined;
    month!: string;
    statusId!: number | undefined;
    studentId!: number | undefined;
    attendanceStatus!: string;
    attendanceDateTime!: moment.Moment | undefined;
    ngbAttendanceDateTime!: SchoolNgbDateModel | undefined;
    userId!: number | undefined;
    attendanceStatusList!: BulkAttendanceUpdateUpsertDto[];

    constructor(data?: IBulkAttendanceUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.academicYearStartMonth = _data["academicYearStartMonth"] ? moment(_data["academicYearStartMonth"].toString()) : <any>undefined;
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.status = _data["status"];
            this.divisionId = _data["divisionId"];
            this.divisionName = _data["divisionName"];
            this.className = _data["className"];
            this.monthId = _data["monthId"];
            this.year = _data["year"];
            this.yearId = _data["yearId"];
            this.month = _data["month"];
            this.statusId = _data["statusId"];
            this.studentId = _data["studentId"];
            this.attendanceStatus = _data["attendanceStatus"];
            this.attendanceDateTime = _data["attendanceDateTime"] ? moment(_data["attendanceDateTime"].toString()) : <any>undefined;
            this.ngbAttendanceDateTime = _data["ngbAttendanceDateTime"] ? SchoolNgbDateModel.fromJS(_data["ngbAttendanceDateTime"]) : <any>undefined;
            this.userId = _data["userId"];
            if (Array.isArray(_data["attendanceStatusList"])) {
                this.attendanceStatusList = [] as any;
                for (let item of _data["attendanceStatusList"])
                    this.attendanceStatusList!.push(BulkAttendanceUpdateUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkAttendanceUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAttendanceUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["academicYearStartMonth"] = this.academicYearStartMonth ? this.academicYearStartMonth.toISOString() : <any>undefined;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["status"] = this.status;
        data["divisionId"] = this.divisionId;
        data["divisionName"] = this.divisionName;
        data["className"] = this.className;
        data["monthId"] = this.monthId;
        data["year"] = this.year;
        data["yearId"] = this.yearId;
        data["month"] = this.month;
        data["statusId"] = this.statusId;
        data["studentId"] = this.studentId;
        data["attendanceStatus"] = this.attendanceStatus;
        data["attendanceDateTime"] = this.attendanceDateTime ? this.attendanceDateTime.toISOString() : <any>undefined;
        data["ngbAttendanceDateTime"] = this.ngbAttendanceDateTime ? this.ngbAttendanceDateTime.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        if (Array.isArray(this.attendanceStatusList)) {
            data["attendanceStatusList"] = [];
            for (let item of this.attendanceStatusList)
                data["attendanceStatusList"].push(item.toJSON());
        }
        return data;
    }

    clone(): BulkAttendanceUpdateDto {
        const json = this.toJSON();
        let result = new BulkAttendanceUpdateDto();
        result.init(json);
        return result;
    }
}

export interface IBulkAttendanceUpdateDto {
    academicYearId: number | undefined;
    academicYearStartMonth: moment.Moment | undefined;
    gradeId: number | undefined;
    gradeName: string;
    status: string;
    divisionId: number | undefined;
    divisionName: string;
    className: string;
    monthId: number | undefined;
    year: number | undefined;
    yearId: number | undefined;
    month: string;
    statusId: number | undefined;
    studentId: number | undefined;
    attendanceStatus: string;
    attendanceDateTime: moment.Moment | undefined;
    ngbAttendanceDateTime: SchoolNgbDateModel | undefined;
    userId: number | undefined;
    attendanceStatusList: BulkAttendanceUpdateUpsertDto[];
}

export class BulkAttendanceUpdateUpsertDto implements IBulkAttendanceUpdateUpsertDto {
    studentId!: number;
    statusId!: number | undefined;
    attendanceDateTime!: moment.Moment | undefined;
    ngbAttendanceDateTime!: SchoolNgbDateModel | undefined;

    constructor(data?: IBulkAttendanceUpdateUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.statusId = _data["statusId"];
            this.attendanceDateTime = _data["attendanceDateTime"] ? moment(_data["attendanceDateTime"].toString()) : <any>undefined;
            this.ngbAttendanceDateTime = _data["ngbAttendanceDateTime"] ? SchoolNgbDateModel.fromJS(_data["ngbAttendanceDateTime"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BulkAttendanceUpdateUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAttendanceUpdateUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["statusId"] = this.statusId;
        data["attendanceDateTime"] = this.attendanceDateTime ? this.attendanceDateTime.toISOString() : <any>undefined;
        data["ngbAttendanceDateTime"] = this.ngbAttendanceDateTime ? this.ngbAttendanceDateTime.toJSON() : <any>undefined;
        return data;
    }

    clone(): BulkAttendanceUpdateUpsertDto {
        const json = this.toJSON();
        let result = new BulkAttendanceUpdateUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBulkAttendanceUpdateUpsertDto {
    studentId: number;
    statusId: number | undefined;
    attendanceDateTime: moment.Moment | undefined;
    ngbAttendanceDateTime: SchoolNgbDateModel | undefined;
}

export class AttendanceSummaryBulkResponseDto implements IAttendanceSummaryBulkResponseDto {
    attendanceSummaryList!: StudentAttendanceSummaryDto[];

    constructor(data?: IAttendanceSummaryBulkResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attendanceSummaryList"])) {
                this.attendanceSummaryList = [] as any;
                for (let item of _data["attendanceSummaryList"])
                    this.attendanceSummaryList!.push(StudentAttendanceSummaryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttendanceSummaryBulkResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceSummaryBulkResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attendanceSummaryList)) {
            data["attendanceSummaryList"] = [];
            for (let item of this.attendanceSummaryList)
                data["attendanceSummaryList"].push(item.toJSON());
        }
        return data;
    }

    clone(): AttendanceSummaryBulkResponseDto {
        const json = this.toJSON();
        let result = new AttendanceSummaryBulkResponseDto();
        result.init(json);
        return result;
    }
}

export interface IAttendanceSummaryBulkResponseDto {
    attendanceSummaryList: StudentAttendanceSummaryDto[];
}

export class StudentAttendanceSummaryDto implements IStudentAttendanceSummaryDto {
    studentId!: number;
    rollNumber!: string;
    studentName!: string;
    presentDays!: number;
    absentDays!: number;
    attendanceStatus!: string;
    month!: string;
    className!: string;
    gradeId!: number;
    divisionId!: number;
    monthId!: number;
    yearId!: number;

    constructor(data?: IStudentAttendanceSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.rollNumber = _data["rollNumber"];
            this.studentName = _data["studentName"];
            this.presentDays = _data["presentDays"];
            this.absentDays = _data["absentDays"];
            this.attendanceStatus = _data["attendanceStatus"];
            this.month = _data["month"];
            this.className = _data["className"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.monthId = _data["monthId"];
            this.yearId = _data["yearId"];
        }
    }

    static fromJS(data: any): StudentAttendanceSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["rollNumber"] = this.rollNumber;
        data["studentName"] = this.studentName;
        data["presentDays"] = this.presentDays;
        data["absentDays"] = this.absentDays;
        data["attendanceStatus"] = this.attendanceStatus;
        data["month"] = this.month;
        data["className"] = this.className;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["monthId"] = this.monthId;
        data["yearId"] = this.yearId;
        return data;
    }

    clone(): StudentAttendanceSummaryDto {
        const json = this.toJSON();
        let result = new StudentAttendanceSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceSummaryDto {
    studentId: number;
    rollNumber: string;
    studentName: string;
    presentDays: number;
    absentDays: number;
    attendanceStatus: string;
    month: string;
    className: string;
    gradeId: number;
    divisionId: number;
    monthId: number;
    yearId: number;
}

export class StudentAttendanceStatusInsertDto implements IStudentAttendanceStatusInsertDto {
    academicYearId!: number;
    gradeId!: number;
    divisionId!: number;
    monthId!: number | undefined;
    yearId!: number | undefined;

    constructor(data?: IStudentAttendanceStatusInsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.monthId = _data["monthId"];
            this.yearId = _data["yearId"];
        }
    }

    static fromJS(data: any): StudentAttendanceStatusInsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAttendanceStatusInsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["monthId"] = this.monthId;
        data["yearId"] = this.yearId;
        return data;
    }

    clone(): StudentAttendanceStatusInsertDto {
        const json = this.toJSON();
        let result = new StudentAttendanceStatusInsertDto();
        result.init(json);
        return result;
    }
}

export interface IStudentAttendanceStatusInsertDto {
    academicYearId: number;
    gradeId: number;
    divisionId: number;
    monthId: number | undefined;
    yearId: number | undefined;
}

export class AdminDto implements IAdminDto {
    adminId!: number | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    fullName!: string | undefined;
    address!: string | undefined;
    gender!: string | undefined;
    contactNumber!: string | undefined;
    mobileNumber!: string | undefined;
    emailId!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    talukaId!: number | undefined;
    districtId!: number | undefined;
    stateId!: number | undefined;
    talukaName!: string | undefined;
    districtName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    adharNumber!: string | undefined;
    countryId!: number | undefined;
    zipCode!: string | undefined;
    education!: string | undefined;
    bloodGroup!: string | undefined;
    profileImageURL!: string | undefined;
    userId!: number | undefined;
    ngbBirthDate!: SchoolNgbDateModel | undefined;
    birthDate!: moment.Moment | undefined;
    profileBase64Image!: string | undefined;
    profileImageContentType!: string | undefined;
    isAppAccess!: boolean | undefined;
    appAccessMobileNo!: string | undefined;
    appAccessOneTimePassword!: string | undefined;

    constructor(data?: IAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminId = _data["adminId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.address = _data["address"];
            this.gender = _data["gender"];
            this.contactNumber = _data["contactNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.emailId = _data["emailId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.talukaId = _data["talukaId"];
            this.districtId = _data["districtId"];
            this.stateId = _data["stateId"];
            this.talukaName = _data["talukaName"];
            this.districtName = _data["districtName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.adharNumber = _data["adharNumber"];
            this.countryId = _data["countryId"];
            this.zipCode = _data["zipCode"];
            this.education = _data["education"];
            this.bloodGroup = _data["bloodGroup"];
            this.profileImageURL = _data["profileImageURL"];
            this.userId = _data["userId"];
            this.ngbBirthDate = _data["ngbBirthDate"] ? SchoolNgbDateModel.fromJS(_data["ngbBirthDate"]) : <any>undefined;
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.profileBase64Image = _data["profileBase64Image"];
            this.profileImageContentType = _data["profileImageContentType"];
            this.isAppAccess = _data["isAppAccess"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.appAccessOneTimePassword = _data["appAccessOneTimePassword"];
        }
    }

    static fromJS(data: any): AdminDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminId"] = this.adminId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["address"] = this.address;
        data["gender"] = this.gender;
        data["contactNumber"] = this.contactNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["emailId"] = this.emailId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["talukaId"] = this.talukaId;
        data["districtId"] = this.districtId;
        data["stateId"] = this.stateId;
        data["talukaName"] = this.talukaName;
        data["districtName"] = this.districtName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["adharNumber"] = this.adharNumber;
        data["countryId"] = this.countryId;
        data["zipCode"] = this.zipCode;
        data["education"] = this.education;
        data["bloodGroup"] = this.bloodGroup;
        data["profileImageURL"] = this.profileImageURL;
        data["userId"] = this.userId;
        data["ngbBirthDate"] = this.ngbBirthDate ? this.ngbBirthDate.toJSON() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["profileBase64Image"] = this.profileBase64Image;
        data["profileImageContentType"] = this.profileImageContentType;
        data["isAppAccess"] = this.isAppAccess;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["appAccessOneTimePassword"] = this.appAccessOneTimePassword;
        return data;
    }

    clone(): AdminDto {
        const json = this.toJSON();
        let result = new AdminDto();
        result.init(json);
        return result;
    }
}

export interface IAdminDto {
    adminId: number | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    address: string | undefined;
    gender: string | undefined;
    contactNumber: string | undefined;
    mobileNumber: string | undefined;
    emailId: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    talukaId: number | undefined;
    districtId: number | undefined;
    stateId: number | undefined;
    talukaName: string | undefined;
    districtName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    adharNumber: string | undefined;
    countryId: number | undefined;
    zipCode: string | undefined;
    education: string | undefined;
    bloodGroup: string | undefined;
    profileImageURL: string | undefined;
    userId: number | undefined;
    ngbBirthDate: SchoolNgbDateModel | undefined;
    birthDate: moment.Moment | undefined;
    profileBase64Image: string | undefined;
    profileImageContentType: string | undefined;
    isAppAccess: boolean | undefined;
    appAccessMobileNo: string | undefined;
    appAccessOneTimePassword: string | undefined;
}

export class AdminDeleteRespose implements IAdminDeleteRespose {
    affectedRows!: number;

    constructor(data?: IAdminDeleteRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.affectedRows = _data["affectedRows"];
        }
    }

    static fromJS(data: any): AdminDeleteRespose {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDeleteRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedRows"] = this.affectedRows;
        return data;
    }

    clone(): AdminDeleteRespose {
        const json = this.toJSON();
        let result = new AdminDeleteRespose();
        result.init(json);
        return result;
    }
}

export interface IAdminDeleteRespose {
    affectedRows: number;
}

export class AdhocParticularMasterDtoInsertRespose implements IAdhocParticularMasterDtoInsertRespose {
    exits!: number;

    constructor(data?: IAdhocParticularMasterDtoInsertRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exits = _data["exits"];
        }
    }

    static fromJS(data: any): AdhocParticularMasterDtoInsertRespose {
        data = typeof data === 'object' ? data : {};
        let result = new AdhocParticularMasterDtoInsertRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exits"] = this.exits;
        return data;
    }

    clone(): AdhocParticularMasterDtoInsertRespose {
        const json = this.toJSON();
        let result = new AdhocParticularMasterDtoInsertRespose();
        result.init(json);
        return result;
    }
}

export interface IAdhocParticularMasterDtoInsertRespose {
    exits: number;
}

export class AdhocParticularMasterDto implements IAdhocParticularMasterDto {
    adhocParticularMasterId!: number | undefined;
    particular!: string | undefined;

    constructor(data?: IAdhocParticularMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adhocParticularMasterId = _data["adhocParticularMasterId"];
            this.particular = _data["particular"];
        }
    }

    static fromJS(data: any): AdhocParticularMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdhocParticularMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adhocParticularMasterId"] = this.adhocParticularMasterId;
        data["particular"] = this.particular;
        return data;
    }

    clone(): AdhocParticularMasterDto {
        const json = this.toJSON();
        let result = new AdhocParticularMasterDto();
        result.init(json);
        return result;
    }
}

export interface IAdhocParticularMasterDto {
    adhocParticularMasterId: number | undefined;
    particular: string | undefined;
}

export class AdhocParticularMasterDtoListRespose implements IAdhocParticularMasterDtoListRespose {
    particulars!: AdhocParticularMasterDto[];

    constructor(data?: IAdhocParticularMasterDtoListRespose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["particulars"])) {
                this.particulars = [] as any;
                for (let item of _data["particulars"])
                    this.particulars!.push(AdhocParticularMasterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdhocParticularMasterDtoListRespose {
        data = typeof data === 'object' ? data : {};
        let result = new AdhocParticularMasterDtoListRespose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.particulars)) {
            data["particulars"] = [];
            for (let item of this.particulars)
                data["particulars"].push(item.toJSON());
        }
        return data;
    }

    clone(): AdhocParticularMasterDtoListRespose {
        const json = this.toJSON();
        let result = new AdhocParticularMasterDtoListRespose();
        result.init(json);
        return result;
    }
}

export interface IAdhocParticularMasterDtoListRespose {
    particulars: AdhocParticularMasterDto[];
}

export class AdhocFeePaymentSelectDto implements IAdhocFeePaymentSelectDto {
    fullName!: string;
    generalRegistrationNo!: string;
    isNewStudent!: boolean;
    isRTEStudent!: boolean;
    appAccessMobileNo!: string;
    academicYearId!: number;
    rollNumber!: string;
    gradeName!: string;
    divisionName!: string;

    constructor(data?: IAdhocFeePaymentSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.isNewStudent = _data["isNewStudent"];
            this.isRTEStudent = _data["isRTEStudent"];
            this.appAccessMobileNo = _data["appAccessMobileNo"];
            this.academicYearId = _data["academicYearId"];
            this.rollNumber = _data["rollNumber"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
        }
    }

    static fromJS(data: any): AdhocFeePaymentSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdhocFeePaymentSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["isNewStudent"] = this.isNewStudent;
        data["isRTEStudent"] = this.isRTEStudent;
        data["appAccessMobileNo"] = this.appAccessMobileNo;
        data["academicYearId"] = this.academicYearId;
        data["rollNumber"] = this.rollNumber;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        return data;
    }

    clone(): AdhocFeePaymentSelectDto {
        const json = this.toJSON();
        let result = new AdhocFeePaymentSelectDto();
        result.init(json);
        return result;
    }
}

export interface IAdhocFeePaymentSelectDto {
    fullName: string;
    generalRegistrationNo: string;
    isNewStudent: boolean;
    isRTEStudent: boolean;
    appAccessMobileNo: string;
    academicYearId: number;
    rollNumber: string;
    gradeName: string;
    divisionName: string;
}

export class AdhocFeePaymentUpsertDto implements IAdhocFeePaymentUpsertDto {
    academicYearId!: number | undefined;
    gradeId!: number | undefined;
    divisionId!: number | undefined;
    studentId!: number | undefined;
    onlineTransactionId!: string | undefined;
    onlineTransactionDateTime!: moment.Moment | undefined;
    ngbOnlineTransactionDateTime!: SchoolNgbDateModel | undefined;
    onlinePaymentRequest!: string | undefined;
    onlinePaymentResponse!: string | undefined;
    paidToBank!: string | undefined;
    totalFee!: number | undefined;
    particularId!: number | undefined;
    paymentTypeId!: number | undefined;
    chequeNumber!: string;
    chequeDate!: moment.Moment | undefined;
    ngbChequeDate!: SchoolNgbDateModel | undefined;
    chequeBank!: string;
    chequeAmount!: number | undefined;
    isChequeClear!: boolean | undefined;
    userId!: number | undefined;

    constructor(data?: IAdhocFeePaymentUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicYearId = _data["academicYearId"];
            this.gradeId = _data["gradeId"];
            this.divisionId = _data["divisionId"];
            this.studentId = _data["studentId"];
            this.onlineTransactionId = _data["onlineTransactionId"];
            this.onlineTransactionDateTime = _data["onlineTransactionDateTime"] ? moment(_data["onlineTransactionDateTime"].toString()) : <any>undefined;
            this.ngbOnlineTransactionDateTime = _data["ngbOnlineTransactionDateTime"] ? SchoolNgbDateModel.fromJS(_data["ngbOnlineTransactionDateTime"]) : <any>undefined;
            this.onlinePaymentRequest = _data["onlinePaymentRequest"];
            this.onlinePaymentResponse = _data["onlinePaymentResponse"];
            this.paidToBank = _data["paidToBank"];
            this.totalFee = _data["totalFee"];
            this.particularId = _data["particularId"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.ngbChequeDate = _data["ngbChequeDate"] ? SchoolNgbDateModel.fromJS(_data["ngbChequeDate"]) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.chequeAmount = _data["chequeAmount"];
            this.isChequeClear = _data["isChequeClear"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AdhocFeePaymentUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdhocFeePaymentUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicYearId"] = this.academicYearId;
        data["gradeId"] = this.gradeId;
        data["divisionId"] = this.divisionId;
        data["studentId"] = this.studentId;
        data["onlineTransactionId"] = this.onlineTransactionId;
        data["onlineTransactionDateTime"] = this.onlineTransactionDateTime ? this.onlineTransactionDateTime.toISOString() : <any>undefined;
        data["ngbOnlineTransactionDateTime"] = this.ngbOnlineTransactionDateTime ? this.ngbOnlineTransactionDateTime.toJSON() : <any>undefined;
        data["onlinePaymentRequest"] = this.onlinePaymentRequest;
        data["onlinePaymentResponse"] = this.onlinePaymentResponse;
        data["paidToBank"] = this.paidToBank;
        data["totalFee"] = this.totalFee;
        data["particularId"] = this.particularId;
        data["paymentTypeId"] = this.paymentTypeId;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["ngbChequeDate"] = this.ngbChequeDate ? this.ngbChequeDate.toJSON() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["chequeAmount"] = this.chequeAmount;
        data["isChequeClear"] = this.isChequeClear;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AdhocFeePaymentUpsertDto {
        const json = this.toJSON();
        let result = new AdhocFeePaymentUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IAdhocFeePaymentUpsertDto {
    academicYearId: number | undefined;
    gradeId: number | undefined;
    divisionId: number | undefined;
    studentId: number | undefined;
    onlineTransactionId: string | undefined;
    onlineTransactionDateTime: moment.Moment | undefined;
    ngbOnlineTransactionDateTime: SchoolNgbDateModel | undefined;
    onlinePaymentRequest: string | undefined;
    onlinePaymentResponse: string | undefined;
    paidToBank: string | undefined;
    totalFee: number | undefined;
    particularId: number | undefined;
    paymentTypeId: number | undefined;
    chequeNumber: string;
    chequeDate: moment.Moment | undefined;
    ngbChequeDate: SchoolNgbDateModel | undefined;
    chequeBank: string;
    chequeAmount: number | undefined;
    isChequeClear: boolean | undefined;
    userId: number | undefined;
}

export class AdhocFeePaymentHistorySelectDto implements IAdhocFeePaymentHistorySelectDto {
    schoolName!: string;
    schoolAddress!: string;
    academicYearId!: number;
    studentName!: string;
    gradeName!: string;
    divisionName!: string;
    rollNumber!: string;
    generalRegistrationNo!: string | undefined;
    paymentTypeName!: string;
    paymentDate!: moment.Moment | undefined;
    chequeDate!: moment.Moment | undefined;
    chequeBank!: string;
    transactionId!: string;
    invoiceNumber!: string;
    totalFee!: number | undefined;
    particular!: string | undefined;

    constructor(data?: IAdhocFeePaymentHistorySelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schoolName = _data["schoolName"];
            this.schoolAddress = _data["schoolAddress"];
            this.academicYearId = _data["academicYearId"];
            this.studentName = _data["studentName"];
            this.gradeName = _data["gradeName"];
            this.divisionName = _data["divisionName"];
            this.rollNumber = _data["rollNumber"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.transactionId = _data["transactionId"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.totalFee = _data["totalFee"];
            this.particular = _data["particular"];
        }
    }

    static fromJS(data: any): AdhocFeePaymentHistorySelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdhocFeePaymentHistorySelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schoolName"] = this.schoolName;
        data["schoolAddress"] = this.schoolAddress;
        data["academicYearId"] = this.academicYearId;
        data["studentName"] = this.studentName;
        data["gradeName"] = this.gradeName;
        data["divisionName"] = this.divisionName;
        data["rollNumber"] = this.rollNumber;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["paymentTypeName"] = this.paymentTypeName;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["transactionId"] = this.transactionId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["totalFee"] = this.totalFee;
        data["particular"] = this.particular;
        return data;
    }

    clone(): AdhocFeePaymentHistorySelectDto {
        const json = this.toJSON();
        let result = new AdhocFeePaymentHistorySelectDto();
        result.init(json);
        return result;
    }
}

export interface IAdhocFeePaymentHistorySelectDto {
    schoolName: string;
    schoolAddress: string;
    academicYearId: number;
    studentName: string;
    gradeName: string;
    divisionName: string;
    rollNumber: string;
    generalRegistrationNo: string | undefined;
    paymentTypeName: string;
    paymentDate: moment.Moment | undefined;
    chequeDate: moment.Moment | undefined;
    chequeBank: string;
    transactionId: string;
    invoiceNumber: string;
    totalFee: number | undefined;
    particular: string | undefined;
}

export class AdhocFeePaymentDaywiseReportDto implements IAdhocFeePaymentDaywiseReportDto {
    cashDaywiseAdhocPaymentReport!: CashDaywiseAdhocPaymentReport;
    chequeDaywiseAdhocPaymentReport!: ChequeDaywiseAdhocPaymentReport;
    ddDaywiseAdhocPaymentReport!: DDDaywiseAdhocPaymentReport;
    upiAdhocPaymentDaywiseReport!: UpiAdhocPaymentDaywiseReport;
    netBankingAdhocDaywisePaymentReport!: NetBankingAdhocDaywisePaymentReport;
    cardDaywiseAdhocPaymentReport!: CardDaywiseAdhocPaymentReport;

    constructor(data?: IAdhocFeePaymentDaywiseReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashDaywiseAdhocPaymentReport = _data["cashDaywiseAdhocPaymentReport"] ? CashDaywiseAdhocPaymentReport.fromJS(_data["cashDaywiseAdhocPaymentReport"]) : <any>undefined;
            this.chequeDaywiseAdhocPaymentReport = _data["chequeDaywiseAdhocPaymentReport"] ? ChequeDaywiseAdhocPaymentReport.fromJS(_data["chequeDaywiseAdhocPaymentReport"]) : <any>undefined;
            this.ddDaywiseAdhocPaymentReport = _data["ddDaywiseAdhocPaymentReport"] ? DDDaywiseAdhocPaymentReport.fromJS(_data["ddDaywiseAdhocPaymentReport"]) : <any>undefined;
            this.upiAdhocPaymentDaywiseReport = _data["upiAdhocPaymentDaywiseReport"] ? UpiAdhocPaymentDaywiseReport.fromJS(_data["upiAdhocPaymentDaywiseReport"]) : <any>undefined;
            this.netBankingAdhocDaywisePaymentReport = _data["netBankingAdhocDaywisePaymentReport"] ? NetBankingAdhocDaywisePaymentReport.fromJS(_data["netBankingAdhocDaywisePaymentReport"]) : <any>undefined;
            this.cardDaywiseAdhocPaymentReport = _data["cardDaywiseAdhocPaymentReport"] ? CardDaywiseAdhocPaymentReport.fromJS(_data["cardDaywiseAdhocPaymentReport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdhocFeePaymentDaywiseReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdhocFeePaymentDaywiseReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashDaywiseAdhocPaymentReport"] = this.cashDaywiseAdhocPaymentReport ? this.cashDaywiseAdhocPaymentReport.toJSON() : <any>undefined;
        data["chequeDaywiseAdhocPaymentReport"] = this.chequeDaywiseAdhocPaymentReport ? this.chequeDaywiseAdhocPaymentReport.toJSON() : <any>undefined;
        data["ddDaywiseAdhocPaymentReport"] = this.ddDaywiseAdhocPaymentReport ? this.ddDaywiseAdhocPaymentReport.toJSON() : <any>undefined;
        data["upiAdhocPaymentDaywiseReport"] = this.upiAdhocPaymentDaywiseReport ? this.upiAdhocPaymentDaywiseReport.toJSON() : <any>undefined;
        data["netBankingAdhocDaywisePaymentReport"] = this.netBankingAdhocDaywisePaymentReport ? this.netBankingAdhocDaywisePaymentReport.toJSON() : <any>undefined;
        data["cardDaywiseAdhocPaymentReport"] = this.cardDaywiseAdhocPaymentReport ? this.cardDaywiseAdhocPaymentReport.toJSON() : <any>undefined;
        return data;
    }

    clone(): AdhocFeePaymentDaywiseReportDto {
        const json = this.toJSON();
        let result = new AdhocFeePaymentDaywiseReportDto();
        result.init(json);
        return result;
    }
}

export interface IAdhocFeePaymentDaywiseReportDto {
    cashDaywiseAdhocPaymentReport: CashDaywiseAdhocPaymentReport;
    chequeDaywiseAdhocPaymentReport: ChequeDaywiseAdhocPaymentReport;
    ddDaywiseAdhocPaymentReport: DDDaywiseAdhocPaymentReport;
    upiAdhocPaymentDaywiseReport: UpiAdhocPaymentDaywiseReport;
    netBankingAdhocDaywisePaymentReport: NetBankingAdhocDaywisePaymentReport;
    cardDaywiseAdhocPaymentReport: CardDaywiseAdhocPaymentReport;
}

export class CashDaywiseAdhocPaymentReport implements ICashDaywiseAdhocPaymentReport {
    cashDaywiseAdhocPaymentReportList!: DaywiseAdhocPaymentReport[];
    cashAdhocDaywisePaymentReportTotal!: DaywiseAdhocPaymentReportTotal;

    constructor(data?: ICashDaywiseAdhocPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cashDaywiseAdhocPaymentReportList"])) {
                this.cashDaywiseAdhocPaymentReportList = [] as any;
                for (let item of _data["cashDaywiseAdhocPaymentReportList"])
                    this.cashDaywiseAdhocPaymentReportList!.push(DaywiseAdhocPaymentReport.fromJS(item));
            }
            this.cashAdhocDaywisePaymentReportTotal = _data["cashAdhocDaywisePaymentReportTotal"] ? DaywiseAdhocPaymentReportTotal.fromJS(_data["cashAdhocDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashDaywiseAdhocPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new CashDaywiseAdhocPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cashDaywiseAdhocPaymentReportList)) {
            data["cashDaywiseAdhocPaymentReportList"] = [];
            for (let item of this.cashDaywiseAdhocPaymentReportList)
                data["cashDaywiseAdhocPaymentReportList"].push(item.toJSON());
        }
        data["cashAdhocDaywisePaymentReportTotal"] = this.cashAdhocDaywisePaymentReportTotal ? this.cashAdhocDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): CashDaywiseAdhocPaymentReport {
        const json = this.toJSON();
        let result = new CashDaywiseAdhocPaymentReport();
        result.init(json);
        return result;
    }
}

export interface ICashDaywiseAdhocPaymentReport {
    cashDaywiseAdhocPaymentReportList: DaywiseAdhocPaymentReport[];
    cashAdhocDaywisePaymentReportTotal: DaywiseAdhocPaymentReportTotal;
}

export class DaywiseAdhocPaymentReport implements IDaywiseAdhocPaymentReport {
    studentName!: string;
    class!: string;
    generalRegistrationNo!: string;
    chequeNumber!: string;
    chequeDate!: moment.Moment;
    chequeBank!: string;
    academicYearName!: string;
    paymentAmount!: number;
    invoiceNumber!: string;
    transactionDate!: moment.Moment;
    paymentMode!: string;
    chequeUnclearedAmount!: number;
    transactionBy!: string;
    transactionId!: string;

    constructor(data?: IDaywiseAdhocPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentName = _data["studentName"];
            this.class = _data["class"];
            this.generalRegistrationNo = _data["generalRegistrationNo"];
            this.chequeNumber = _data["chequeNumber"];
            this.chequeDate = _data["chequeDate"] ? moment(_data["chequeDate"].toString()) : <any>undefined;
            this.chequeBank = _data["chequeBank"];
            this.academicYearName = _data["academicYearName"];
            this.paymentAmount = _data["paymentAmount"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.transactionDate = _data["transactionDate"] ? moment(_data["transactionDate"].toString()) : <any>undefined;
            this.paymentMode = _data["paymentMode"];
            this.chequeUnclearedAmount = _data["chequeUnclearedAmount"];
            this.transactionBy = _data["transactionBy"];
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): DaywiseAdhocPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new DaywiseAdhocPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["class"] = this.class;
        data["generalRegistrationNo"] = this.generalRegistrationNo;
        data["chequeNumber"] = this.chequeNumber;
        data["chequeDate"] = this.chequeDate ? this.chequeDate.toISOString() : <any>undefined;
        data["chequeBank"] = this.chequeBank;
        data["academicYearName"] = this.academicYearName;
        data["paymentAmount"] = this.paymentAmount;
        data["invoiceNumber"] = this.invoiceNumber;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["paymentMode"] = this.paymentMode;
        data["chequeUnclearedAmount"] = this.chequeUnclearedAmount;
        data["transactionBy"] = this.transactionBy;
        data["transactionId"] = this.transactionId;
        return data;
    }

    clone(): DaywiseAdhocPaymentReport {
        const json = this.toJSON();
        let result = new DaywiseAdhocPaymentReport();
        result.init(json);
        return result;
    }
}

export interface IDaywiseAdhocPaymentReport {
    studentName: string;
    class: string;
    generalRegistrationNo: string;
    chequeNumber: string;
    chequeDate: moment.Moment;
    chequeBank: string;
    academicYearName: string;
    paymentAmount: number;
    invoiceNumber: string;
    transactionDate: moment.Moment;
    paymentMode: string;
    chequeUnclearedAmount: number;
    transactionBy: string;
    transactionId: string;
}

export class DaywiseAdhocPaymentReportTotal implements IDaywiseAdhocPaymentReportTotal {
    totalPaymentAmount!: number;
    totalChequeUnclearedAmount!: number;

    constructor(data?: IDaywiseAdhocPaymentReportTotal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPaymentAmount = _data["totalPaymentAmount"];
            this.totalChequeUnclearedAmount = _data["totalChequeUnclearedAmount"];
        }
    }

    static fromJS(data: any): DaywiseAdhocPaymentReportTotal {
        data = typeof data === 'object' ? data : {};
        let result = new DaywiseAdhocPaymentReportTotal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPaymentAmount"] = this.totalPaymentAmount;
        data["totalChequeUnclearedAmount"] = this.totalChequeUnclearedAmount;
        return data;
    }

    clone(): DaywiseAdhocPaymentReportTotal {
        const json = this.toJSON();
        let result = new DaywiseAdhocPaymentReportTotal();
        result.init(json);
        return result;
    }
}

export interface IDaywiseAdhocPaymentReportTotal {
    totalPaymentAmount: number;
    totalChequeUnclearedAmount: number;
}

export class ChequeDaywiseAdhocPaymentReport implements IChequeDaywiseAdhocPaymentReport {
    chequeDaywiseAdhocPaymentReportList!: DaywiseAdhocPaymentReport[];
    chequeDaywiseAdhocPaymentReportTotal!: DaywiseAdhocPaymentReportTotal;

    constructor(data?: IChequeDaywiseAdhocPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chequeDaywiseAdhocPaymentReportList"])) {
                this.chequeDaywiseAdhocPaymentReportList = [] as any;
                for (let item of _data["chequeDaywiseAdhocPaymentReportList"])
                    this.chequeDaywiseAdhocPaymentReportList!.push(DaywiseAdhocPaymentReport.fromJS(item));
            }
            this.chequeDaywiseAdhocPaymentReportTotal = _data["chequeDaywiseAdhocPaymentReportTotal"] ? DaywiseAdhocPaymentReportTotal.fromJS(_data["chequeDaywiseAdhocPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChequeDaywiseAdhocPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new ChequeDaywiseAdhocPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chequeDaywiseAdhocPaymentReportList)) {
            data["chequeDaywiseAdhocPaymentReportList"] = [];
            for (let item of this.chequeDaywiseAdhocPaymentReportList)
                data["chequeDaywiseAdhocPaymentReportList"].push(item.toJSON());
        }
        data["chequeDaywiseAdhocPaymentReportTotal"] = this.chequeDaywiseAdhocPaymentReportTotal ? this.chequeDaywiseAdhocPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): ChequeDaywiseAdhocPaymentReport {
        const json = this.toJSON();
        let result = new ChequeDaywiseAdhocPaymentReport();
        result.init(json);
        return result;
    }
}

export interface IChequeDaywiseAdhocPaymentReport {
    chequeDaywiseAdhocPaymentReportList: DaywiseAdhocPaymentReport[];
    chequeDaywiseAdhocPaymentReportTotal: DaywiseAdhocPaymentReportTotal;
}

export class DDDaywiseAdhocPaymentReport implements IDDDaywiseAdhocPaymentReport {
    ddDaywiseAdhocPaymentReportList!: DaywiseAdhocPaymentReport[];
    ddDaywiseAdhocPaymentReportTotal!: DaywiseAdhocPaymentReportTotal;

    constructor(data?: IDDDaywiseAdhocPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ddDaywiseAdhocPaymentReportList"])) {
                this.ddDaywiseAdhocPaymentReportList = [] as any;
                for (let item of _data["ddDaywiseAdhocPaymentReportList"])
                    this.ddDaywiseAdhocPaymentReportList!.push(DaywiseAdhocPaymentReport.fromJS(item));
            }
            this.ddDaywiseAdhocPaymentReportTotal = _data["ddDaywiseAdhocPaymentReportTotal"] ? DaywiseAdhocPaymentReportTotal.fromJS(_data["ddDaywiseAdhocPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DDDaywiseAdhocPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new DDDaywiseAdhocPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ddDaywiseAdhocPaymentReportList)) {
            data["ddDaywiseAdhocPaymentReportList"] = [];
            for (let item of this.ddDaywiseAdhocPaymentReportList)
                data["ddDaywiseAdhocPaymentReportList"].push(item.toJSON());
        }
        data["ddDaywiseAdhocPaymentReportTotal"] = this.ddDaywiseAdhocPaymentReportTotal ? this.ddDaywiseAdhocPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): DDDaywiseAdhocPaymentReport {
        const json = this.toJSON();
        let result = new DDDaywiseAdhocPaymentReport();
        result.init(json);
        return result;
    }
}

export interface IDDDaywiseAdhocPaymentReport {
    ddDaywiseAdhocPaymentReportList: DaywiseAdhocPaymentReport[];
    ddDaywiseAdhocPaymentReportTotal: DaywiseAdhocPaymentReportTotal;
}

export class UpiAdhocPaymentDaywiseReport implements IUpiAdhocPaymentDaywiseReport {
    upiAdhocPaymentDaywisePaymentReportList!: DaywiseAdhocPaymentReport[];
    upiAdhocPaymentDaywisePaymentReportTotal!: DaywiseAdhocPaymentReportTotal;

    constructor(data?: IUpiAdhocPaymentDaywiseReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upiAdhocPaymentDaywisePaymentReportList"])) {
                this.upiAdhocPaymentDaywisePaymentReportList = [] as any;
                for (let item of _data["upiAdhocPaymentDaywisePaymentReportList"])
                    this.upiAdhocPaymentDaywisePaymentReportList!.push(DaywiseAdhocPaymentReport.fromJS(item));
            }
            this.upiAdhocPaymentDaywisePaymentReportTotal = _data["upiAdhocPaymentDaywisePaymentReportTotal"] ? DaywiseAdhocPaymentReportTotal.fromJS(_data["upiAdhocPaymentDaywisePaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpiAdhocPaymentDaywiseReport {
        data = typeof data === 'object' ? data : {};
        let result = new UpiAdhocPaymentDaywiseReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upiAdhocPaymentDaywisePaymentReportList)) {
            data["upiAdhocPaymentDaywisePaymentReportList"] = [];
            for (let item of this.upiAdhocPaymentDaywisePaymentReportList)
                data["upiAdhocPaymentDaywisePaymentReportList"].push(item.toJSON());
        }
        data["upiAdhocPaymentDaywisePaymentReportTotal"] = this.upiAdhocPaymentDaywisePaymentReportTotal ? this.upiAdhocPaymentDaywisePaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpiAdhocPaymentDaywiseReport {
        const json = this.toJSON();
        let result = new UpiAdhocPaymentDaywiseReport();
        result.init(json);
        return result;
    }
}

export interface IUpiAdhocPaymentDaywiseReport {
    upiAdhocPaymentDaywisePaymentReportList: DaywiseAdhocPaymentReport[];
    upiAdhocPaymentDaywisePaymentReportTotal: DaywiseAdhocPaymentReportTotal;
}

export class NetBankingAdhocDaywisePaymentReport implements INetBankingAdhocDaywisePaymentReport {
    netBankingDaywiseAdhocPaymentReportList!: DaywiseAdhocPaymentReport[];
    netBankingDaywiseAdhocPaymentReportTotal!: DaywiseAdhocPaymentReportTotal;

    constructor(data?: INetBankingAdhocDaywisePaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["netBankingDaywiseAdhocPaymentReportList"])) {
                this.netBankingDaywiseAdhocPaymentReportList = [] as any;
                for (let item of _data["netBankingDaywiseAdhocPaymentReportList"])
                    this.netBankingDaywiseAdhocPaymentReportList!.push(DaywiseAdhocPaymentReport.fromJS(item));
            }
            this.netBankingDaywiseAdhocPaymentReportTotal = _data["netBankingDaywiseAdhocPaymentReportTotal"] ? DaywiseAdhocPaymentReportTotal.fromJS(_data["netBankingDaywiseAdhocPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NetBankingAdhocDaywisePaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new NetBankingAdhocDaywisePaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.netBankingDaywiseAdhocPaymentReportList)) {
            data["netBankingDaywiseAdhocPaymentReportList"] = [];
            for (let item of this.netBankingDaywiseAdhocPaymentReportList)
                data["netBankingDaywiseAdhocPaymentReportList"].push(item.toJSON());
        }
        data["netBankingDaywiseAdhocPaymentReportTotal"] = this.netBankingDaywiseAdhocPaymentReportTotal ? this.netBankingDaywiseAdhocPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): NetBankingAdhocDaywisePaymentReport {
        const json = this.toJSON();
        let result = new NetBankingAdhocDaywisePaymentReport();
        result.init(json);
        return result;
    }
}

export interface INetBankingAdhocDaywisePaymentReport {
    netBankingDaywiseAdhocPaymentReportList: DaywiseAdhocPaymentReport[];
    netBankingDaywiseAdhocPaymentReportTotal: DaywiseAdhocPaymentReportTotal;
}

export class CardDaywiseAdhocPaymentReport implements ICardDaywiseAdhocPaymentReport {
    cardDaywiseAdhocPaymentReportList!: DaywiseAdhocPaymentReport[];
    cardDaywiseAdhocPaymentReportTotal!: DaywiseAdhocPaymentReportTotal;

    constructor(data?: ICardDaywiseAdhocPaymentReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cardDaywiseAdhocPaymentReportList"])) {
                this.cardDaywiseAdhocPaymentReportList = [] as any;
                for (let item of _data["cardDaywiseAdhocPaymentReportList"])
                    this.cardDaywiseAdhocPaymentReportList!.push(DaywiseAdhocPaymentReport.fromJS(item));
            }
            this.cardDaywiseAdhocPaymentReportTotal = _data["cardDaywiseAdhocPaymentReportTotal"] ? DaywiseAdhocPaymentReportTotal.fromJS(_data["cardDaywiseAdhocPaymentReportTotal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CardDaywiseAdhocPaymentReport {
        data = typeof data === 'object' ? data : {};
        let result = new CardDaywiseAdhocPaymentReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cardDaywiseAdhocPaymentReportList)) {
            data["cardDaywiseAdhocPaymentReportList"] = [];
            for (let item of this.cardDaywiseAdhocPaymentReportList)
                data["cardDaywiseAdhocPaymentReportList"].push(item.toJSON());
        }
        data["cardDaywiseAdhocPaymentReportTotal"] = this.cardDaywiseAdhocPaymentReportTotal ? this.cardDaywiseAdhocPaymentReportTotal.toJSON() : <any>undefined;
        return data;
    }

    clone(): CardDaywiseAdhocPaymentReport {
        const json = this.toJSON();
        let result = new CardDaywiseAdhocPaymentReport();
        result.init(json);
        return result;
    }
}

export interface ICardDaywiseAdhocPaymentReport {
    cardDaywiseAdhocPaymentReportList: DaywiseAdhocPaymentReport[];
    cardDaywiseAdhocPaymentReportTotal: DaywiseAdhocPaymentReportTotal;
}

export class DaywiseAdhocPaymentReportRequest implements IDaywiseAdhocPaymentReportRequest {
    startDate!: SchoolNgbDateModel;
    endDate!: SchoolNgbDateModel;

    constructor(data?: IDaywiseAdhocPaymentReportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? SchoolNgbDateModel.fromJS(_data["startDate"]) : <any>undefined;
            this.endDate = _data["endDate"] ? SchoolNgbDateModel.fromJS(_data["endDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DaywiseAdhocPaymentReportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DaywiseAdhocPaymentReportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>undefined;
        return data;
    }

    clone(): DaywiseAdhocPaymentReportRequest {
        const json = this.toJSON();
        let result = new DaywiseAdhocPaymentReportRequest();
        result.init(json);
        return result;
    }
}

export interface IDaywiseAdhocPaymentReportRequest {
    startDate: SchoolNgbDateModel;
    endDate: SchoolNgbDateModel;
}

export class PermissionDto implements IPermissionDto {
    moduleId!: number;
    roleId!: number;
    permissionId!: number;
    permissionName!: string | undefined;
    permissionNameKey!: string | undefined;
    isChecked!: boolean | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleId = _data["moduleId"];
            this.roleId = _data["roleId"];
            this.permissionId = _data["permissionId"];
            this.permissionName = _data["permissionName"];
            this.permissionNameKey = _data["permissionNameKey"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["roleId"] = this.roleId;
        data["permissionId"] = this.permissionId;
        data["permissionName"] = this.permissionName;
        data["permissionNameKey"] = this.permissionNameKey;
        data["isChecked"] = this.isChecked;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    moduleId: number;
    roleId: number;
    permissionId: number;
    permissionName: string | undefined;
    permissionNameKey: string | undefined;
    isChecked: boolean | undefined;
}

export class RoleModuleDto implements IRoleModuleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleNameKey!: string | undefined;
    modules!: ModulePermissionDto[] | undefined;

    constructor(data?: IRoleModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleNameKey = _data["roleNameKey"];
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ModulePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleNameKey"] = this.roleNameKey;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleModuleDto {
        const json = this.toJSON();
        let result = new RoleModuleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleModuleDto {
    roleId: number;
    roleName: string | undefined;
    roleNameKey: string | undefined;
    modules: ModulePermissionDto[] | undefined;
}

export class ModulePermissionDto implements IModulePermissionDto {
    moduleId!: number;
    moduleName!: string | undefined;
    moduleNameKey!: string | undefined;
    menuUrl!: string | undefined;
    modulePermissions!: PermissionDto[] | undefined;

    constructor(data?: IModulePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.moduleNameKey = _data["moduleNameKey"];
            this.menuUrl = _data["menuUrl"];
            if (Array.isArray(_data["modulePermissions"])) {
                this.modulePermissions = [] as any;
                for (let item of _data["modulePermissions"])
                    this.modulePermissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModulePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModulePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["moduleNameKey"] = this.moduleNameKey;
        data["menuUrl"] = this.menuUrl;
        if (Array.isArray(this.modulePermissions)) {
            data["modulePermissions"] = [];
            for (let item of this.modulePermissions)
                data["modulePermissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): ModulePermissionDto {
        const json = this.toJSON();
        let result = new ModulePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IModulePermissionDto {
    moduleId: number;
    moduleName: string | undefined;
    moduleNameKey: string | undefined;
    menuUrl: string | undefined;
    modulePermissions: PermissionDto[] | undefined;
}

export class RoleMasterDto implements IRoleMasterDto {
    roles!: RoleModuleDto[] | undefined;

    constructor(data?: IRoleMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleModuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleMasterDto {
        const json = this.toJSON();
        let result = new RoleMasterDto();
        result.init(json);
        return result;
    }
}

export interface IRoleMasterDto {
    roles: RoleModuleDto[] | undefined;
}

export class PermissionMasterDto implements IPermissionMasterDto {
    permissions!: PermissionDto[] | undefined;

    constructor(data?: IPermissionMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionMasterDto {
        const json = this.toJSON();
        let result = new PermissionMasterDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionMasterDto {
    permissions: PermissionDto[] | undefined;
}

export class ModuleMasterDto implements IModuleMasterDto {
    modules!: ModuleDto[];

    constructor(data?: IModuleMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ModuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data;
    }

    clone(): ModuleMasterDto {
        const json = this.toJSON();
        let result = new ModuleMasterDto();
        result.init(json);
        return result;
    }
}

export interface IModuleMasterDto {
    modules: ModuleDto[];
}

export class ModuleDto implements IModuleDto {
    moduleId!: number;
    moduleName!: string;
    moduleKey!: string;
    menuUrl!: string | undefined;

    constructor(data?: IModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.moduleKey = _data["moduleKey"];
            this.menuUrl = _data["menuUrl"];
        }
    }

    static fromJS(data: any): ModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["moduleKey"] = this.moduleKey;
        data["menuUrl"] = this.menuUrl;
        return data;
    }

    clone(): ModuleDto {
        const json = this.toJSON();
        let result = new ModuleDto();
        result.init(json);
        return result;
    }
}

export interface IModuleDto {
    moduleId: number;
    moduleName: string;
    moduleKey: string;
    menuUrl: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}